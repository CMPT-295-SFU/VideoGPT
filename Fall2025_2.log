2025-08-27 15:13:25.862 | Query: R-type | 1
2025-08-27 15:13:33.663 |  Query: R-type | Rating: 5  | 1
2025-09-08 15:15:22.322 | Query: Show me C code on linked list | 1
2025-09-08 15:15:36.876 |  Query: Show me C code on linked list | Rating: 5  | 1
2025-09-08 15:59:03.655 | Query: what code should be written to access array in c language?%20 | 1
2025-09-08 15:59:39.126 | Query: c언어에서 array에 수를 삽입하려해 무슨 명령어가 필요해?%20 | 1
2025-09-08 16:00:22.333 | Query: c언어에서 array에 수를 삽입할 때 array를 다시 정의해야해? dynamic array야?%20%20 | 1
2025-09-08 16:02:17.431 | Query: buffer size가 뭐니?%20 | 1
2025-09-08 16:03:47.834 | Query: in c language, what should be written to insert item into array? | 1
2025-09-08 16:05:22.372 | Query: in c language, what should be written to insert item into arraylist? | 1
2025-09-08 16:05:50.750 | Query: in c language, what should be written to insert item into list? | 1
2025-09-08 16:07:16.872 | Query: in c language, what should be written to insert item into string? | 1
2025-09-08 16:10:28.459 | Query: Ask ChatGPT or TA%20What does s, n and b and do in gdb?%20Show me how to use s, n and b in gdb?%20How to print variable values in C ?%20How to print pointers in hex in C ? | 1
2025-09-08 16:10:47.292 | Query: malloc이 뭐니? | 1
2025-09-08 16:11:41.723 | Query: malloc이 뭐니? c++에서 비슷한 개념이 뭔지 알려줘 | 1
2025-09-08 16:14:04.662 | Query: string을 free 하려면? | 1
2025-09-08 16:29:37.635 | Query: github code가 뭐야? | 1
2025-09-08 16:49:09.559 | Query: iterate가 뭐야? | 1
2025-09-08 16:49:58.219 | Query: tokenize가 뭐야? | 1
2025-09-08 16:51:34.173 | Query: vector char가 뭐야? | 1
2025-09-08 17:11:27.782 | Query: Given this function where 'a' is the array and 'x' is the value to be appended,%20void arraylist_add(arraylist *a, void *x) {%20%20/*%20    typedef struct arraylist%20    {%20        void **buffer;            // pointer to allocated memory%20        unsigned int buffer_size; // Maximum element capacity%20        unsigned int length;      // Current number of elements%20    } arraylist;%20    */%20%20}%20%20would 'a->buffer[a->length] = x;' be the appropriate instrunctions to append given that 'a' has already been alloced? | 1
2025-09-08 17:17:43.313 | Query: /*%20 * Store x at the specified index of the arraylist. Previously stored values%20 * should be moved back rather than overwritten. It is undefined behavior to%20 * insert an element with an index beyond the end of an arraylist.%20 */%20void arraylist_insert(arraylist *a, unsigned int index, void *x)%20{%20    // Hint: Consider how you could implement this function in terms of%20    // arraylist_add()%20%20    // Check if arraylist exists%20    if (a == NULL) {%20        return;%20    }%20%20    // Move previously stored value to the back%20    arraylist_add(a, x);%20%20    // Overwrite previously stored value after previous step%20    a->buffer[index] = x;%20%20    return;%20}%20%20is this an appropriate way to insert x? | 1
2025-09-08 18:15:13.134 | Query:   // TODO: Tokenize processing%20  // TODO:source contains the string to be processed.%20  /** Start processing file and separate into words */%20  /** Pseudocode */%20  // 1. Iterate over characters%20  // 2. if current-character starts word start accumulating into vector_char%20  // 3. if current character terminates word. print and restart word start%20  // check. Free all data.%20  // Hint: Use vector_char%20내 목표가 뭐지..?%20 | 1
2025-09-08 18:35:24.875 | Query:  how can i initialize? | 1
2025-09-08 21:16:44.249 | Query: What does s, n, and b do in gdb?%20 | 1
2025-09-08 21:17:37.544 | Query: Show me how to use s n and b in gdb%20%20 | 1
2025-09-08 21:19:00.465 | Query: how to print variable values in c?%20%20%20 | 1
2025-09-08 21:19:29.735 | Query: how to print pointers in hex in C?%20%20%20%20 | 1
2025-09-08 21:20:24.537 | Query: how to set up launch.json in vscode for debugging c programs?%20 | 1
2025-09-08 21:27:21.279 | Query: how to set up launch.json in vscode for debugging c programs?%20"C/C++: g++ build and debug active file or C/C++: gcc build and debug active file" neither option is showing up under configurations%20 | 1
2025-09-08 21:28:42.244 | Query: "C/C++: g++ build and debug active file or C/C++: gcc build and debug active file" neither option is showing up under configurations%20explain how to edit tasks.json so these options appear%20 | 1
2025-09-08 21:39:18.454 | Query: when i use the Tasks: Configure Default Build Task command, many options show up. what do these mean and which should i choose?%20 | 1
2025-09-08 21:41:16.632 | Query: How to setup launch.json in VSCODE for debugging C programs?%20%20 | 1
2025-09-08 21:42:13.652 | Query: How to setup launch.json in VSCODE for debugging C programs?%20Where should these jsons end up in my files?%20 | 1
2025-09-08 21:55:49.162 | Query: do i just have to change edit the tasks.json and launch.json everytime i need to work on a new project? | 1
2025-09-08 21:56:47.644 | Query: Regarding tasks.json and launch.json, do I need to edit these files if I want to debug a different project to the one in the files? | 1
2025-09-09 12:23:55.932 | Query: write assembly code for a simple loop | 1
2025-09-09 14:37:25.850 | Query: What does s, n and b and do in gdb?%20Show me how to use s, n and b in gdb?%20 | 1
2025-09-09 14:42:22.978 | Query: give a week 1 summary | 1
2025-09-09 14:50:33.439 | Query: how can i find a seg fault and fix it using cgdb%20 | 1
2025-09-09 18:06:12.786 | Query: What is the standard procedure for checking if a ptr is null after using realloc?%20 | 1
2025-09-09 18:08:12.913 | Query: What is the standard procedure for checking if a ptr is null after using realloc?%20What would be the best way to log the error for this class?%20 | 1
2025-09-09 18:11:32.457 | Query: What is memmove?%20 | 1
2025-09-09 18:12:09.996 | Query: What is memmove?%20Is n a required argument? | 1
2025-09-09 18:13:19.555 | Query: All pointers are 2 bytes right? | 1
2025-09-09 18:15:09.410 | Query: If I want to move sequential items from an array with memmove, and the array stores pointers, how could I calculate the number of bytes I need to copy for memmove? | 1
2025-09-09 18:17:56.627 | Query: Does memmove just copy the elements of an array into another section of memory? | 1
2025-09-09 18:19:16.964 | Query: If a pointer has not been assigned memory will memmove automatically assign the memory?%20 | 1
2025-09-09 18:25:03.668 | Query: If the header files are in a folder that is in the same folder as the C source file, how do I compile the source file?%20 | 1
2025-09-09 18:25:52.159 | Query: If the header files are in a folder that is in the same folder as the C source file, how do I compile the source file?%20The folder is in the same folder as the C source file, but the header files are not | 1
2025-09-09 18:38:22.642 | Query: What do these errors from the arraylist practice section of assignment 1 mean?%20malloc(): corrupted top size%20Test interrupted by SIGSEGV. | 1
2025-09-09 18:42:06.262 | Query: What do these errors from the arraylist practice section of assignment 1 mean?%20Test interrupted by SIGABRT | 1
2025-09-09 18:43:59.076 | Query: will fprintf to stderr show up on the terminal? | 1
2025-09-09 18:45:14.665 | Query: What does this error mean from Arraylist practice on Assignment 1?%20free(): double free detected in tcache 2 | 1
2025-09-09 18:49:06.474 | Query: How do I use cgdb on an executable generated by two c files?%20 | 1
2025-09-09 18:55:05.253 | Query: Can you help me read this?%20#5  0x00007ffff7c297b6 in __libc_message_impl (fmt=fmt@entry=0x7ffff7dce8d7 "%s\n") at ../sysdeps/posix/libc_fatal.c:134%20#6  0x00007ffff7ca8ff5 in malloc_printerr (str=str@entry=0x7ffff7dcc6f7 "malloc(): corrupted top size") at ./malloc/malloc.c:5772%20#7  0x00007ffff7cac2fc in _int_malloc (av=av@entry=0x7ffff7e03ac0 <main_arena>, bytes=16) at ./malloc/malloc.c:4447%20#8  0x00007ffff7cad7f2 in __GI___libc_malloc (bytes=<optimized out>) at ./malloc/malloc.c:3328%20#9  0x0000555555556892 in arraylist_new () at arraylist.c:78%20#10 0x000055555555a14a in test1 () at main.c:107%20#11 0x0000555555557fd9 in test_do_run__ (test=0x55555555dc50 <test_list__+16>, index=1) at include/acutest.h:944%20#12 0x00005555555583ef in test_run__ (test=0x55555555dc50 <test_list__+16>, index=1, master_index=1) at include/acutest.h:1115%20#13 0x0000555555559807 in main (argc=1, argv=0x7fffffffe2d8) at include/acutest.h:1634%20From what I'm getting it's crashing due to arraylist_new() which is provided, could I be doing something that is crashing it? This is line 107 in main.c%20  arraylist *a = arraylist_new(); | 1
2025-09-09 19:13:44.543 | Query: Are there reasons for a seg fault other than double freeing, going out of bounds, and trying to access a ptr that is NULL? | 1
2025-09-09 21:04:31.102 | Query: Can you help me debug this resizing code?%20if (a->length == a->buffer_size) {%20        a->buffer_size *= 2;%20        void** temp;%20        temp = (void**)realloc(a->buffer, a->buffer_size * sizeof(void*));%20        if (temp == NULL) {%20            arraylist_free(a);%20            a = NULL;%20            fprintf(stderr, "Memory allocation failed during realloc.\n");%20            exit(1);%20        }%20        free(a->buffer);%20        a->buffer = temp;%20    } | 1
2025-09-09 21:08:41.161 | Query: How could I get the result of putting a variable into a function in cgdb? Do I need to actually put it in the code itself or is there a cgdb command for this? | 1
2025-09-09 21:13:53.485 | Query: What reasons could there be for my buffer_size to become ridiculously large, like 3945469781? It should be coming from this code, and if not then it may be some kind of memory mismanagement%20void arraylist_add(arraylist *a, void *x)%20{%20    // TODO%20    if (a->length == a->buffer_size) {%20        a->buffer_size *= 2;%20        void** temp;%20        temp = (void**)realloc(a->buffer, a->buffer_size * sizeof(void*));%20        if (temp == NULL) {%20            arraylist_free(a);%20            fprintf(stderr, "Memory allocation failed during realloc.\n");%20            exit(1);%20        }%20        a->buffer = temp;%20    }%20    a->buffer[a->length] = x;%20    a->length++;%20} | 1
2025-09-09 21:15:47.183 | Query: How do I add logging for a variable after each modification during runtime? | 1
2025-09-09 21:19:23.705 | Query: How do I move to a specific line in a specific file in cgdb?%20 | 1
2025-09-09 21:19:31.826 |  Query: How do I move to a specific line in a specific file in cgdb?%20 | Rating: 1  | 1
2025-09-09 21:19:52.288 | Query: How do I move to a specific line in cgdb?%20 | 1
2025-09-09 21:19:56.724 |  Query: How do I move to a specific line in cgdb?%20 | Rating: 5  | 1
2025-09-09 21:20:26.203 | Query: How do I move to a specific line in cgdb?%20What if it is in a different folder than the one that cgdb is currently on? | 1
2025-09-09 21:25:54.915 | Query: void arraylist_insert(arraylist *a, unsigned int index, void *x)%20{%20    // TODO%20    // Hint: Consider how you could implement this function in terms of%20    // arraylist_add()%20    unsigned int num_bytes = index * sizeof(void*);%20    arraylist* result = arraylist_new();%20    result->length = index;%20    void** temp;%20    temp = (void**)realloc(result->buffer, a->buffer_size * sizeof(void*));%20    result->buffer_size = a->buffer_size;%20    if (temp == NULL) {%20        arraylist_free(result);%20        arraylist_free(a);%20        fprintf(stderr, "Memory allocation failed during malloc.\n");%20        exit(1);%20    }%20    result->buffer = temp;%20%20    memmove(result->buffer, a->buffer, num_bytes);%20    result->length = index;%20%20    arraylist_add(result, x);%20    for (int i = index; i < a->length+1; i++) {%20        arraylist_add(result, a->buffer[i]);%20    }%20    arraylist_free(a);%20    a = result;%20}%20%20Can you help me debug this code? As soon as it goes out of scope a's buffer size becomes extremely large | 1
2025-09-09 21:38:30.526 | Query: void arraylist_insert(arraylist *a, unsigned int index, void *x)%20{%20    // TODO%20    // Hint: Consider how you could implement this function in terms of%20    // arraylist_add()%20    unsigned int num_bytes = index * sizeof(void*);%20    arraylist* result = arraylist_new();%20    result->length = index;%20    void** temp;%20    temp = (void**)realloc(result->buffer, a->buffer_size * sizeof(void*));%20    result->buffer_size = a->buffer_size;%20    if (temp == NULL) {%20        arraylist_free(result);%20        arraylist_free(a);%20        fprintf(stderr, "Memory allocation failed during malloc.\n");%20        exit(1);%20    }%20    result->buffer = temp;%20%20    memmove(result->buffer, a->buffer, num_bytes);%20    result->length = index;%20%20    arraylist_add(result, x);%20    for (int i = index; i < a->length; i++) {%20        printf("%d\n", a->buffer[i]);%20        arraylist_add(result, a->buffer[i]);%20    }%20    free(a->buffer);%20    a->buffer = result->buffer;%20    free(result);%20}%20Can you debug my code? When printing a->buffer[i] it seems like the int at buffer[i] is underflowed | 1
2025-09-09 21:40:08.185 | Query: void arraylist_insert(arraylist *a, unsigned int index, void *x)%20{%20    // TODO%20    // Hint: Consider how you could implement this function in terms of%20    // arraylist_add()%20    unsigned int num_bytes = index * sizeof(void*);%20    arraylist* result = arraylist_new();%20    result->length = index;%20    void** temp;%20    temp = (void**)realloc(result->buffer, a->buffer_size * sizeof(void*));%20    result->buffer_size = a->buffer_size;%20    if (temp == NULL) {%20        arraylist_free(result);%20        arraylist_free(a);%20        fprintf(stderr, "Memory allocation failed during malloc.\n");%20        exit(1);%20    }%20    result->buffer = temp;%20%20    memmove(result->buffer, a->buffer, num_bytes);%20    result->length = index;%20%20    arraylist_add(result, x);%20    for (int i = index; i < a->length; i++) {%20        printf("%d\n", a->buffer[i]);%20        arraylist_add(result, a->buffer[i]);%20    }%20    free(a->buffer);%20    a->buffer = result->buffer;%20    free(result);%20}%20Can you debug my code? When printing a->buffer[i] it seems like the int at buffer[i] is underflowed%20After removing free(result) at the end it is overflowing | 1
2025-09-09 21:46:21.005 | Query: Is it possible to view the value of a void* through cgdb? | 1
2025-09-09 21:47:28.478 | Query: How do I go back one line in cgdb?%20 | 1
2025-09-09 22:07:54.898 | Query: When a character is converted into ascii in C, which column on the table is used for the conversion? | 1
2025-09-09 22:09:42.895 | Query: Could you tell me what ranges of ascii values represent 0-9, a-z, and A-Z?%20 | 1
2025-09-09 22:26:50.951 | Query: how to do gdbinit in window? | 1
2025-09-09 22:27:10.903 | Query: how to do gdbinit in window in vs code? | 1
2025-09-09 22:55:35.380 | Query: if I type p_generic_list list1, there comes undefined command%20 | 1
2025-09-09 22:55:48.249 | Query: if I type p_generic_list list1, there comes undefined command in gdb%20%20  | 1
2025-09-09 22:57:29.738 | Query: although I defined p_generic_list, if I type p_generic_list list1, there comes undefined command in gdb%20%20  | 1
2025-09-09 23:11:16.336 | Query: how to compile intellij%20%20%20  | 1
2025-09-10 10:44:46.185 | Query: What kind of unit tests should i write for str_cmp in the first assignment? Should I do tests that the provided tests don't cover?%20 | 1
2025-09-10 10:54:28.555 | Query: else printf("TEST CASE 3 PASSED\n"); passed++;%20is this allowed in C?%20 | 1
2025-09-10 10:56:20.585 | Query: else printf("TEST CASE 3 PASSED\n"); passed++;%20is this allowed in C?%20is the passed++ within the else? | 1
2025-09-10 14:29:35.863 | Query: The CPU executes instructions%20! Memory stores data%20! Binary encoding!%20" Instructions are just data%205%20Memory%20CPU%20?%20How are data%20and instructions%20represented? | 1
2025-09-10 14:30:24.229 | Topic: The CPU executes instructions! Memory stores data! Binary encoding!" Instructions are just data5MemoryCPU?How are dataand instructionsrepresented? | 1
2025-09-10 14:30:29.907 | Topic: The CPU executes instructions! Memory stores data! Binary encoding!" Instructions are just data5MemoryCPU?How are dataand instructionsrepresented? | 1
2025-09-10 14:34:06.058 | Query: How does a%20program find its%20data in memory? | 1
2025-09-10 14:38:01.729 | Query: ! If we choose to use 4-bit addresses, how big is our%20address space?%20" i.e. How much space can we “refer to” using our addresses?%20A. 16 bits%20B. 16 bytes%20C. 4 bits%20D. 4 bytes%20E. We’re lost… | 1
2025-09-10 16:44:59.698 | Query: If the word size of a machine is 64-bits, which of the%20following is usually true? (pick all that apply)%20a) 64 bits is the size of a pointer%20b) 64 bits is the size of an integer%20c) 64 bits is the width of a register | 1
2025-09-10 16:46:58.111 | Query: (True/False) By looking at the bits stored in memory,%20I can tell if a particular 4-bytes is being used to%20represent an integer, floating point number, or%20instruction. | 1
2025-09-10 16:50:44.759 | Query: int* ptr;%20int x = 5;%20int y = 2;%20ptr = &x;%20y = 1 + *ptr;%205%20Declares a variable, ptr, that is a pointer to%20(i.e. holds the address of) an int in memory%20Declares two variables, x and y, that hold ints,%20and initializes them to 5 and 2, respectively%20Sets ptr to the address of x%20(“ptr points to x”)%20Sets y to “1 plus the value stored at the%20address held by ptr. Because ptr%20points to x, this is equivalent to y=1+x;%20“Dereference ptr”%20What is *(&y) ? | 1
2025-09-10 17:39:24.134 | Query: can you explain the code line void* calloc(size_t nitems, size_t size) | 1
2025-09-10 17:42:27.899 | Query: can you explain the code line void* calloc(size_t nitems, size_t size) and how it is different from malloc(size_t size) and is there difference between variable size in both?%20 | 1
2025-09-10 21:14:26.060 | Query: hello | 1
2025-09-10 21:14:49.972 | Query: what is the marking scheme for this course%20 | 1
2025-09-10 21:15:23.198 | Query: what are the passing requirements for the exam | 1
2025-09-10 21:15:42.156 | Query: how do i use cgdb | 1
2025-09-10 21:16:16.533 | Query: write a function in C that prints a pointer value%20 | 1
2025-09-11 16:49:06.510 | Query: do I need to assert that new data is not NULL while using realloc?%20 | 1
2025-09-11 17:06:55.122 | Query: In arraylist_free, do I need to assert that *a is NULL? | 1
2025-09-11 17:07:46.773 | Query: In arraylist_free, do I need to use for loop?%20 | 1
2025-09-11 17:08:01.538 | Query: In arraylist_free, do I need to use loop?%20 | 1
2025-09-11 17:09:13.605 | Query: In arraylist_free, do I need to use loop? then how?%20 | 1
2025-09-11 20:50:11.836 | Query: vector_char_t *vector_char_allocate(void) {%20%20  vector_char_t *header = (vector_char_t *)malloc(sizeof(vector_char_t));%20  if (!header)%20    return NULL;%20%20  header->data = NULL;%20  header->len = header->max = 0;%20%20  return header;%20}%20what does this function allocate? | 1
2025-09-11 21:22:48.478 | Query: realloc이 뭐니 | 1
2025-09-11 21:23:20.518 | Query: realloc 에 대해 | 1
2025-09-11 21:24:49.354 | Query: realloc 에 대해 한글로 | 1
2025-09-11 21:25:12.391 | Query: realloc 에 대해 한글로 parameter는? | 1
2025-09-11 21:26:46.401 | Query: malloc의 파라미터 | 1
2025-09-11 21:27:42.080 | Query: arraylist *arraylist_new()%20{%20    arraylist *a = (arraylist *)malloc(sizeof(arraylist));%20    a->buffer = (void **)malloc(4 * sizeof(void *));%20    a->buffer_size = 4;%20    a->length = 0;%20%20    return a;%20}%20이거에 대해 분석 | 1
2025-09-11 21:29:43.936 | Query: malloc 파라미터 한글로 설명 | 1
2025-09-11 21:30:50.788 | Query: malloc 파라미터 한글로 설명 void일 때 | 1
2025-09-11 21:31:36.936 | Query: realloc 파라미터 한글로 설명 void일 때 | 1
2025-09-11 21:32:28.664 | Query: array_list_add 작성 팁 | 1
2025-09-11 21:33:23.631 | Query: array_list_add 작성 팁 한글로 | 1
2025-09-11 21:36:26.273 | Query: assignment1을 하면서 refer하면 좋은 슬라이드 다 보여줘 | 1
2025-09-11 21:36:45.160 | Query: assignment1에 관한 모든 슬라이드 | 1
2025-09-11 21:45:07.163 | Query: memmove에 대해 파라미터, 한글로 설명 | 1
2025-09-11 21:48:55.279 | Query: memmove에 대해 쉽게 설명 | 1
2025-09-11 22:40:41.044 | Query: arraylist free하는 법 | 1
2025-09-11 22:40:54.185 | Query: arraylist free하는 법 assignment1에서! 한글로 | 1
2025-09-11 22:41:08.895 | Query: arraylist free하는 법 ! 한글로 | 1
2025-09-11 22:42:13.636 | Query: arraylist free하는 법 한글로 | 1
2025-09-11 22:42:28.063 | Query: arraylist free하는 법 한글로 c언어 | 1
2025-09-12 10:24:36.846 | Query: assignment 1 에 관련한 슬라이드 | 1
2025-09-12 10:25:00.030 | Query: assignment 1 slide reference? | 1
2025-09-12 10:25:26.303 | Query: slide reference about free%20 | 1
2025-09-12 10:55:32.753 | Query: char* 와 char** 차이%20 | 1
2025-09-12 11:05:04.438 | Query: string comparison에 관한 슬라이드 | 1
2025-09-12 11:05:22.925 | Query: string comparison에 관한 | 1
2025-09-12 11:06:26.661 | Query: string comparison에 대해 | 1
2025-09-12 11:07:14.287 | Query: string comparison에 대해 not use library function | 1
2025-09-12 11:24:07.821 | Query: What does vector_char_allocate() allocate? space for string OR space for pointer to string?%20vector_char_t *vector_char_allocate(void) {%20%20  vector_char_t *header = (vector_char_t *)malloc(sizeof(vector_char_t));%20  if (!header)%20    return NULL;%20%20  header->data = NULL;%20  header->len = header->max = 0;%20%20  return header;%20} | 1
2025-09-12 11:25:36.847 | Query: Where does the header reside?%20vector_char_t *header = vector_char_allocate(); | 1
2025-09-12 11:25:56.069 | Query: Where does the header reside?%20vector_char_t *header = vector_char_allocate();%20stack or heap? | 1
2025-09-12 11:29:57.712 | Query: where is header->data allocated? stack or heap?%20vector_char_t *vector_char_allocate(void) {%20%20  vector_char_t *header = (vector_char_t *)malloc(sizeof(vector_char_t));%20  if (!header)%20    return NULL;%20%20  header->data = NULL;%20  header->len = header->max = 0;%20%20  return header;%20} | 1
2025-09-12 11:37:10.462 | Query: how to iterate string? | 1
2025-09-12 13:09:01.706 | Query: how do you loop over an array in C | 1
2025-09-12 14:04:42.796 | Query: vs_entry_t가 뭐야 | 1
2025-09-12 14:38:28.868 | Query: What does s, n and b and do in gdb?%20Show me how to use s, n and b in gdb?%20How to print variable values in C ?%20How to print pointers in hex in C ? | 1
2025-09-12 15:23:46.521 | Query: (buckets & (buckets - 1)이게 뭐니 | 1
2025-09-12 15:50:49.809 | Query: Could not load source './malloc/./malloc/malloc.c': 'SourceRequest' not supported..%20 | 1
2025-09-12 16:04:10.321 | Query:   if ((n = (struct node *)malloc(sizeof(struct node))) == 0) what is malloc here%20 | 1
2025-09-12 17:21:59.921 | Query: Now that we know how to tokenize, let’s build a dictionary. A dictionary is a collection of all the unify words. e.g.,%20%201. Lorem%202. i%203. dolor%204. sit%205. amet%20%20what does unify words mean? | 1
2025-09-12 18:41:56.986 | Query: should you free a char* | 1
2025-09-12 20:36:03.910 | Query: Do you have information on the assignments in this class?%20 | 1
2025-09-12 23:18:44.128 | Query: How would I modify the print_list to only print the node if the data == 5? | 1
2025-09-12 23:19:24.859 | Query: # Gdb init file for linked list debugging%20# $PWD/.gdbinit%20define p_generic_list%20  set var $n = $arg0%20  while $n%20    print *($n)%20    set var $n = $n->next%20  end%20end%20%20%20document p_generic_list%20        p_generic_list LIST_HEAD_POINTER%20        Print all the fields of the nodes in the linked list pointed to by LIST_HEAD_POINTER. Assumes there is a next field in the struct.%20end%20%20%20%20define indentby%20    printf "\n"%20    set $i_$arg0 = $arg0%20    while $i_$arg0 > 10%20        set $i_$arg0 = $i_$arg0 - 1%20        printf "%c", ' '%20    end%20end%20%20Given this .gdbinit file, how would I modify the print_list to only print the node if the data == 5? | 1
2025-09-13 15:00:52.000 | Query: How much space does a void pointer in c take? How does pointer math change with it | 1
2025-09-13 15:05:28.232 | Topic: How much space does a void pointer in c take? How does pointer math change with it | 1
2025-09-13 15:05:48.160 | Query: What does : Test interrupted by SIGSEGV. mean? | 1
2025-09-13 15:11:21.871 | Query: Debug this pointer array code: %20    arraylist_add(a, x);%20    memmove(a->buffer[index + 1], a->buffer[index], sizeof(a->buffer[index] + (a->length - index)));%20    a->buffer[index] = x; | 1
2025-09-13 15:13:01.490 |  Query: Debug this pointer array code: %20    arraylist_add(a, x);%20    memmove(a->buffer[index + 1], a->buffer[index], sizeof(a->buffer[index] + (a->length - index)));%20    a->buffer[index] = x; | Rating: 5  | 1
2025-09-13 16:08:44.052 | Query: Is there a standard method to decide how many buckets to allocate in a hash table? | 1
2025-09-13 16:27:58.959 | Query: Are there instructions for assignment 1 about how to decide how many buckets to allocate for table_string?%20 | 1
2025-09-13 19:54:07.436 | Query: Is it normal for the diff command in the terminal to print < before each line of the first file and > before each line of the second file? | 1
2025-09-14 14:54:32.305 | Query: What are s and n in gdb? | 1
2025-09-14 15:04:12.323 | Query: What is the Binary of Decimal 0d11 | 1
2025-09-14 15:04:34.996 | Query: What is the Binary of Decimal 0d36 | 1
2025-09-14 15:05:15.658 | Query: What is the Decimal of Binary 0b11011111 | 1
2025-09-14 15:05:51.987 | Query: What is the Hex of Decimal 0d111 | 1
2025-09-14 15:06:24.711 | Query: Consider a base number system 4%20%20The digits used to represent a number is | 1
2025-09-14 15:07:46.947 | Query: Consider a base number system 4%20%20The digits used to represent a number is 0, 1, 2 and 3.%20%20The maximum number i is of 2 digits is ______ (in decimal. You do not need to write 0d)%20%20Number 0d138 represented in base 4 is _______ (only write digits) | 1
2025-09-14 15:08:58.654 | Query: What is x (in hex) ?%20x = *((short*)array+29);%20%20Assume array = 0x1000%20Assume big endianess | 1
2025-09-14 15:10:38.769 | Query: If the size of the pointer is 16 bits, what is the maximum size of the memory ? | 1
2025-09-14 15:11:04.304 | Query: If the size of the memory is 4.0 megabytes what is the number of bits required ? | 1
2025-09-14 15:44:52.796 | Query: Debug why this code is not printing out:%20int i = 0;%20  vector_char_t *word = vector_char_allocate();%20  while (source[i] != '\0') {%20    if ((source[i] >= 65 && source[i] <= 90) || (source[i] >= 97 && source[i] <= 122)) {%20      vector_char_add(word, source[i]);%20%20    } else {%20      vector_char_add(word, '\0');%20%20      char* word_ptr = vector_char_get_array(word);%20      printf("%s \n", word_ptr);%20%20      vector_char_delete(word);%20%20      word = vector_char_allocate();%20%20    }%20  } | 1
2025-09-14 15:59:52.269 | Query: What reasons could there be for an extra empty line printing.%20  int i = 0;%20  vector_char_t *word = vector_char_allocate();%20  char* word_ptr;%20  while (source[i] != '\0') {%20%20    if (source[i + 1] == '\0') {%20      vector_char_add(word, '\0');%20      word_ptr = vector_char_get_array(word);%20      printf("%s", word_ptr);%20%20    }%20%20    if ((source[i] >= 65 && source[i] <= 90) || (source[i] >= 97 && source[i] <= 122)) {%20      vector_char_add(word, source[i]);%20%20    } else {%20      vector_char_add(word, '\0');%20%20      word_ptr = vector_char_get_array(word);%20      printf("%s\n", word_ptr);%20%20      vector_char_delete(word);%20%20      word = vector_char_allocate();%20%20    }%20    i++;%20  }%20%20  if (word != NULL) {%20    vector_char_delete(word);%20%20  }%20 | 1
2025-09-14 17:49:33.928 | Query: #include "table_string.h"%20#include "str_cmp.h"%20#include <stdbool.h>%20#include <stdint.h>%20#include <stdio.h>%20#include <stdlib.h>%20#include <string.h>%20%20#define BUCKETS%20// DO NOT ADD ANY NEW FUNCTIONS BEFORE djb2%20// Hash a character array to integer value between 0 and buckets-1.%20// See here for more details: https://theartincode.stanis.me/008-djb2/%20unsigned int djb2_word_to_bucket(char *word, int buckets) {%20  if (!word) {%20    printf("Invoked with null string");%20    exit(EXIT_FAILURE);%20  }%20  unsigned long hash = 5381;%20  uint32_t i;%20%20  for (i = 0; i < strlen(word); i++)%20    hash = ((hash << 5) + hash) + word[i];%20%20  return hash & (buckets - 1);%20}%20// ADD YOUR HELPER FUNCTIONS AFTER djb2%20/**%20 * @brief Instantiate a table string%20 *%20 * @param buckets%20 * @return table_string*%20 */%20table_string *table_string_allocate(unsigned int buckets) {%20  // Instantiate a bucket number of heads%20  %20  table_string *ts = malloc(sizeof(table_string));%20  if (ts == NULL) {%20    free(ts);%20    return NULL;%20  }%20%20  ts->buckets = buckets;%20  ts->heads = malloc(buckets * sizeof(vs_entry_t *));%20  if (ts->heads == NULL) {%20    free(ts->heads);%20    free(ts);%20    return NULL;%20  }%20  // Set everything to NULL%20  for (int i = 0; i < buckets; i++) {%20    ts->heads[i] = NULL;%20  }%20%20  return ts;%20}%20%20/**%20 * @brief Insert the string pointed to by word into the table string.%20 *   If word is already found increment count.%20 *   If word is not found insert at the end of the corresponding bucket%20 * @param ts - Pointer to table_string datastructure%20 * @param word - Pointer to string to search for%20 * @return * Find*%20 */%20void table_string_insert_or_add(table_string *ts, char *word, int line) {%20  // Find the bucket for word. djb2 will return a value between 0-buckets-1.%20  // Rule: buckets can only be power of 2.%20  int bucket = djb2_word_to_bucket(word, ts->buckets);%20  // TODO:%20  // Case head == NULL: bucket hasn't been initialized yet%20  // Case word already in list, add to line array.%20  // Case word not found, insert word and return.%20%20  // Validation%20  if (ts == NULL) {%20    return;%20  }%20%20  vs_entry_t *tail = NULL;%20  vs_entry_t *cursor = ts->heads[bucket];%20%20  // Searches array %20  while (cursor != NULL) {%20    // Match found%20    if (my_str_cmp(cursor->value, word) == 0) {%20%20      // Add line to pos array%20      cursor->size_of_pos++;%20      cursor->pos = (int *)realloc(cursor->pos, cursor->size_of_pos * sizeof(int));%20      cursor->pos[cursor->size_of_pos - 1] = line;%20%20      // This is  stupid%20      free(cursor->value);%20      cursor->value = word;%20%20      return;%20    }%20    // No match found, continue searching%20    tail = cursor;%20    cursor = cursor->next;%20  }%20%20  // end of array reached; create new entry%20  vs_entry_t *newNode = malloc(sizeof(vs_entry_t));%20  newNode->value = word;%20  newNode->next = NULL;%20  newNode->size_of_pos = 1;%20  newNode->pos = malloc(1 * sizeof(int));%20  newNode->pos[0] = line;%20%20  if (ts->heads[bucket] == NULL) {  // Bucket has not been initialized%20    ts->heads[bucket] = newNode;%20  } else {                          // Bucket has been initialized%20    tail->next = newNode;%20  }%20%20  return;%20%20}%20%20void table_string_deallocate(table_string *ts) {%20  // TODO:%20  // Free the linked list of each bucket%20  // Free the array of head pointers%20  // Free the structure itself%20%20  if (ts == NULL) {%20    return;%20  }%20%20  vs_entry_t *cursor = NULL;%20  vs_entry_t *temp = NULL;%20%20  for (int i = 0; i < ts->buckets; i++) {%20%20    // Anchor%20    cursor = ts->heads[i];%20%20    while (cursor != NULL) {%20      %20      temp = cursor;%20      cursor = cursor->next;%20      %20      free(temp->pos);%20      temp->pos = NULL;%20      free(temp->value);%20      temp->value = NULL;%20      free(temp);%20    }%20%20  }%20%20  free(ts->heads);%20  free(ts);%20%20  return;%20}%20%20void table_string_print(table_string *ts) {%20  /** TODO:%20   for each bucket%20    for each entry in bucket%20      print entry->word: line line line%20  */%20%20  vs_entry_t *cursor = NULL;%20  %20  // For each bucket%20  for (int i = 0; i < ts->buckets; i++) {%20%20    cursor = ts->heads[i];%20    %20    // debug stuff to show which words are in which bucket%20    printf("===[bucket %d]===\n", i);%20    // Problem: Everything else is working correctly except the for words being mapped to the incorrect bucket.%20%20    // for each entry in bucket%20    while (cursor != NULL) {%20      printf("%s: ", cursor->value);%20      %20      for (int j = 0; j < cursor->size_of_pos; j++) {%20        printf("%d ", cursor->pos[j]);%20      }%20%20      printf("\n");%20%20      cursor = cursor->next;%20    }%20  }%20}%20%20Everything else in this code works as intended, but why are my words not mapping to the correct bucket? | 1
2025-09-14 18:45:29.360 | Query: Explain what I'm supposed to do to write the code of unit_test_strcmp.c%20 | 1
2025-09-14 18:46:36.144 | Query: Debug reason causing segfault:%20void vector_string_deallocate(vector_string *vs) {%20  if (vs == NULL) {%20    return;%20  }%20  %20  vs_entry_t* p = vs->head;%20  vs_entry_t* next;%20%20  while (next != NULL) {%20    next = p->next;%20    free(p);%20    p = next;%20  }%20  p = NULL;%20%20  free(vs);%20  vs = NULL;%20} | 1
2025-09-14 18:47:05.856 |  Query: Debug reason causing segfault:%20void vector_string_deallocate(vector_string *vs) {%20  if (vs == NULL) {%20    return;%20  }%20  %20  vs_entry_t* p = vs->head;%20  vs_entry_t* next;%20%20  while (next != NULL) {%20    next = p->next;%20    free(p);%20    p = next;%20  }%20  p = NULL;%20%20  free(vs);%20  vs = NULL;%20} | Rating: 5  | 1
2025-09-14 20:19:15.577 | Query:  If the size of the pointer is 16 bits, what is the maximum size of the%20 memory ? | 1
2025-09-14 20:22:06.075 | Query: What is the Hex of Decimal 0d111  | 1
2025-09-14 20:25:13.813 | Query: What is the Decimal of Binary 0b11011111 | 1
2025-09-14 21:02:51.093 | Query: Can you explain what we are supposed to do in Assignment 1 part 4?%20 | 1
2025-09-14 21:03:34.074 | Query: Can you explain what we are supposed to do in Assignment 1 part 4?%20Here are the instructions:%20Step 4 Word Pair Search%20%20We are going to build a useful application leveraging existing data structures. Hash-based table strings enable efficient word lookup by partitioning words across buckets. We will implement a consecutive word pair detector. Given two files, find all consecutive word pairs from file 2 that also appear consecutively in file 1, then output each matching pair with its starting position from file 1. The algorithm steps are as follows:%20%20If you open txt/input.txt and txt/small.txt in a text editor and search for word pairs from small [Lorem i],... , you will find that [sit amet] at position 3, then at 32, and then again at 56 and 69. WARNING: print format has to exactly match for tests to pass. See reference%20%20We will now proceed to find the occurences of all word pairs from one file in another.%20%20# Make sure you initialize the table_strings with 8 buckets in duplicate.c%20# The reference output was generated assuming 8 buckets%20# in the table string.%20# If you do not set buckets to 8, then each word will be fine. But the order of the words could be different leading to mismatches against the reference%20%20$ cat reference/input.small.mapcount                                                        %20Lorem i 0%20i dolor 1%20dolor sit 2%20sit amet 3%20sit amet 32%20sit amet 56%20sit amet 69%20%20Example: Word Pair Extraction%20%20Input file (small.txt):%20%20Lorem Lorem i dolor sit amet,%20%20Consecutive word pairs extracted:%20%20    Lorem Lorem (positions 0,1)%20    Lorem i (positions 1,2)%20    i dolor (positions 2,3)%20    dolor sit (positions 3,4)%20    sit amet (positions 4,5)%20%20Search process: For each pair, check if both words appear consecutively in the target file (input.txt). For example, if “Lorem” appears at position 0 and “i” appears at position 1 in input.txt, then the pair “Lorem i” is found and we output: Lorem i 0%20SOURCE FILES%20%20    Create a table string to track the occurrence of words in each file. You will create one table string for file 1 (let’s call it table1).%20    Tokenize the words from file2.%20    Iterate over the words keeping track of pairs of words i.e., the cur word and next.%20    Get all positions of current word - cur_word_pos%20    Get all positons of next word - next_word_pos%20    If there exists i ∈%20%20cur_word_pos and j ∈%20%20    next_word_pos. such that j == i + 1 then we found the word pair.%20    Display it%20%20    table_file1 = table_string_create(file1) %20    words_file2 = tokenize(file2)%20    for i in range(len(words_file2) - 1):%20      cur_word = words_file2[i]%20      next_word = words_file2[i + 1]%20      cur_word_pos = table_string_get_positions(table_file1, cur_word)%20      next_word_pos = table_string_get_positions(table_file1, next_word)%20      for i in cur_word_pos:%20          for j in next_word_pos:%20              if j == i + 1:%20                  print(f"{cur_word} {next_word} {i}"%20%20Filename 	Description%20mapcount.c 	TODO: Implement the mapcount function for searching word pairs from one file in another%20%20There is only one function that you are expected to implement for common word counts:%20Test and Validation%20%20# Make sure you initialize the table_string with 8 buckets in poscount.c%20# The reference output was generated assuming 8 buckets%20# in the table string.%20cd $REPO/word-count%20# Even though binary name says mapcount. Note that you %20# are expected to implement common word count finding algorithm.%20make mapcount.bin %20# To test make sure you are in the parent folder%20cd $REPO %20./word-count/mapcount.bin  ./word-count/txt/input.txt ./word-count/txt/small.txt > ./word-count/out/input.small.ccount%20diff  ./word-count/out/input.small.ccount ./word-count/reference/input.small.ccount%20# To match reference output, you have to run from the $REPO folder.%20 | 1
2025-09-14 21:10:33.621 | Query: git revert는 어떻게 해? | 1
2025-09-14 21:10:47.465 | Query: git revert는 어떻게 해?? | 1
2025-09-14 21:53:52.463 | Query: //Functions that you need to implement:%20%20/*%20 * Append the value x to the end of the arraylist. If necessary, double the%20 * capacity of the arraylist.%20 */%20void arraylist_add(arraylist *a, void *x)%20{%20    // TODO%20} | 1
2025-09-14 22:33:00.237 | Query: while(s1[current_index] != 0 && s2[current_index] != 0)%20Suppose s1 and s2 are strings. Does this while statement sufficiently determine whether or not either string has reached its null terminator?%20 | 1
2025-09-14 22:39:28.620 | Query: int current_index = 0;%20  while(s1[current_index] != 0 && s2[current_index] != 0)%20  {%20    if (s1[current_index] == s2[current_index])%20    {%20      current_index++;%20      continue;%20    }%20    else%20    {%20      return 1;%20    }%20  }%20  if (s1[current_index] == 0 ^ s2[current_index] = 0)%20  {%20    return 1;%20  }%20%20Explain the problem with this code%20 | 1
2025-09-14 22:41:14.945 | Query: If i want to check if one string has reached its null terminator with regard to current_index but the other hasnt, how should i go about this?%20 | 1
2025-09-14 22:51:24.831 | Query: int my_str_cmp(const char *s1, const char *s2) {%20  // TODO: Compare two character arrays. return 0 if they match, 1 otherwise%20  // You can assume that s1 and s2 are null terminated strings.%20  // WARNING: strings could potentially be of different lengths%20  // e.g., "apple" does not match "apple " (which includes the extra space).%20  // Value to be returned will be 1.%20  // You cannot use any of the string helper functions including strlen and%20  // strncmp, strcmp.%20%20  int current_index = 0;%20  while(s1[current_index] != 0 && s2[current_index] != 0)%20  {%20    if (s1[current_index] == s2[current_index])%20    {%20      current_index++;%20      continue;%20    }%20      return 1;%20  }%20  if (s1[current_index] == 0 ^ s2[current_index] == 0)%20  {%20    return 1;%20  }%20  return 0;%20}%20%20With the provided description of what the code should do, explain the code below | 1
2025-09-14 22:52:03.730 | Query: int my_str_cmp(const char *s1, const char *s2) {%20  // TODO: Compare two character arrays. return 0 if they match, 1 otherwise%20  // You can assume that s1 and s2 are null terminated strings.%20  // WARNING: strings could potentially be of different lengths%20  // e.g., "apple" does not match "apple " (which includes the extra space).%20  // Value to be returned will be 1.%20  // You cannot use any of the string helper functions including strlen and%20  // strncmp, strcmp.%20%20  int current_index = 0;%20  while(s1[current_index] != 0 && s2[current_index] != 0)%20  {%20    if (s1[current_index] == s2[current_index])%20    {%20      current_index++;%20      continue;%20    }%20      return 1;%20  }%20  if (s1[current_index] == 0 ^ s2[current_index] == 0)%20  {%20    return 1;%20  }%20  return 0;%20}%20%20With the provided description of what the code should do, explain the code below%20What may be wrong with this code? | 1
2025-09-14 22:59:27.780 | Query: #include <ctype.h>%20#include <fcntl.h>%20#include <stdio.h>%20#include <stdlib.h>%20#include <string.h>%20#include <vector_char.h>%20#include <vector_string.h>%20int main(int argc, char **argv) {%20  char *source = NULL;%20%20  if (argc != 2) {%20    printf("./grade_tokenize.bin [FILE PATH]");%20    exit(1);%20  }%20  /**%20   * @brief Read file into source.%20   * source is a character array with file contents%20   * It is null terminated%20   */%20  FILE *fp = fopen(argv[1], "r");%20  if (fp == NULL) { /* Error */%20    printf("Error reading file");%20    exit(1);%20  }%20  if (fp != NULL) {%20    /* Go to the end of the file. */%20    if (fseek(fp, 0L, SEEK_END) == 0) {%20      /* Get the size of the file. */%20      long bufsize = ftell(fp);%20      if (bufsize == -1) { /* Error */%20        printf("Error reading file");%20      }%20      /* Allocate our buffer to that size. */%20      source = malloc(sizeof(char) * (bufsize + 1));%20      /* Go back to the start of the file. */%20      if (fseek(fp, 0L, SEEK_SET) != 0) { /* Error */%20      }%20      /* Read the entire file into memory. */%20      size_t newLen = fread(source, sizeof(char), bufsize, fp);%20      if (ferror(fp) != 0) {%20        printf("Error reading file");%20      } else {%20        source[newLen++] = '\0'; /* Just to be safe. */%20      }%20    }%20  }%20  fclose(fp);%20%20  vector_string *vs = vector_string_allocate();%20  vector_char_t *vc = vector_char_allocate();%20  for (size_t i =0 ; source[i] != '\0'; i++) {%20    char c = source[i];%20    if (isalpha(c)) {%20      vector_char_add(vc, c);%20    } else {%20     if (vc->len > 0) {%20        vector_char_add(vc, '\0');%20        char *word = vector_char_get_array(vc);%20        if (!vector_string_find(vs, word)) {%20          vector_string_insert(vs, word);%20        }%20        vector_char_delete(vc);%20        vc = vector_char_allocate();%20      }%20    }%20  }%20  if (vc->len > 0) {%20    vector_char_add(vc, '\0');%20    char *word = vector_char_get_array(vc);%20    if (!vector_string_find(vs, word)) {%20      vector_string_insert(vs, word);%20    }%20    free(vc);%20  }%20  vector_string_print(vs);%20  vector_string_deallocate(vs);%20  free(source);%20  return 0;%20} | 1
2025-09-14 22:59:52.055 | Query: #include <ctype.h>%20#include <fcntl.h>%20#include <stdio.h>%20#include <stdlib.h>%20#include <string.h>%20#include <vector_char.h>%20#include <vector_string.h>%20int main(int argc, char **argv) {%20  char *source = NULL;%20%20  if (argc != 2) {%20    printf("./grade_tokenize.bin [FILE PATH]");%20    exit(1);%20  }%20  /**%20   * @brief Read file into source.%20   * source is a character array with file contents%20   * It is null terminated%20   */%20  FILE *fp = fopen(argv[1], "r");%20  if (fp == NULL) { /* Error */%20    printf("Error reading file");%20    exit(1);%20  }%20  if (fp != NULL) {%20    /* Go to the end of the file. */%20    if (fseek(fp, 0L, SEEK_END) == 0) {%20      /* Get the size of the file. */%20      long bufsize = ftell(fp);%20      if (bufsize == -1) { /* Error */%20        printf("Error reading file");%20      }%20      /* Allocate our buffer to that size. */%20      source = malloc(sizeof(char) * (bufsize + 1));%20      /* Go back to the start of the file. */%20      if (fseek(fp, 0L, SEEK_SET) != 0) { /* Error */%20      }%20      /* Read the entire file into memory. */%20      size_t newLen = fread(source, sizeof(char), bufsize, fp);%20      if (ferror(fp) != 0) {%20        printf("Error reading file");%20      } else {%20        source[newLen++] = '\0'; /* Just to be safe. */%20      }%20    }%20  }%20  fclose(fp);%20%20  vector_string *vs = vector_string_allocate();%20  vector_char_t *vc = vector_char_allocate();%20  for (size_t i =0 ; source[i] != '\0'; i++) {%20    char c = source[i];%20    if (isalpha(c)) {%20      vector_char_add(vc, c);%20    } else {%20     if (vc->len > 0) {%20        vector_char_add(vc, '\0');%20        char *word = vector_char_get_array(vc);%20        if (!vector_string_find(vs, word)) {%20          vector_string_insert(vs, word);%20        }%20        vector_char_delete(vc);%20        vc = vector_char_allocate();%20      }%20    }%20  }%20  if (vc->len > 0) {%20    vector_char_add(vc, '\0');%20    char *word = vector_char_get_array(vc);%20    if (!vector_string_find(vs, word)) {%20      vector_string_insert(vs, word);%20    }%20    free(vc);%20  }%20  vector_string_print(vs);%20  vector_string_deallocate(vs);%20  free(source);%20  return 0;%20}%20is there any problem | 1
2025-09-14 23:00:48.016 | Query: #include "vector_string.h"%20#include "str_cmp.h"%20#include <stdbool.h>%20#include <stdint.h>%20#include <stdio.h>%20#include <stdlib.h>%20#include <string.h>%20/**%20/////////////////////////////////////////%20%20*/%20/**%20 * @brief Memory allocate a vector string so that we can start inserting entries%20 * into it.%20 *%20 */%20vector_string *vector_string_allocate() {%20  vector_string *vs = malloc(sizeof(vector_string));%20  if (!vs)%20    return NULL;%20%20  vs->head = NULL;%20  vs->tail = NULL;%20%20  return vs;%20}%20%20/**%20 * @brief Search the vector string pointed to by vs and return true if the%20 * vs_entry.value == key, else return false.%20 * TODO:%20 * @param vs - Pointer to vector_string datastructure%20 * @param key - Pointer to string to search for%20 * @return * Find*%20 */%20bool vector_string_find(vector_string *vs, char *key) { %20  vs_entry_t *temp = vs->head;%20  while (temp != NULL) {%20    if (my_str_cmp(temp->value, key) == 0) {%20      return true;}%20    temp = temp->next;%20  }%20  return false;%20}%20%20/**%20 * @brief TODO: Insert the string pointed to by key into the vector string.%20 *  char* is externally allocated. You do not have to allocate internally%20 *%20 * @param vs - Pointer to vector_string datastructure%20 * @param key - Pointer to string to search for%20 * @return * Find*%20 */%20void vector_string_insert(vector_string *vs, char *key) {%20  if (vs == NULL || key == NULL)%20    return;%20  vs_entry_t *new_entry = malloc(sizeof(vs_entry_t));%20  new_entry->value = key;%20  new_entry->next = NULL;%20%20  if (vs->head == NULL) {%20    vs->head = new_entry;%20    vs->tail = new_entry;%20  } else {%20    vs->tail->next = new_entry;%20    vs->tail = new_entry;%20  }%20}%20/**%20 * @brief Remove all entries and cleanup vector string%20 * TODO: Remove all entries. Remember head and tail are pointers.%20 * Remember to remove vs as well; not just entries. or you will have memory%20 * leaks.%20 * @param vs: Pointer to vector_string struct%20 */%20void vector_string_deallocate(vector_string *vs) {%20  if (vs == NULL) {%20    return;%20  }%20  if (vs->head == NULL) {%20    free(vs);%20    return;%20  }%20  vs_entry_t *temp = vs->head;%20  while (temp != NULL) {%20    vs_entry_t *next = temp->next;%20    free(temp->value);%20    free(temp);%20    temp = next;%20  }%20  free(vs);%20}%20%20/**%20 * @brief Print all value in each entry of the vector string, in the following%20 * format. In this case hello and world are the unique words in the file.%20 * 1. hello%20 * 2. world%20 * @param vs%20 */%20void vector_string_print(vector_string *vs) {%20%20  vs_entry_t *entry = vs->head;%20  int count = 1;%20%20  while (entry != NULL) {%20    printf("%d. %s\n", count, entry->value);%20    entry = entry->next;%20    count++;%20  }%20}%20what is problem | 1
2025-09-15 10:48:12.373 | Query: you know how there is step by step solutions for midterm/quiz questions? is there video walkthroughs as well | 1
2025-09-15 19:13:56.140 | Query: Explain vector_chars functions and usage | 1
2025-09-15 19:20:36.515 | Query: explain how function calls work%20 | 1
2025-09-15 19:26:05.038 | Query: %20Filename	Description%20str_cmp.c	TODO: Implement string compare%20test_str_cmp.c	YOU CANNOT MODIFY THIS FILE. Tester for str_cmp (will not work with gdb)%20unit_test_str_cmp.c	TODO: Write your own unit test case for gdbing%20%20What am I expected to put in the unit_test_str_cmp.c file? | 1
2025-09-15 19:28:23.807 | Query: Explain how to check if a char is alphanumeric or not in C | 1
2025-09-15 19:28:41.116 | Query: Explain how to check if a char is alphanumeric or not in C. Provide alternatives | 1
2025-09-15 19:32:35.176 | Query: can you explain bit level operations in c and provide examples%20%20 | 1
2025-09-15 19:49:21.283 | Query: can you explain how to do addition and subtraction with binary and hex numbers. for binary can you show both msb sign bit notation and twos complement notations as well.%20%20 | 1
2025-09-15 20:14:31.497 | Topic: can you explain how to do addition and subtraction with binary and hex numbers. for binary can you show both msb sign bit notation and twos complement notations as well. | 1
2025-09-15 20:25:11.683 | Query: for the pre integer 2 slides, slide 37, why is 0xFF0000 represent all 1's on the second byte and not the first byte%20%20%20 | 1
2025-09-15 20:26:58.158 | Query: for the pre integer 2 slides, slide 37, why is 0xFF0000 represent all 1's on the second byte and not the first byte for an int value%20%20%20 | 1
2025-09-15 21:03:41.827 | Query: // TODO: Tokenize processing%20  // TODO:source contains the string to be processed.%20  /** Start processing file and separate into words */%20  /** Pseudocode */%20  // 1. Iterate over characters%20  // 2. if current-character starts word start accumulating into vector_char%20  // 3. if current character terminates word. print and restart word start%20  // check. Free all data.%20  // Hint: Use vector_char%20%20  int current_index = 0;%20  vector_char_t *header = vector_char_allocate();%20  while(source[current_index] != 0)%20  {%20    if (isalnum(source[current_index]))%20    {%20    vector_char_add(header, source[current_index]);%20    }%20    else%20    {%20      vector_char_add(header, 0);%20      printf("%s\n", vector_char_get_array(header));%20      vector_char_delete(header);%20      vector_char_t *header = vector_char_allocate();%20    }%20  }%20  vector_char_delete(header);%20%20  return 0;%20}%20%20Explain this issue of this snippet%20 | 1
2025-09-15 21:08:47.851 | Query: // TODO: Tokenize processing%20  // TODO:source contains the string to be processed.%20  /** Start processing file and separate into words */%20  /** Pseudocode */%20  // 1. Iterate over characters%20  // 2. if current-character starts word start accumulating into vector_char%20  // 3. if current character terminates word. print and restart word start%20  // check. Free all data.%20  // Hint: Use vector_char%20%20  int current_index = 0;%20  vector_char_t *header = vector_char_allocate();%20  while(source[current_index] != 0)%20  {%20    if (isalnum(source[current_index]))%20    {%20    vector_char_add(header, source[current_index]);%20    }%20    else%20    {%20      vector_char_add(header, 0);%20      printf("%s\n", vector_char_get_array(header));%20      vector_char_delete(header);%20      vector_char_t *header = vector_char_allocate();%20    }%20  }%20  vector_char_delete(header);%20%20  return 0;%20}%20%20Explain this issue of this snippet%20Explain how I should clear if there is no clear function in the vector_char?%20 | 1
2025-09-15 21:20:00.086 | Query: what is the difference between the types of addresses (heap, stack, static, code)%20 | 1
2025-09-15 21:21:19.648 | Query: what are string literals and why are they allocated in static addresses%20%20 | 1
2025-09-15 21:37:55.686 | Query: Show me how to write a unit test | 1
2025-09-15 21:42:27.646 | Query: %20Filename	Description%20str_cmp.c	TODO: Implement string compare%20test_str_cmp.c	YOU CANNOT MODIFY THIS FILE. Tester for str_cmp (will not work with gdb)%20unit_test_str_cmp.c	TODO: Write your own unit test case for gdbing%20%20What am I expected to put in the unit_test_str_cmp.c file?%20%20this is test_str_cmp.c :%20#include <acutest.h>%20#include <stdint.h>%20#include <str_cmp.h>%20%20struct TestVector {%20  const int index;%20  const char *s1;%20  const char *s2;%20  int expected;%20};%20%20struct TestVector test_vectors[] = {%20    // Inorder,Preorder,Postorder(Expected)%20    {0, "a", "b", 1},%20    {1, "apple", "appl@ ", 1},%20    {2, "apple and oranges", "apple and oranges", 0},%20    {3, "123456", "123456", 0},%20    {4, "342342;", "afasdfsafd;", 1}};%20%20void test(void) {%20  for (int i = 0; i < 5; i++) {%20    int result = my_str_cmp(test_vectors[i].s1, test_vectors[i].s2);%20%20    TEST_CHECK(result == test_vectors[i].expected);%20    TEST_MSG("String s1: %s", test_vectors[i].s1);%20    TEST_MSG("String s2: %s", test_vectors[i].s2);%20  }%20}%20%20TEST_LIST = {{"Test", test}, {NULL, NULL}};%20 | 1
2025-09-15 22:00:27.099 | Query: Is the c "assert" method covered within the first few weeks in this course? | 1
2025-09-15 22:11:00.969 | Query: can you go over the questions in the fall 2020 midterm practice quiz%20%20 | 1
2025-09-15 22:11:26.683 | Topic: can you go over the questions in the fall 2020 midterm practice quiz | 1
2025-09-15 22:11:27.497 | Topic: can you go over the questions in the fall 2020 midterm practice quiz | 1
2025-09-15 22:11:28.141 | Topic: can you go over the questions in the fall 2020 midterm practice quiz | 1
2025-09-15 22:11:28.776 | Topic: can you go over the questions in the fall 2020 midterm practice quiz | 1
2025-09-15 22:11:29.231 | Topic: can you go over the questions in the fall 2020 midterm practice quiz | 1
2025-09-15 22:11:29.729 | Topic: can you go over the questions in the fall 2020 midterm practice quiz | 1
2025-09-15 22:11:30.341 | Topic: can you go over the questions in the fall 2020 midterm practice quiz | 1
2025-09-16 12:44:13.346 | Query: for this function, /*%20 * Return the size of an integer in bytes.%20 *%20 * ALLOWED:%20 *   Pointer operators: *, &%20 *   Binary integer operators: -, +, *%20 *   Unary integer operators: !%20 *   Shorthand operators based on the above: ex. +=, *=, ++, --, eFDIStc.%20 *%20 * DISALLOWED:%20 *   Pointer operators: [] (Array Indexing Operator)%20 *   Binary integer operators: &, &&, |, ||, <, >, <<, >>, ==, !=, ^, /, %%20 *   Unary integer operators: ~, -%20 */%20int intSize() {%20  int intArray[10];%20  int *intPtr1;%20  int *intPtr2;%20  // Write code to compute size of an integer.%20%20  *intPtr1 = 1;%20  *intPtr2 = 2;%20%20  return %20%20  return 2;%20}%20%20do i have to allocate memory with malloc or can i just start intPtr = 1 and just that.%20 | 1
2025-09-16 12:46:56.200 | Query: why does the code (char*)intPtr2 - (char*)intPtr1, compute the difference in bytes?%20 | 1
2025-09-16 13:07:10.601 | Query: how would you implement this. /*%20 * Return the size of a pointer in bytes.%20 *%20 * ALLOWED:%20 *   Pointer operators: *, &%20 *   Binary integer operators: -, +, *%20 *   Unary integer operators: !%20 *   Shorthand operators based on the above: ex. +=, *=, ++, --, etc.%20 *%20 * DISALLOWED:%20 *   Pointer operators: [] (Array Indexing Operator)%20 *   Binary integer operators: &, &&, |, ||, <, >, <<, >>, ==, !=, ^, /, %%20 *   Unary integer operators: ~, -%20 */%20int pointerSize() {%20  double *ptrArray[10];%20  double **ptrPtr1;%20  double **ptrPtr2;%20  // Write code to compute size of a pointer.%20%20  ptrPtr1 = ptrArray;%20  ptrPtr2 = ptrArray + 1;%20%20  return ptrPtr2 - ptrPtr1;%20} | 1
2025-09-16 13:10:13.896 | Query: how would you implement this. /*%20 * Return the size of a pointer in bytes.%20 *%20 * ALLOWED:%20 *   Pointer operators: *, &%20 *   Binary integer operators: -, +, *%20 *   Unary integer operators: !%20 *   Shorthand operators based on the above: ex. +=, *=, ++, --, etc.%20 *%20 * DISALLOWED:%20 *   Pointer operators: [] (Array Indexing Operator)%20 *   Binary integer operators: &, &&, |, ||, <, >, <<, >>, ==, !=, ^, /, %%20 *   Unary integer operators: ~, -%20 */%20int pointerSize() {%20  double *ptrArray[10];%20  double **ptrPtr1;%20  double **ptrPtr2;%20  // Write code to compute size of a pointer.%20%20  ptrPtr1 = ptrArray;%20  ptrPtr2 = ptrArray + 1;%20%20  return ptrPtr2 - ptrPtr1;%20}%20%20do i have to initialize the values for ptrPtr1 after giving them their adrress so i can get the size | 1
2025-09-16 18:02:11.463 | Query: Explain how to initialize and allocate memory for a linked list in C. | 1
2025-09-16 18:04:16.700 | Query: Explain how to initialize and allocate memory for a linked list in C, the header included | 1
2025-09-16 18:20:59.916 | Query: int current_index = 0;%20  vector_char_t *header = vector_char_allocate();%20  while(source[current_index] != 0)%20  {%20    if ((source[current_index] >= 65 && source[current_index] <= 90) ||%20        (source[current_index] >= 97 && source[current_index] <= 122) ||%20        (source[current_index] >= 48 && source[current_index] <= 57))%20...%20explain how i can optimize this without using alnum() | 1
2025-09-16 19:56:39.558 | Query: Debug segfault:%20vector_string *vector_string_allocate() {%20  vector_string* vs = (vector_string*) malloc(sizeof(vector_string));%20  %20  if (vs == NULL) {%20    return NULL;%20  }%20%20  vs->head = (vs_entry_t*) malloc(sizeof(vs_entry_t));%20  vs->tail = vs->head;%20  vs->head->value = NULL;%20  vs->head->next = NULL;%20%20  return vs;%20}%20void vector_string_insert(vector_string *vs, char *key) {%20  if (vector_string_find(vs, key)) {%20    return;%20  }%20  %20  vs_entry_t* add = (vs_entry_t*) malloc(sizeof(vs_entry_t));%20  add->next = NULL;%20  add->value = key;%20%20  if (vs->head == NULL && vs->tail == NULL) {%20    vs->head = add;%20    vs->tail = add;%20%20  } else {%20    vs->tail->next = add;%20    vs->tail = add;%20%20  }%20  %20} | 1
2025-09-16 20:19:17.988 | Query: Debug segfault:%20vector_string *vector_string_allocate() {%20  vector_string* vs = (vector_string*) malloc(sizeof(vector_string));%20  %20  if (vs == NULL) {%20    return NULL;%20  }%20%20  vs->head = NULL;%20  vs->head->value = NULL;%20  vs->head->next = NULL;%20  vs->tail = vs->head;%20%20  return vs;%20}%20%20void vector_string_insert(vector_string *vs, char *key) {%20  // Insert the string into the tail of the list.%20  if (vs == NULL) {%20    return;%20  }%20%20  if (vector_string_find(vs, key)) {%20    return;%20  }%20  %20  vs_entry_t* add = (vs_entry_t*) malloc(sizeof(vs_entry_t));%20  if (add == NULL) {%20    return;%20  }%20  add->next = NULL;%20  add->value = key;%20%20  if (vs->head == NULL && vs->tail == NULL) {%20    vs->head = add;%20    vs->tail = add;%20%20  } else {%20    vs->tail->next = add;%20    vs->tail = add;%20%20  }%20  %20} | 1
2025-09-16 20:20:14.915 | Query: Debug segfault:%20vector_string *vector_string_allocate() {%20  vector_string* vs = (vector_string*) malloc(sizeof(vector_string));%20  %20  if (vs == NULL) {%20    return NULL;%20  }%20%20  vs->head = NULL;%20  vs->tail = vs->head;%20%20  return vs;%20}%20%20void vector_string_insert(vector_string *vs, char *key) {%20  // Insert the string into the tail of the list.%20  if (vs == NULL) {%20    return;%20  }%20%20  if (vector_string_find(vs, key)) {%20    return;%20  }%20  %20  vs_entry_t* add = (vs_entry_t*) malloc(sizeof(vs_entry_t));%20  if (add == NULL) {%20    return;%20  }%20  add->next = NULL;%20  add->value = key;%20%20  if (vs->head == NULL && vs->tail == NULL) {%20    vs->head = add;%20    vs->tail = add;%20%20  } else {%20    vs->tail->next = add;%20    vs->tail = add;%20%20  }%20  %20} | 1
2025-09-16 20:22:37.989 | Query: how can i finish this function with what i have written in their now. /*%20 * Return 1 if the addresses stored in ptr1 and ptr2 are within the%20 * *same* 64-byte aligned  block of memory. Check the spec for examples if you%20 * are confused about what this means. Return zero otherwise. Operators / and %%20 * and loops are NOT allowed.%20 *%20 * ALLOWED:%20 *   Pointer operators: *, &%20 *   Binary integer operators: -, +, *, <<, >>, ==, ^%20 *   Unary integer operators: !, ~%20 *   Shorthand operators based on the above: ex. <<=, *=, ++, --, etc.%20 *%20 * DISALLOWED:%20 *   Pointer operators: [] (Array Indexing Operator)%20 *   Binary integer operators: &, &&, |, ||, <, >, !=, /, %%20 *   Unary integer operators: -%20 */%20int withinSameBlock(int *ptr1, int *ptr2) {%20  // Your code here%20%20%20  return ((long int)ptr2 - (long int)ptr1) ;%20}%20%20 | 1
2025-09-16 20:33:48.325 | Query: Debug segfault:%20vector_string *vector_string_allocate() {%20  vector_string* vs = (vector_string*) malloc(sizeof(vector_string));%20  %20  if (vs == NULL) {%20    return NULL;%20  }%20%20  vs->head = NULL;%20  vs->tail = vs->head;%20%20  return vs;%20}%20%20void vector_string_insert(vector_string *vs, char *key) {%20  // Insert the string into the tail of the list.%20  if (vs == NULL) {%20    return;%20  }%20%20  if (vector_string_find(vs, key)) {%20    return;%20  }%20  %20  vs_entry_t* add = (vs_entry_t*) malloc(sizeof(vs_entry_t));%20  if (add == NULL) {%20    return;%20  }%20  add->next = NULL;%20  add->value = key;%20%20  if (vs->head == NULL && vs->tail == NULL) {%20    vs->head = add;%20    vs->tail = add;%20%20  } else {%20    vs->tail->next = add;%20    vs->tail = add;%20%20  }%20  %20}%20%20void vector_string_print(vector_string *vs) {%20  int count = 1;%20%20  vs_entry_t *entry = vs->head;%20  while (entry->next != NULL) {%20    printf("%d. %s\n", count, entry->value);%20    entry = entry->next;%20    count++;%20  }%20} | 1
2025-09-16 20:34:39.368 | Query: Debug segfault:%20vector_string *vector_string_allocate() {%20  vector_string* vs = (vector_string*) malloc(sizeof(vector_string));%20  %20  if (vs == NULL) {%20    return NULL;%20  }%20%20  vs->head = NULL;%20  vs->tail = vs->head;%20%20  return vs;%20}%20%20void vector_string_print(vector_string *vs) {%20  int count = 1;%20%20  vs_entry_t *entry = vs->head;%20  while (entry->next != NULL) {%20    printf("%d. %s\n", count, entry->value);%20    entry = entry->next;%20    count++;%20  }%20} | 1
2025-09-16 20:42:34.389 | Query: Debug insert not adding:%20called by:%20      char* word_ptr = vector_char_get_array(word);%20      vector_string_insert(vs, word_ptr);%20%20vector_string *vector_string_allocate() {%20  vector_string* vs = (vector_string*) malloc(sizeof(vector_string));%20  %20  if (vs == NULL) {%20    return NULL;%20  }%20%20  vs->head = NULL;%20  vs->tail = vs->head;%20%20  return vs;%20}%20%20void vector_string_insert(vector_string *vs, char *key) {%20  // Insert the string into the tail of the list.%20  if (vs == NULL) {%20    return;%20  }%20%20  if (vs->head != NULL && vector_string_find(vs, key)) {%20    return;%20  }%20  %20  vs_entry_t* add = (vs_entry_t*) malloc(sizeof(vs_entry_t));%20  if (add == NULL) {%20    return;%20  }%20  add->next = NULL;%20  add->value = key;%20%20  if (vs->head == NULL && vs->tail == NULL) {%20    vs->head = add;%20    vs->tail = add;%20%20  } else {%20    vs->tail->next = add;%20    vs->tail = add;%20%20  } | 1
2025-09-16 20:54:24.190 | Query: Debug insert not adding:%20called by:%20      char* word_ptr = vector_char_get_array(word);%20      vector_string_insert(vs, word_ptr);%20%20void vector_string_insert(vector_string *vs, char *key) {%20  // Insert the string into the tail of the list.%20  if (vs == NULL) {%20    return;%20  }%20%20  if (vs->head != NULL && vector_string_find(vs, key)) {%20    return;%20  }%20  %20  vs_entry_t* add = (vs_entry_t*) malloc(sizeof(vs_entry_t));%20  if (add == NULL) {%20    return;%20  }%20  add->next = NULL;%20  int size = 0;%20  while (key[size] != '\0') {%20    size++;%20  }%20  add->value = (char*) malloc(sizeof(char) * size);%20  add->value = key;%20%20  if (vs->head == NULL && vs->tail == NULL) {%20    vs->head = add;%20    vs->tail = add;%20%20  } else {%20    vs->tail->next = add;%20    vs->tail = add;%20%20  }%20  %20} | 1
2025-09-16 20:54:50.211 | Query: /**%20 * @brief Remove all entries and cleanup vector string%20 * TODO: Remove all entries. Remember head and tail are pointers.%20 * Remember to remove vs as well; not just entries. or you will have memory%20 * leaks.%20 * @param vs: Pointer to vector_string struct%20 */%20void vector_string_deallocate(vector_string *vs) %20{%20  if (!vs) {return;}%20}%20%20Explain how to go about this | 1
2025-09-16 20:55:22.992 | Query: /**%20 * @brief Remove all entries and cleanup vector string%20 * TODO: Remove all entries. Remember head and tail are pointers.%20 * Remember to remove vs as well; not just entries. or you will have memory%20 * leaks.%20 * @param vs: Pointer to vector_string struct%20 */%20void vector_string_deallocate(vector_string *vs) %20{%20  if (!vs) {return;}%20}%20%20Explain how to go about this. Its a linked list | 1
2025-09-16 21:07:35.039 | Query: Debug insert not adding:%20called by:%20      vector_char_add(word, '\0');%20%20      char* word_ptr = (char*) malloc(sizeof(char) * word->len);%20      word_ptr = vector_char_get_array(word);%20      printf("%s\n", word_ptr);%20%20      vector_string_insert(vs, word_ptr);%20%20      vector_char_delete(word);%20      word = vector_char_allocate();%20%20void vector_string_insert(vector_string *vs, char *key) {%20  // Insert the string into the tail of the list.%20  if (vs == NULL) {%20    return;%20  }%20%20  if (vs->head != NULL && vector_string_find(vs, key)) {%20    return;%20  }%20  %20  vs_entry_t* add = (vs_entry_t*) malloc(sizeof(vs_entry_t));%20  if (add == NULL) {%20    return;%20  }%20  add->next = NULL;%20  int size = 0;%20  while (key[size] != '\0') {%20    size++;%20  }%20  add->value = (char*) malloc(sizeof(char) * size);%20  add->value = key;%20%20  if (vs->head == NULL && vs->tail == NULL) {%20    vs->head = add;%20    vs->tail = add;%20%20  } else {%20    vs->tail->next = add;%20    vs->tail = add;%20%20  }%20  %20} | 1
2025-09-16 21:08:06.424 | Query: Debug insert not adding:%20called by:%20      vector_char_add(word, '\0');%20%20      char* word_ptr = (char*) malloc(sizeof(char) * word->len);%20      word_ptr = vector_char_get_array(word);%20      printf("%s\n", word_ptr);%20%20      vector_string_insert(vs, word_ptr);%20%20      vector_char_delete(word);%20      word = vector_char_allocate();%20%20void vector_string_insert(vector_string *vs, char *key) {%20  // Insert the string into the tail of the list.%20  if (vs == NULL) {%20    return;%20  }%20%20  if (vs->head != NULL && vector_string_find(vs, key)) {%20    return;%20  }%20  %20  vs_entry_t* add = (vs_entry_t*) malloc(sizeof(vs_entry_t));%20  if (add == NULL) {%20    return;%20  }%20  add->next = NULL;%20  add->value = key;%20%20  if (vs->head == NULL && vs->tail == NULL) {%20    vs->head = add;%20    vs->tail = add;%20%20  } else {%20    vs->tail->next = add;%20    vs->tail = add;%20%20  }%20  %20} | 1
2025-09-16 21:27:09.661 | Query: Debug insert, not adding. Key is allocated externally:%20called by:%20      vector_char_add(word, '\0');%20%20      char* word_ptr = (char*) malloc(sizeof(char) * word->len);%20      word_ptr = vector_char_get_array(word);%20      printf("%s\n", word_ptr);%20%20      vector_string_insert(vs, word_ptr);%20%20      vector_char_delete(word);%20      word = vector_char_allocate();%20%20void vector_string_insert(vector_string *vs, char *key) {%20  // Insert the string into the tail of the list.%20  if (vs == NULL) {%20    return;%20  }%20%20  if (vs->head != NULL && vector_string_find(vs, key)) {%20    return;%20  }%20  %20  vs_entry_t* add = (vs_entry_t*) malloc(sizeof(vs_entry_t));%20  if (add == NULL) {%20    return;%20  }%20  add->next = NULL;%20  add->value = key;%20%20  if (vs->head == NULL && vs->tail == NULL) {%20    vs->head = add;%20    vs->tail = add;%20%20  } else {%20    vs->tail->next = add;%20    vs->tail = add;%20%20  }%20  %20} | 1
2025-09-16 22:11:26.043 | Query: Why does word_ptr[j] cause a segfault even though memory has been allocated?%20Debug:%20int count = 0;%20  vector_string* vs = vector_string_allocate();%20  vector_char_t* word = vector_char_allocate();%20%20%20  int i = 0;%20  while (source[i] != '\0') {%20%20    if ((source[i] >= 65 && source[i] <= 90) || (source[i] >= 97 && source[i] <= 122)) {%20      vector_char_add(word, source[i]);%20%20    } else {%20      vector_char_add(word, '\0');%20%20      char* word_ptr = (char*) malloc(sizeof(char) * word->len);%20      char* temp = vector_char_get_array(word);%20      for (int j = 0; j < word->len; j++) {%20        word_ptr[j] = temp[j];%20      }%20%20      printf("KEY: %s\n", word_ptr);%20%20      vector_string_insert(vs, word_ptr);%20%20      vector_char_delete(word);%20      word = vector_char_allocate();%20%20    }%20    i++;%20  }%20%20  vector_string_print(vs);%20%20  vector_string_deallocate(vs);%20  vector_char_delete(word);%20 | 1
2025-09-17 13:04:10.369 | Query: Check Yourself%20Have you read tutorials page and set up either VM or have CSIL Access?%20Have you read the linux section on the tutorials page?%20Have you read the C section on the tutorials page?%20Have you read the modules%20Do you know how to run cgdb on CSIL machines or VM? If not read here%20Don't proceed without knowing how to run this program in a terminal%20#include <stdio.h>%20void main() {%20  printf("Hello World");%20}%20Labs are essential to your learning and you should not skip them.%20Computer programming is inherently an applied exercise, and you will not learn much if you do not practice.%20Debugging code is an essential part of programming.%20Details%20Please use Rooms 9838 and 9700 if you want ready access to TAs. You can also use room 9804, but then TAs may not be able to provide timely advice.%20Labs are designed to take approximately 1 hour.%20Watch lab videos before the lab. TAs will dedicate the majority of the time for lab tasks only.%20TAs will not be going over the pre-req that prior courses have outlined see here%20Go over lab tasks before the lab. TAs will walk through the slides (if any) and handouts.%20TAs will only guide, they will not provide the complete solution.%20The staff recommends always asking for help on labs when you need it.%20We do recognize the value of AI bots to enhance learning in labs. You can use any AI Bot; however you see fit. May we recommend 295’s Bot ChatGPT here.%20%20%20help me follow these%20 | 1
2025-09-17 14:15:58.258 | Query: Explain how function calls work in RISC-V | 1
2025-09-17 16:21:36.142 | Query: Explain how heads would be iterated%20typedef struct table_string {%20  vs_entry_t **heads; // Array to maintain the heads of each bucket.%20  int buckets;        // Buckets can only be a power of 2.%20} table_string;%20%20%20typedef struct vs_entry {%20  char *value;%20  struct vs_entry *next;%20%20#ifdef POS_COUNT%20  int* pos; // This keeps track of each pos the word is found in%20  int  size_of_pos; // This keeps size of pos. Remember in C we track array size explicitly.%20#endif%20} vs_entry_t;%20 | 1
2025-09-17 16:34:48.572 | Query: If the size of the pointer is 24 bits, what is the maximum size of the%20memory | 1
2025-09-17 16:35:55.987 | Query: If the size of the memory is 1024.0 kilobytes what is the number of%20bits required ? | 1
2025-09-17 16:53:51.826 | Query: is x=memmove(x,...) equivalent to memmove(x, ...) is there any benefit to one%20 | 1
2025-09-17 17:15:07.723 | Query: %20debug double free:%20table_string *table_string_allocate(unsigned int buckets) {%20  // Instantiate a bucket number of heads%20  table_string* ts = (table_string*) malloc(sizeof(table_string));%20%20  for (int i = 0; i < buckets; i++) {%20    vs_entry_t *b = (vs_entry_t*) malloc(sizeof(vs_entry_t));%20    b = NULL;%20    ts->heads[i] = b;%20  }%20  ts->buckets = buckets;%20%20  return ts;%20}%20void table_string_insert_or_add(table_string *ts, char *word, int line) {%20  // Find the bucket for word. djb2 will return a value between 0-buckets-1.%20  // Rule: buckets can only be power of 2.%20  int bucket = djb2_word_to_bucket(word, ts->buckets);%20  // TODO:%20  // Case head == NULL: bucket hasn't been initialized yet%20  // Case word already in list, add to line array.%20  // Case word not found, insert word and return.%20  vs_entry_t* b = ts->heads[bucket];%20%20  if (b == NULL) {%20    b = (vs_entry_t*) malloc(sizeof(vs_entry_t));%20    b->pos = (int*) malloc(sizeof(int));%20    b->size_of_pos = 1;%20    %20    b->pos[0] = line;%20    b->value = word;%20    b->next = NULL;%20    return;%20  }%20%20  vs_entry_t* p = b;%20%20  while (p->next != NULL) {%20    if (!my_str_cmp(word, p->value)) {%20      p->pos = (int*) realloc(p->pos, sizeof(int) * p->size_of_pos + 1);%20      p->pos[p->size_of_pos] = line;%20      p->size_of_pos++;%20      return;%20%20    } else {%20      p = p->next;%20%20    }%20  }%20  %20  vs_entry_t* add = (vs_entry_t*) malloc(sizeof(vs_entry_t));%20  add->pos[0] = line;%20  add->size_of_pos = 1;%20  add->value = word;%20  add->next = NULL;%20  p->next = add;%20%20%20  return;%20}%20void table_string_deallocate(table_string *ts) {%20  // TODO:%20  // Free the linked list of each bucket%20  // Free the array of head pointers%20  // Free the structure itself%20  for (int i = 0; i < ts->buckets; i++) {%20%20    vs_entry_t* p = ts->heads[i];%20    vs_entry_t* next = p;;%20%20    while (next != NULL) {%20      next = p->next;%20      free(p);%20      p = next;%20    }%20    p = NULL;%20%20  }%20%20  // free(ts->heads);%20  free(ts);%20%20  return;%20} | 1
2025-09-17 17:35:43.356 | Query: how to properly initialize%20typedef struct table_string {%20  vs_entry_t **heads; // Array to maintain the heads of each bucket.%20  int buckets;        // Buckets can only be a power of 2.%20} table_string;%20%20typedef struct vs_entry {%20  char *value;%20  struct vs_entry *next;%20%20// Conditionally compiled in code. Not relevant for part 2. You can assume the%20// int count declaration does not exist and is irrelevant for part 2.%20#ifdef POS_COUNT%20  int* pos; // This keeps track of each pos the word is found in%20  int  size_of_pos; // This keeps size of pos. Remember in C we track array size explicitly.%20#endif%20} vs_entry_t;%20%20table_string *table_string_allocate(unsigned int buckets) {%20  // Instantiate a bucket number of heads%20  table_string* ts = (table_string*) malloc(sizeof(table_string));%20%20  for (int i = 0; i < buckets; i++) {%20%20    ts->heads[i] = NULL;%20  }%20  ts->buckets = buckets;%20%20  return ts;%20} | 1
2025-09-17 17:56:00.554 | Query: Debug memory leaks: %20void table_string_insert_or_add(table_string *ts, char *word, int line) {%20  int bucket = djb2_word_to_bucket(word, ts->buckets);%20  vs_entry_t* b = ts->heads[bucket];%20%20  if (b == NULL) {%20    b = (vs_entry_t*) malloc(sizeof(vs_entry_t));%20    b->pos = (int*) malloc(sizeof(int));%20    b->size_of_pos = 1;%20    %20    b->pos[0] = line;%20    b->value = word;%20    b->next = NULL;%20    ts->heads[bucket] = b;%20    return;%20  }%20%20  vs_entry_t* p = b;%20%20  while (p->next != NULL) {%20    if (!my_str_cmp(word, p->value)) {%20      p->pos = (int*) realloc(p->pos, sizeof(int) * p->size_of_pos + 1);%20      p->pos[p->size_of_pos] = line;%20      p->size_of_pos++;%20      return;%20%20    } else {%20      p = p->next;%20%20    }%20  }%20  %20  vs_entry_t* add = (vs_entry_t*) malloc(sizeof(vs_entry_t));%20  add->pos = (int*) malloc(sizeof(int));%20  add->pos = line;%20  add->size_of_pos = 1;%20  add->value = word;%20  add->next = NULL;%20  p->next = add;%20%20} | 1
2025-09-17 18:06:15.705 | Query: How to initalize pos correctly.%20typedef struct table_string {%20  vs_entry_t **heads; // Array to maintain the heads of each bucket.%20  int buckets;        // Buckets can only be a power of 2.%20} table_string;%20%20typedef struct vs_entry {%20  char *value;%20  struct vs_entry *next;%20%20#ifdef POS_COUNT%20  int* pos; // This keeps track of each pos the word is found in%20  int  size_of_pos; // This keeps size of pos. Remember in C we track array size explicitly.%20#endif%20} vs_entry_t; | 1
2025-09-17 18:08:04.209 | Query: How to initalize pos correctly and resize it.%20typedef struct table_string {%20  vs_entry_t **heads; // Array to maintain the heads of each bucket.%20  int buckets;        // Buckets can only be a power of 2.%20} table_string;%20%20typedef struct vs_entry {%20  char *value;%20  struct vs_entry *next;%20%20#ifdef POS_COUNT%20  int* pos; // This keeps track of each pos the word is found in%20  int  size_of_pos; // This keeps size of pos. Remember in C we track array size explicitly.%20#endif%20} vs_entry_t;%20%20void table_string_insert_or_add(table_string *ts, char *word, int line) {%20  // Find the bucket for word. djb2 will return a value between 0-buckets-1.%20  // Rule: buckets can only be power of 2.%20  int bucket = djb2_word_to_bucket(word, ts->buckets);%20  // TODO:%20  // Case head == NULL: bucket hasn't been initialized yet%20  // Case word already in list, add to line array.%20  // Case word not found, insert word and return.%20  vs_entry_t* b = ts->heads[bucket];%20%20  if (b == NULL) {%20    vs_entry_t* add = (vs_entry_t*) malloc(sizeof(vs_entry_t));%20    add->pos = (int*) malloc(1 * sizeof(int));%20    add->size_of_pos = 1;%20    %20    add->pos[0] = line;%20    add->value = word;%20    add->next = NULL;%20    ts->heads[bucket] = add;%20    return;%20  }%20%20  vs_entry_t* p = b;%20%20  while (p->next != NULL) {%20    if (!my_str_cmp(word, p->value)) {%20      int* newPos = (int*) realloc(p->pos, sizeof(int) * p->size_of_pos + 1);%20      free(p->pos);%20      p->pos = newPos;%20      p->pos[p->size_of_pos] = line;%20      p->size_of_pos++;%20      return;%20%20    } else {%20      p = p->next;%20%20    }%20  }%20  %20  vs_entry_t* add = (vs_entry_t*) malloc(sizeof(vs_entry_t));%20  add->pos = (int*) malloc(1 * sizeof(int));%20  add->pos[0] = line;%20  add->size_of_pos = 1;%20  add->value = word;%20  add->next = NULL;%20  p->next = add;%20%20} | 1
2025-09-17 18:16:48.856 | Query: Debug:       char* word_ptr = (char*) malloc(sizeof(char) * word->len - 1); leaks 5 bytes%20%20%20#include <ctype.h>%20#include <fcntl.h>%20#include <stdio.h>%20#include <stdlib.h>%20#include <string.h>%20#include <vector_char.h>%20#include <vector_string.h>%20int main(int argc, char **argv) {%20  char *source = NULL;%20%20  if (argc != 2) {%20    printf("./grade_tokenize.bin [FILE PATH]");%20    exit(1);%20  }%20  /**%20   * @brief Read file into source.%20   * source is a character array with file contents%20   * It is null terminated%20   */%20  FILE *fp = fopen(argv[1], "r");%20  if (fp == NULL) { /* Error */%20    printf("Error reading file");%20    exit(1);%20  }%20  if (fp != NULL) {%20    /* Go to the end of the file. */%20    if (fseek(fp, 0L, SEEK_END) == 0) {%20      /* Get the size of the file. */%20      long bufsize = ftell(fp);%20      if (bufsize == -1) { /* Error */%20        printf("Error reading file");%20      }%20      /* Allocate our buffer to that size. */%20      source = malloc(sizeof(char) * (bufsize + 1));%20      /* Go back to the start of the file. */%20      if (fseek(fp, 0L, SEEK_SET) != 0) { /* Error */%20      }%20      /* Read the entire file into memory. */%20      size_t newLen = fread(source, sizeof(char), bufsize, fp);%20      if (ferror(fp) != 0) {%20        printf("Error reading file");%20      } else {%20        source[newLen++] = '\0'; /* Just to be safe. */%20      }%20    }%20  }%20  fclose(fp);%20%20  // TODO: Process source[] and count the number of words%20  // Print the number of words in the end.%20  int count = 0;%20  vector_string* vs = vector_string_allocate();%20  vector_char_t* word = vector_char_allocate();%20%20%20  int i = 0;%20  while (source[i] != '\0') {%20%20    if ((source[i] >= 65 && source[i] <= 90) || (source[i] >= 97 && source[i] <= 122)) {%20      vector_char_add(word, source[i]);%20%20    } else {%20      vector_char_add(word, '\0');%20%20      char* word_ptr = (char*) malloc(sizeof(char) * word->len - 1);%20      char* temp = vector_char_get_array(word);%20      for (int j = 0; j < word->len - 1; j++) {%20        word_ptr[j] = temp[j];%20      }%20      word_ptr[word->len - 1] = '\0';%20%20      vector_string_insert(vs, word_ptr);%20%20      vector_char_delete(word);%20      word = vector_char_allocate();%20%20    }%20    i++;%20  }%20%20  vector_string_print(vs);%20%20  vector_string_deallocate(vs);%20  vector_char_delete(word);%20%20  free(source);%20%20  return 0;%20} | 1
2025-09-17 18:27:21.090 | Query: Debug infinate loop;%20void table_string_print(table_string *ts) {%20  /** TODO:%20   for each bucket%20    for each entry in bucket%20      print entry->word: line line line%20  */%20  if (ts == NULL || ts->heads == NULL) {%20    return;%20  }%20%20  for (int i = 0; i < ts->buckets; i++) {%20    vs_entry_t* p = ts->heads[i];%20%20    while (p != NULL) {%20      printf("%s: ", p->value);%20%20      for (int j = 0; j < p->size_of_pos; j++) {%20        printf("%d ", p->pos[j]);%20      }%20      printf("\n");%20    }%20%20  }%20}%20 | 1
2025-09-17 18:48:09.050 | Query: Conditional jump or move depends on uninitialised value%20 for (int j = 0; j < p->size_of_pos; j++) {%20        printf("%d ", p->pos[j]);%20      }%20%20typedef struct vs_entry {%20  char *value;%20  struct vs_entry *next;%20%20// Conditionally compiled in code. Not relevant for part 2. You can assume the%20// int count declaration does not exist and is irrelevant for part 2.%20#ifdef POS_COUNT%20  int* pos; // This keeps track of each pos the word is found in%20  int  size_of_pos; // This keeps size of pos. Remember in C we track array size explicitly.%20#endif%20} vs_entry_t;%20%20typedef struct table_string {%20  vs_entry_t **heads; // Array to maintain the heads of each bucket.%20  int buckets;        // Buckets can only be a power of 2.%20} table_string; | 1
2025-09-17 18:57:16.858 | Query: Debug:%20#include "table_string.h"%20#include "str_cmp.h"%20#include <stdbool.h>%20#include <stdint.h>%20#include <stdio.h>%20#include <stdlib.h>%20#include <string.h>%20%20#define BUCKETS%20// DO NOT ADD ANY NEW FUNCTIONS BEFORE djb2%20// Hash a character array to integer value between 0 and buckets-1.%20// See here for more details: https://theartincode.stanis.me/008-djb2/%20unsigned int djb2_word_to_bucket(char *word, int buckets) {%20  if (!word) {%20    printf("Invoked with null string");%20    exit(EXIT_FAILURE);%20  }%20  unsigned long hash = 5381;%20  uint32_t i;%20%20  for (i = 0; i < strlen(word); i++)%20    hash = ((hash << 5) + hash) + word[i];%20%20  return hash & (buckets - 1);%20}%20// ADD YOUR HELPER FUNCTIONS AFTER djb2%20/**%20 * @brief Instantiate a table string%20 *%20 * @param buckets%20 * @return table_string*%20 */%20table_string *table_string_allocate(unsigned int buckets) {%20  // Instantiate a bucket number of heads%20  table_string* ts = (table_string*) malloc(sizeof(table_string));%20%20%20  ts->heads = (vs_entry_t**) malloc(buckets * sizeof(vs_entry_t*));%20%20  for (int i = 0; i < buckets; i++) {%20    ts->heads[i] = NULL;%20  }%20  ts->buckets = buckets;%20%20  return ts;%20}%20%20/**%20 * @brief Insert the string pointed to by word into the table string.%20 *   If word is already found increment count.%20 *   If word is not found insert at the end of the corresponding bucket%20 * @param ts - Pointer to table_string datastructure%20 * @param word - Pointer to string to search for%20 * @return * Find*%20 */%20void table_string_insert_or_add(table_string *ts, char *word, int line) {%20  // Find the bucket for word. djb2 will return a value between 0-buckets-1.%20  // Rule: buckets can only be power of 2.%20  int bucket = djb2_word_to_bucket(word, ts->buckets);%20  // TODO:%20  // Case head == NULL: bucket hasn't been initialized yet%20  // Case word already in list, add to line array.%20  // Case word not found, insert word and return.%20  vs_entry_t* b = ts->heads[bucket];%20%20  if (b == NULL) {%20    vs_entry_t* add = (vs_entry_t*) malloc(sizeof(vs_entry_t));%20    add->pos = (int*) malloc(sizeof(int) * 1);%20    add->size_of_pos = 1;%20    %20    add->pos[0] = line;%20    add->value = word;%20    add->next = NULL;%20    ts->heads[bucket] = add;%20    return;%20  }%20%20  vs_entry_t* p = b;%20%20  while (p->next != NULL) {%20    if (!my_str_cmp(word, p->value)) {%20      int* newPos = (int*) realloc(p->pos, sizeof(int) * p->size_of_pos + 1);%20      p->pos = newPos;%20      p->pos[p->size_of_pos] = line;%20      p->size_of_pos++;%20      return;%20%20    } else {%20      p = p->next;%20%20    }%20  }%20  %20  vs_entry_t* add = (vs_entry_t*) malloc(sizeof(vs_entry_t));%20  add->pos = (int*) malloc(sizeof(int) * 1);%20  add->pos[0] = line;%20  add->size_of_pos = 1;%20  add->value = word;%20  add->next = NULL;%20  p->next = add;%20%20}%20%20void table_string_deallocate(table_string *ts) {%20  // TODO:%20  // Free the linked list of each bucket%20  // Free the array of head pointers%20  // Free the structure itself%20  for (int i = 0; i < ts->buckets; i++) {%20%20    vs_entry_t* p = ts->heads[i];%20    vs_entry_t* next = p;;%20%20    while (next != NULL) {%20      next = p->next;%20      free(p->pos);%20      free(p->value);%20      free(p);%20      p = next;%20    }%20    p = NULL;%20%20  }%20%20  free(ts->heads);%20  free(ts);%20%20  return;%20}%20%20void table_string_print(table_string *ts) {%20  /** TODO:%20   for each bucket%20    for each entry in bucket%20      print entry->word: line line line%20  */%20  if (ts == NULL || ts->heads == NULL) {%20    return;%20  }%20%20  for (int i = 0; i < ts->buckets; i++) {%20    vs_entry_t* p = ts->heads[i];%20%20    while (p != NULL) {%20      printf("%s: ", p->value);%20%20      for (int j = 0; j < p->size_of_pos; j++) {%20        printf("%d ", p->pos[j]);%20      }%20      printf("\n");%20%20      p = p->next;%20    }%20%20  }%20}%20%20int buckets = 4;%20  table_string *ts = table_string_allocate(buckets);%20%20  vector_char_t* word = vector_char_allocate();%20%20%20  int i = 0;%20  int line = 0;%20%20  while (source[i] != '\0') {%20    if ((source[i] >= 65 && source[i] <= 90) || (source[i] >= 97 && source[i] <= 122)) {%20      vector_char_add(word, source[i]);%20%20    } else {%20      vector_char_add(word, '\0');%20%20      char* word_ptr = (char*) malloc(sizeof(char) * word->len);%20      char* temp = vector_char_get_array(word);%20      for (int j = 0; j < word->len - 1; j++) {%20        word_ptr[j] = temp[j];%20      }%20      word_ptr[word->len - 1] = '\0';%20%20      table_string_insert_or_add(ts, word_ptr, line);%20%20      vector_char_delete(word);%20      word = vector_char_allocate();%20      line++;%20%20    }%20    i++;%20  }%20%20  table_string_print(ts);%20%20  table_string_deallocate(ts);%20  vector_char_delete(word);%20 | 1
2025-09-17 22:30:37.076 | Query: I have a vector char:%20struct vector_char {%20  uint32_t len;%20  uint32_t max;%20  char *data;%20};%20%20that I use to create and store strings. I then get the data property from the struct and add it as the value to a vs_entry:%20typedef struct vs_entry {%20  char *value;%20  struct vs_entry *next;%20}%20that is in a vector string:%20typedef struct vector_string {%20  vs_entry_t *head;%20  vs_entry_t *tail;%20} vector_string;%20%20To free the vector_char, I'm given this function:%20void vector_char_delete(vector_char_t *vector_char) {%20  if (!vector_char)%20    return;%20%20  if (vector_char->max)%20    _free(vector_char->data);%20%20  _free(vector_char);%20}%20%20However, if I run this after adding the data to a vs_entry, the value property in the vs_entry will be wiped since they both point to the same location in memory. How can I fix this? | 1
2025-09-17 22:32:33.017 | Query: I have a vector char:%20struct vector_char {%20  uint32_t len;%20  uint32_t max;%20  char *data;%20};%20%20that I use to create and store strings. I then get the data property from the struct and add it as the value to a vs_entry:%20typedef struct vs_entry {%20  char *value;%20  struct vs_entry *next;%20}%20that is in a vector string:%20typedef struct vector_string {%20  vs_entry_t *head;%20  vs_entry_t *tail;%20} vector_string;%20%20To free the vector_char, I'm given this function:%20void vector_char_delete(vector_char_t *vector_char) {%20  if (!vector_char)%20    return;%20%20  if (vector_char->max)%20    _free(vector_char->data);%20%20  _free(vector_char);%20}%20%20However, if I run this after adding the data to a vs_entry, the value property in the vs_entry will be wiped since they both point to the same location in memory. How can I fix this? I am not allowed to use strcpy or strncpy. | 1
2025-09-18 16:58:37.699 | Query: what does this mean (after running make):%20%20collect2: error: ld returned 1 exit status%20make: *** [<builtin>: poscount] Error 1 | 1
2025-09-18 18:09:49.838 | Query: debug, loop hits one extra time:%20%20int buckets = 4;%20  table_string *ts = table_string_allocate(buckets);%20%20  vector_char_t* word = vector_char_allocate();%20%20%20  int i = 0;%20  int line = 0;%20%20  while (source[i] != '\0') {%20    if ((source[i] >= 65 && source[i] <= 90) || (source[i] >= 97 && source[i] <= 122)) {%20      vector_char_add(word, source[i]);%20%20    } else {%20%20      vector_char_add(word, '\0');%20%20%20      char* word_ptr = (char*) malloc(sizeof(char) * word->len);%20      char* temp = vector_char_get_array(word);%20      for (int j = 0; j < word->len - 1; j++) {%20        word_ptr[j] = temp[j];%20      }%20      word_ptr[word->len - 1] = '\0';%20%20      printf("hit: %s\n", word_ptr);%20%20      table_string_insert_or_add(ts, word_ptr, line);%20%20      vector_char_delete(word);%20      word = vector_char_allocate();%20      line++;%20%20    }%20    i++;%20  }%20%20  table_string_print(ts);%20%20  table_string_deallocate(ts);%20  vector_char_delete(word);%20  | 1
2025-09-18 18:27:51.032 | Query: Debug:%20%20#include "table_string.h"%20#include "str_cmp.h"%20#include <stdbool.h>%20#include <stdint.h>%20#include <stdio.h>%20#include <stdlib.h>%20#include <string.h>%20%20#define BUCKETS%20// DO NOT ADD ANY NEW FUNCTIONS BEFORE djb2%20// Hash a character array to integer value between 0 and buckets-1.%20// See here for more details: https://theartincode.stanis.me/008-djb2/%20unsigned int djb2_word_to_bucket(char *word, int buckets) {%20  if (!word) {%20    printf("Invoked with null string");%20    exit(EXIT_FAILURE);%20  }%20  unsigned long hash = 5381;%20  uint32_t i;%20%20  for (i = 0; i < strlen(word); i++)%20    hash = ((hash << 5) + hash) + word[i];%20%20  return hash & (buckets - 1);%20}%20// ADD YOUR HELPER FUNCTIONS AFTER djb2%20/**%20 * @brief Instantiate a table string%20 *%20 * @param buckets%20 * @return table_string*%20 */%20table_string *table_string_allocate(unsigned int buckets) {%20  // Instantiate a bucket number of heads%20  table_string* ts = (table_string*) malloc(sizeof(table_string));%20%20%20  ts->heads = (vs_entry_t**) malloc(buckets * sizeof(vs_entry_t*));%20%20  for (int i = 0; i < buckets; i++) {%20    ts->heads[i] = NULL;%20  }%20  ts->buckets = buckets;%20%20  return ts;%20}%20%20/**%20 * @brief Insert the string pointed to by word into the table string.%20 *   If word is already found increment count.%20 *   If word is not found insert at the end of the corresponding bucket%20 * @param ts - Pointer to table_string datastructure%20 * @param word - Pointer to string to search for%20 * @return * Find*%20 */%20void table_string_insert_or_add(table_string *ts, char *word, int line) {%20  // Find the bucket for word. djb2 will return a value between 0-buckets-1.%20  // Rule: buckets can only be power of 2.%20  int bucket = djb2_word_to_bucket(word, ts->buckets);%20  // TODO:%20  // Case head == NULL: bucket hasn't been initialized yet%20  // Case word already in list, add to line array.%20  // Case word not found, insert word and return.%20  vs_entry_t* b = ts->heads[bucket];%20%20  if (b == NULL) {%20    vs_entry_t* add = (vs_entry_t*) malloc(sizeof(vs_entry_t));%20    add->pos = (int*) malloc(sizeof(int) * 1);%20    add->size_of_pos = 1;%20    %20    add->pos[0] = line;%20    add->value = word;%20    add->next = NULL;%20    ts->heads[bucket] = add;%20    return;%20  }%20%20%20  vs_entry_t* p = b;%20%20  do {%20    if (!my_str_cmp(word, p->value)) {%20      // int* newPos%20      p->pos = (int*) realloc(p->pos, sizeof(int) * (p->size_of_pos + 1));%20      // p->pos = newPos;%20      p->pos[p->size_of_pos] = line;%20      p->size_of_pos++;%20      return;%20%20    } else if (p!=NULL){%20      p = p->next;%20%20    }%20    %20  } while(p != NULL);%20  %20  vs_entry_t* add = (vs_entry_t*) malloc(sizeof(vs_entry_t));%20  add->pos = (int*) malloc(sizeof(int));%20  add->pos[0] = line;%20  add->size_of_pos = 1;%20  add->value = word;%20  add->next = NULL;%20  p->next = add;%20%20}%20%20void table_string_deallocate(table_string *ts) {%20  // TODO:%20  // Free the linked list of each bucket%20  // Free the array of head pointers%20  // Free the structure itself%20  for (int i = 0; i < ts->buckets; i++) {%20%20    vs_entry_t* p = ts->heads[i];%20    vs_entry_t* next = p;;%20%20    while (next != NULL) {%20      next = p->next;%20      free(p->pos);%20      free(p->value);%20      free(p);%20      p = next;%20    }%20    p = NULL;%20%20  }%20%20  free(ts->heads);%20  free(ts);%20%20  return;%20}%20%20void table_string_print(table_string *ts) {%20  /** TODO:%20   for each bucket%20    for each entry in bucket%20      print entry->word: line line line%20  */%20  if (ts == NULL || ts->heads == NULL) {%20    return;%20  }%20%20  for (int i = 0; i < ts->buckets; i++) {%20    vs_entry_t* p = ts->heads[i];%20%20    while (p != NULL) {%20      printf("%s: ", p->value);%20%20      for (int j = 0; j < p->size_of_pos; j++) {%20        printf("%d ", p->pos[j]);%20      }%20      printf("\n");%20%20      p = p->next;%20    }%20%20  }%20}%20 | 1
2025-09-18 18:43:44.142 | Query: if you malloc in C, will there still be garbage value in the data that you requested that you have to set to NULL? | 1
2025-09-18 18:51:36.600 | Query: Debug%20%20typedef struct vs_entry {%20  char *value;%20  struct vs_entry *next;%20%20#ifdef POS_COUNT%20  int* pos; // This keeps track of each pos the word is found in%20  int  size_of_pos; // This keeps size of pos. Remember in C we track array size explicitly.%20#endif%20} vs_entry_t;%20%20// Struct describing the data structure vector_string%20// head* points to the entry which is the start of vector string%20typedef struct vector_string {%20  vs_entry_t *head;%20  vs_entry_t *tail;%20} vector_string;%20typedef struct table_string {%20  vs_entry_t **heads; // Array to maintain the heads of each bucket.%20  int buckets;        // Buckets can only be a power of 2.%20} table_string;%20%20#include "table_string.h"%20#include "str_cmp.h"%20#include <stdbool.h>%20#include <stdint.h>%20#include <stdio.h>%20#include <stdlib.h>%20#include <string.h>%20%20#define BUCKETS%20// DO NOT ADD ANY NEW FUNCTIONS BEFORE djb2%20// Hash a character array to integer value between 0 and buckets-1.%20// See here for more details: https://theartincode.stanis.me/008-djb2/%20unsigned int djb2_word_to_bucket(char *word, int buckets) {%20  if (!word) {%20    printf("Invoked with null string");%20    exit(EXIT_FAILURE);%20  }%20  unsigned long hash = 5381;%20  uint32_t i;%20%20  for (i = 0; i < strlen(word); i++)%20    hash = ((hash << 5) + hash) + word[i];%20%20  return hash & (buckets - 1);%20}%20// ADD YOUR HELPER FUNCTIONS AFTER djb2%20/**%20 * @brief Instantiate a table string%20 *%20 * @param buckets%20 * @return table_string*%20 */%20table_string *table_string_allocate(unsigned int buckets) {%20  // Instantiate a bucket number of heads%20  table_string* ts = (table_string*) malloc(sizeof(table_string));%20%20%20  ts->heads = (vs_entry_t**) malloc(buckets * sizeof(vs_entry_t*));%20%20  for (int i = 0; i < buckets; i++) {%20    ts->heads[i] = NULL;%20  }%20  ts->buckets = buckets;%20%20  return ts;%20}%20%20/**%20 * @brief Insert the string pointed to by word into the table string.%20 *   If word is already found increment count.%20 *   If word is not found insert at the end of the corresponding bucket%20 * @param ts - Pointer to table_string datastructure%20 * @param word - Pointer to string to search for%20 * @return * Find*%20 */%20void table_string_insert_or_add(table_string *ts, char *word, int line) {%20  // Find the bucket for word. djb2 will return a value between 0-buckets-1.%20  // Rule: buckets can only be power of 2.%20  int bucket = djb2_word_to_bucket(word, ts->buckets);%20  // TODO:%20  // Case head == NULL: bucket hasn't been initialized yet%20  // Case word already in list, add to line array.%20  // Case word not found, insert word and return.%20  vs_entry_t* p = ts->heads[bucket];%20%20  while(p != NULL ) {%20    if (!my_str_cmp(word, p->value)) {%20      int* newPos = (int*) realloc(p->pos, sizeof(int) * (p->size_of_pos + 1));%20      p->pos = newPos;%20      p->pos[p->size_of_pos] = line;%20      p->size_of_pos++;%20      return;%20%20    } else if (p!=NULL) {%20      p = p->next;%20%20    }%20    %20  } %20  %20  vs_entry_t* add = (vs_entry_t*) malloc(sizeof(vs_entry_t));%20  add->pos = (int*) malloc(sizeof(int));%20  add->pos[0] = line;%20  add->size_of_pos = 1;%20  add->value = word;%20  add->next = NULL;%20%20  if (p == NULL) {%20    ts->heads[bucket] = add;%20  } else {%20    p->next = add;%20  }%20%20}%20%20void table_string_deallocate(table_string *ts) {%20  // TODO:%20  // Free the linked list of each bucket%20  // Free the array of head pointers%20  // Free the structure itself%20  for (int i = 0; i < ts->buckets; i++) {%20%20    vs_entry_t* p = ts->heads[i];%20    vs_entry_t* next = p;;%20%20    while (next != NULL) {%20      next = p->next;%20      free(p->pos);%20      free(p->value);%20      free(p);%20      p = next;%20    }%20    p = NULL;%20%20  }%20%20  free(ts->heads);%20  free(ts);%20%20  return;%20}%20%20void table_string_print(table_string *ts) {%20  /** TODO:%20   for each bucket%20    for each entry in bucket%20      print entry->word: line line line%20  */%20  if (ts == NULL || ts->heads == NULL) {%20    return;%20  }%20%20  for (int i = 0; i < ts->buckets; i++) {%20    vs_entry_t* p = ts->heads[i];%20%20    while (p != NULL) {%20      printf("%s: ", p->value);%20%20      for (int j = 0; j < p->size_of_pos; j++) {%20        printf("%d ", p->pos[j]);%20      }%20      printf("\n");%20%20      p = p->next;%20    }%20%20  }%20}%20 | 1
2025-09-18 18:54:58.346 | Query: Debug%20%20typedef struct vs_entry {%20  char *value;%20  struct vs_entry *next;%20%20#ifdef POS_COUNT%20  int* pos; // This keeps track of each pos the word is found in%20  int  size_of_pos; // This keeps size of pos. Remember in C we track array size explicitly.%20#endif%20} vs_entry_t;%20%20// Struct describing the data structure vector_string%20// head* points to the entry which is the start of vector string%20typedef struct vector_string {%20  vs_entry_t *head;%20  vs_entry_t *tail;%20} vector_string;%20typedef struct table_string {%20  vs_entry_t **heads; // Array to maintain the heads of each bucket.%20  int buckets;        // Buckets can only be a power of 2.%20} table_string;%20%20#include "table_string.h"%20#include "str_cmp.h"%20#include <stdbool.h>%20#include <stdint.h>%20#include <stdio.h>%20#include <stdlib.h>%20#include <string.h>%20%20#define BUCKETS%20// DO NOT ADD ANY NEW FUNCTIONS BEFORE djb2%20// Hash a character array to integer value between 0 and buckets-1.%20// See here for more details: https://theartincode.stanis.me/008-djb2/%20unsigned int djb2_word_to_bucket(char *word, int buckets) {%20  if (!word) {%20    printf("Invoked with null string");%20    exit(EXIT_FAILURE);%20  }%20  unsigned long hash = 5381;%20  uint32_t i;%20%20  for (i = 0; i < strlen(word); i++)%20    hash = ((hash << 5) + hash) + word[i];%20%20  return hash & (buckets - 1);%20}%20// ADD YOUR HELPER FUNCTIONS AFTER djb2%20/**%20 * @brief Instantiate a table string%20 *%20 * @param buckets%20 * @return table_string*%20 */%20table_string *table_string_allocate(unsigned int buckets) {%20  // Instantiate a bucket number of heads%20  table_string* ts = (table_string*) malloc(sizeof(table_string));%20%20%20  ts->heads = (vs_entry_t**) malloc(buckets * sizeof(vs_entry_t*));%20%20  for (int i = 0; i < buckets; i++) {%20    ts->heads[i] = NULL;%20  }%20  ts->buckets = buckets;%20%20  return ts;%20}%20%20/**%20 * @brief Insert the string pointed to by word into the table string.%20 *   If word is already found increment count.%20 *   If word is not found insert at the end of the corresponding bucket%20 * @param ts - Pointer to table_string datastructure%20 * @param word - Pointer to string to search for%20 * @return * Find*%20 */%20void table_string_insert_or_add(table_string *ts, char *word, int line) {%20  // Find the bucket for word. djb2 will return a value between 0-buckets-1.%20  // Rule: buckets can only be power of 2.%20  int bucket = djb2_word_to_bucket(word, ts->buckets);%20  // TODO:%20  // Case head == NULL: bucket hasn't been initialized yet%20  // Case word already in list, add to line array.%20  // Case word not found, insert word and return.%20  vs_entry_t* p = ts->heads[bucket];%20%20  while(p != NULL ) {%20    if (!my_str_cmp(word, p->value)) {%20      int* newPos = (int*) realloc(p->pos, sizeof(int) * (p->size_of_pos + 1));%20      p->pos = newPos;%20      p->pos[p->size_of_pos] = line;%20      p->size_of_pos++;%20      return;%20%20    } else if (p!=NULL) {%20      p = p->next;%20%20    }%20    %20  } %20  %20  vs_entry_t* add = (vs_entry_t*) malloc(sizeof(vs_entry_t));%20  add->pos = (int*) malloc(sizeof(int));%20  add->pos[0] = line;%20  add->size_of_pos = 1;%20  add->value = word;%20  add->next = NULL;%20%20  if (p == NULL) {%20    ts->heads[bucket] = add;%20  } else {%20    p->next = add;%20  }%20%20}%20%20void table_string_deallocate(table_string *ts) {%20  // TODO:%20  // Free the linked list of each bucket%20  // Free the array of head pointers%20  // Free the structure itself%20  for (int i = 0; i < ts->buckets; i++) {%20%20    vs_entry_t* p = ts->heads[i];%20    vs_entry_t* next = p;;%20%20    while (next != NULL) {%20      next = p->next;%20      free(p->pos);%20      free(p->value);%20      free(p);%20      p = next;%20    }%20    p = NULL;%20%20  }%20%20  free(ts->heads);%20  free(ts);%20%20  return;%20}%20%20void table_string_print(table_string *ts) {%20  /** TODO:%20   for each bucket%20    for each entry in bucket%20      print entry->word: line line line%20  */%20  if (ts == NULL || ts->heads == NULL) {%20    return;%20  }%20%20  for (int i = 0; i < ts->buckets; i++) {%20    vs_entry_t* p = ts->heads[i];%20%20    while (p != NULL) {%20      printf("%s: ", p->value);%20%20      for (int j = 0; j < p->size_of_pos; j++) {%20        printf("%d ", p->pos[j]);%20      }%20      printf("\n");%20%20      p = p->next;%20    }%20%20  }%20}%20%20int buckets = 4;%20  table_string *ts = table_string_allocate(buckets);%20%20  vector_char_t* word = vector_char_allocate();%20%20%20  int i = 0;%20  int line = 0;%20%20  while (source[i] != '\0') {%20    if ((source[i] >= 65 && source[i] <= 90) || (source[i] >= 97 && source[i] <= 122)) {%20      vector_char_add(word, source[i]);%20%20    } else if (word->len > 0){%20%20      vector_char_add(word, '\0');%20%20      char* word_ptr = (char*) malloc(sizeof(char) * word->len);%20      memcpy(word_ptr, vector_char_get_array(word), word->len);%20%20      table_string_insert_or_add(ts, word_ptr, line);%20%20      vector_char_delete(word);%20      word = vector_char_allocate();%20      line++;%20%20    } else {%20      vector_char_delete(word);%20%20    }%20    i++;%20  }%20%20  table_string_print(ts);%20%20  table_string_deallocate(ts);%20  vector_char_delete(word); | 1
2025-09-18 19:09:15.985 | Query: How would I deallocate everything%20%20typedef struct table_string {%20  vs_entry_t **heads; // Array to maintain the heads of each bucket.%20  int buckets;        // Buckets can only be a power of 2.%20} table_string;%20%20%20typedef struct vs_entry {%20  char *value;%20  struct vs_entry *next;%20%20#ifdef POS_COUNT%20  int* pos; // This keeps track of each pos the word is found in%20  int  size_of_pos; // This keeps size of pos. Remember in C we track array size explicitly.%20#endif%20} vs_entry_t; | 1
2025-09-18 19:12:29.409 | Query: Debug:%20void table_string_deallocate(table_string *ts) {%20  // TODO:%20  // Free the linked list of each bucket%20  // Free the array of head pointers%20  // Free the structure itself%20  if (ts == NULL) {%20    return;%20  }%20  %20  for (int i = 0; i < ts->buckets; i++) {%20%20    vs_entry_t* p = ts->heads[i];%20    vs_entry_t* next = p;%20%20    while (next != NULL) {%20      next = p->next;%20      free(p->pos);%20      free(p->value);%20      free(p);%20      p = next;%20    }%20    p = NULL;%20%20  }%20%20  free(ts->heads);%20  free(ts);%20%20  return;%20}%20%20typedef struct table_string {%20  vs_entry_t **heads; // Array to maintain the heads of each bucket.%20  int buckets;        // Buckets can only be a power of 2.%20} table_string;%20%20%20typedef struct vs_entry {%20  char *value;%20  struct vs_entry *next;%20%20#ifdef POS_COUNT%20  int* pos; // This keeps track of each pos the word is found in%20  int  size_of_pos; // This keeps size of pos. Remember in C we track array size explicitly.%20#endif%20} vs_entry_t; | 1
2025-09-18 19:36:44.066 | Query: Debug:%20void table_string_insert_or_add(table_string *ts, char *word, int line) {%20  // Find the bucket for word. djb2 will return a value between 0-buckets-1.%20  // Rule: buckets can only be power of 2.%20  int bucket = djb2_word_to_bucket(word, ts->buckets);%20  // TODO:%20  // Case head == NULL: bucket hasn't been initialized yet%20  // Case word already in list, add to line array.%20  // Case word not found, insert word and return.%20%20  if (ts == NULL) {%20    return;%20  }%20%20  vs_entry_t* p = ts->heads[bucket];%20%20  vs_entry_t* last;%20  while (p != NULL) {%20%20    if (!my_str_cmp(word, p->value)) {%20      printf("FOUND MATCH%s\n",p->value);%20      p->pos = (int*) realloc(p->pos, sizeof(int) * p->size_of_pos + 1);%20      p->pos[p->size_of_pos] = line;%20      p->size_of_pos++;%20%20      return;%20    } %20%20    last = p;%20    p = p->next;%20  }%20%20  vs_entry_t* add = (vs_entry_t*) malloc(sizeof(vs_entry_t));%20  add->next = NULL;%20  add->value = word;%20  add->size_of_pos = 1;%20  add->pos = (int*) malloc(sizeof(int));%20  add->pos[0] = line;%20%20  if (p == NULL) {%20    ts->heads[bucket] = add;%20  } else {%20    last->next = add;%20  }%20%20}%20%20typedef struct table_string {%20  vs_entry_t **heads; // Array to maintain the heads of each bucket.%20  int buckets;        // Buckets can only be a power of 2.%20} table_string;%20%20%20typedef struct vs_entry {%20  char *value;%20  struct vs_entry *next;%20%20#ifdef POS_COUNT%20  int* pos; // This keeps track of each pos the word is found in%20  int  size_of_pos; // This keeps size of pos. Remember in C we track array size explicitly.%20#endif%20} vs_entry_t; | 1
2025-09-18 21:19:49.870 | Query: Debug why there is a 6byte memory leak from word_ptr = (char*) malloc(sizeof(char) * word->len);:%20vector_string *vector_string_allocate() {%20  vector_string* vs = (vector_string*) malloc(sizeof(vector_string));%20  %20  if (vs == NULL) {%20    return NULL;%20  }%20%20  vs->head = NULL;%20  vs->tail = NULL;%20%20  return vs;%20}%20%20/**%20 * @brief Search the vector string pointed to by vs and return true if the%20 * vs_entry.value == key, else return false.%20 * TODO:%20 * @param vs - Pointer to vector_string datastructure%20 * @param key - Pointer to string to search for%20 * @return * Find*%20 */%20bool vector_string_find(vector_string *vs, char *key) { %20  if (vs == NULL || vs->head == NULL) {%20    return false;%20  }%20%20%20  vs_entry_t* p = vs->head;%20%20  if (!strcmp(p->value, key) || !strcmp(vs->tail->value, key)) {%20    return true;%20  }%20%20  if (p->next != NULL) {%20    p = p->next;%20  } else {%20    return false;%20  }%20%20  while (p != vs->tail) {%20    if (strcmp(p->value, key)) {%20      p = p->next;%20%20    } else {%20      return true;%20%20    }%20%20  }%20  %20  return false; %20}%20%20/**%20 * @brief TODO: Insert the string pointed to by key into the vector string.%20 *  char* is externally allocated. You do not have to allocate internally%20 *%20 * @param vs - Pointer to vector_string datastructure%20 * @param key - Pointer to string to search for%20 * @return * Find*%20 */%20void vector_string_insert(vector_string *vs, char *key) {%20  // Insert the string into the tail of the list.%20  if (vs == NULL) {%20    return;%20  }%20%20  if (vs->head != NULL && vector_string_find(vs, key)) {%20    return;%20  }%20  %20  vs_entry_t* add = (vs_entry_t*) malloc(sizeof(vs_entry_t));%20  if (add == NULL) {%20    return;%20  }%20%20  add->next = NULL;%20  add->value = key;%20%20%20%20  if (vs->head == NULL && vs->tail == NULL) {%20    vs->head = add;%20    vs->tail = add;%20%20%20  } else {%20    vs->tail->next = add;%20    vs->tail = add;%20%20%20%20  }%20%20  %20}%20/**%20 * @brief Remove all entries and cleanup vector string%20 * TODO: Remove all entries. Remember head and tail are pointers.%20 * Remember to remove vs as well; not just entries. or you will have memory%20 * leaks.%20 * @param vs: Pointer to vector_string struct%20 */%20void vector_string_deallocate(vector_string *vs) {%20  if (vs == NULL || vs->head == NULL) {%20    return;%20  }%20%20  vs_entry_t* p = vs->head;%20  vs_entry_t* next = p;;%20%20  while (next != NULL) {%20    next = p->next;%20    free(p->value);%20    free(p);%20    p = next;%20  }%20  p = NULL;%20%20  free(vs);%20  vs = NULL;%20}%20%20/**%20 * @brief Print all value in each entry of the vector string, in the following%20 * format. In this case hello and world are the unique words in the file.%20 * 1. hello%20 * 2. world%20 * @param vs%20 */%20void vector_string_print(vector_string *vs) {%20  if (vs == NULL || vs->head == NULL%20%20#include <ctype.h>%20#include <fcntl.h>%20#include <stdio.h>%20#include <stdlib.h>%20#include <string.h>%20#include <vector_char.h>%20#include <vector_string.h>%20int main(int argc, char **argv) {%20  char *source = NULL;%20%20  if (argc != 2) {%20    printf("./grade_tokenize.bin [FILE PATH]");%20    exit(1);%20  }%20  /**%20   * @brief Read file into source.%20   * source is a character array with file contents%20   * It is null terminated%20   */%20  FILE *fp = fopen(argv[1], "r");%20  if (fp == NULL) { /* Error */%20    printf("Error reading file");%20    exit(1);%20  }%20  if (fp != NULL) {%20    /* Go to the end of the file. */%20    if (fseek(fp, 0L, SEEK_END) == 0) {%20      /* Get the size of the file. */%20      long bufsize = ftell(fp);%20      if (bufsize == -1) { /* Error */%20        printf("Error reading file");%20      }%20      /* Allocate our buffer to that size. */%20      source = malloc(sizeof(char) * (bufsize + 1));%20      /* Go back to the start of the file. */%20      if (fseek(fp, 0L, SEEK_SET) != 0) { /* Error */%20      }%20      /* Read the entire file into memory. */%20      size_t newLen = fread(source, sizeof(char), bufsize, fp);%20      if (ferror(fp) != 0) {%20        printf("Error reading file");%20      } else {%20        source[newLen++] = '\0'; /* Just to be safe. */%20      }%20    }%20  }%20  fclose(fp);%20%20  // TODO: Process source[] and count the number of words%20  // Print the number of words in the end.%20  int count = 0;%20  vector_string* vs = vector_string_allocate();%20  vector_char_t* word = vector_char_allocate();%20  char* word_ptr;%20  int i = 0;%20  while (source[i] != '\0') {%20%20    if ((source[i] >= 65 && source[i] <= 90) || (source[i] >= 97 && source[i] <= 122)) {%20      vector_char_add(word, source[i]);%20%20    } else if (word->len > 0) {%20      vector_char_add(word, '\0');%20%20      word_ptr = (char*) malloc(sizeof(char) * word->len);%20      memcpy(word_ptr, vector_char_get_array(word), word->len);%20%20      vector_string_insert(vs, word_ptr);%20%20      vector_char_delete(word);%20      word = vector_char_allocate();%20%20    }%20    i++;%20  }%20  vector_string_print(vs);%20%20  vector_string_deallocate(vs);%20  vector_char_delete(word);%20%20  free(source);%20%20  return 0;%20} | 1
2025-09-18 21:28:33.394 | Query: debug why is the deallocator missing something:%20vector_string *vector_string_allocate() {%20  vector_string* vs = (vector_string*) malloc(sizeof(vector_string));%20  %20  if (vs == NULL) {%20    return NULL;%20  }%20%20  vs->head = NULL;%20  vs->tail = NULL;%20%20  return vs;%20}%20%20/**%20 * @brief Search the vector string pointed to by vs and return true if the%20 * vs_entry.value == key, else return false.%20 * TODO:%20 * @param vs - Pointer to vector_string datastructure%20 * @param key - Pointer to string to search for%20 * @return * Find*%20 */%20bool vector_string_find(vector_string *vs, char *key) { %20  if (vs == NULL || vs->head == NULL) {%20    return false;%20  }%20%20%20  vs_entry_t* p = vs->head;%20%20  if (!strcmp(p->value, key) || !strcmp(vs->tail->value, key)) {%20    return true;%20  }%20%20  if (p->next != NULL) {%20    p = p->next;%20  } else {%20    return false;%20  }%20%20  while (p != vs->tail) {%20    if (strcmp(p->value, key)) {%20      p = p->next;%20%20    } else {%20      return true;%20%20    }%20%20  }%20  %20  return false; %20}%20%20/**%20 * @brief TODO: Insert the string pointed to by key into the vector string.%20 *  char* is externally allocated. You do not have to allocate internally%20 *%20 * @param vs - Pointer to vector_string datastructure%20 * @param key - Pointer to string to search for%20 * @return * Find*%20 */%20void vector_string_insert(vector_string *vs, char *key) {%20  // Insert the string into the tail of the list.%20  if (vs == NULL) {%20    return;%20  }%20%20  if (vs->head != NULL && vector_string_find(vs, key)) {%20    return;%20  }%20  %20  vs_entry_t* add = (vs_entry_t*) malloc(sizeof(vs_entry_t));%20  if (add == NULL) {%20    return;%20  }%20%20  add->next = NULL;%20  add->value = key;%20%20%20%20  if (vs->head == NULL && vs->tail == NULL) {%20    vs->head = add;%20    vs->tail = add;%20%20%20  } else {%20    vs->tail->next = add;%20    vs->tail = add;%20%20%20%20  }%20%20  %20}%20/**%20 * @brief Remove all entries and cleanup vector string%20 * TODO: Remove all entries. Remember head and tail are pointers.%20 * Remember to remove vs as well; not just entries. or you will have memory%20 * leaks.%20 * @param vs: Pointer to vector_string struct%20 */%20void vector_string_deallocate(vector_string *vs) {%20  if (vs == NULL || vs->head == NULL) {%20    return;%20  }%20%20  vs_entry_t* p = vs->head;%20  vs_entry_t* next = p;;%20%20  while (next != NULL) {%20    next = p->next;%20    free(p->value);%20    free(p);%20    p = next;%20  }%20  p = NULL;%20%20  free(vs);%20  vs = NULL;%20}%20%20/**%20 * @brief Print all value in each entry of the vector string, in the following%20 * format. In this case hello and world are the unique words in the file.%20 * 1. hello%20 * 2. world%20 * @param vs%20 */%20void vector_string_print(vector_string *vs) {%20  if (vs == NULL || vs->head == NULL) {%20    return;%20  }%20%20  int count = 1;%20  vs_entry_t *entry = vs->head;%20  %20%20  while (entry->next != NULL) {%20    printf("%d. %s\n", count, entry->value);%20%20    entry = entry->next;%20    count++;%20  %20  }%20}%20%20  int count = 0;%20  vector_string* vs = vector_string_allocate();%20  vector_char_t* word = vector_char_allocate();%20  char* word_ptr;%20  int i = 0;%20  while (source[i] != '\0') {%20%20    if ((source[i] >= 65 && source[i] <= 90) || (source[i] >= 97 && source[i] <= 122)) {%20      vector_char_add(word, source[i]);%20%20    } else if (word->len > 0) {%20      vector_char_add(word, '\0');%20%20      word_ptr = (char*) malloc(sizeof(char) * word->len);%20      memcpy(word_ptr, vector_char_get_array(word), word->len);%20%20%20      vector_string_insert(vs, word_ptr);%20%20      vector_char_delete(word);%20      word = vector_char_allocate();%20%20    }%20    i++;%20  }%20%20  vector_string_print(vs);%20%20  vector_string_deallocate(vs);%20  vector_char_delete(word);%20 | 1
2025-09-18 21:33:06.520 |  Query: debug why is the deallocator missing something:%20vector_string *vector_string_allocate() {%20  vector_string* vs = (vector_string*) malloc(sizeof(vector_string));%20  %20  if (vs == NULL) {%20    return NULL;%20  }%20%20  vs->head = NULL;%20  vs->tail = NULL;%20%20  return vs;%20}%20%20/**%20 * @brief Search the vector string pointed to by vs and return true if the%20 * vs_entry.value == key, else return false.%20 * TODO:%20 * @param vs - Pointer to vector_string datastructure%20 * @param key - Pointer to string to search for%20 * @return * Find*%20 */%20bool vector_string_find(vector_string *vs, char *key) { %20  if (vs == NULL || vs->head == NULL) {%20    return false;%20  }%20%20%20  vs_entry_t* p = vs->head;%20%20  if (!strcmp(p->value, key) || !strcmp(vs->tail->value, key)) {%20    return true;%20  }%20%20  if (p->next != NULL) {%20    p = p->next;%20  } else {%20    return false;%20  }%20%20  while (p != vs->tail) {%20    if (strcmp(p->value, key)) {%20      p = p->next;%20%20    } else {%20      return true;%20%20    }%20%20  }%20  %20  return false; %20}%20%20/**%20 * @brief TODO: Insert the string pointed to by key into the vector string.%20 *  char* is externally allocated. You do not have to allocate internally%20 *%20 * @param vs - Pointer to vector_string datastructure%20 * @param key - Pointer to string to search for%20 * @return * Find*%20 */%20void vector_string_insert(vector_string *vs, char *key) {%20  // Insert the string into the tail of the list.%20  if (vs == NULL) {%20    return;%20  }%20%20  if (vs->head != NULL && vector_string_find(vs, key)) {%20    return;%20  }%20  %20  vs_entry_t* add = (vs_entry_t*) malloc(sizeof(vs_entry_t));%20  if (add == NULL) {%20    return;%20  }%20%20  add->next = NULL;%20  add->value = key;%20%20%20%20  if (vs->head == NULL && vs->tail == NULL) {%20    vs->head = add;%20    vs->tail = add;%20%20%20  } else {%20    vs->tail->next = add;%20    vs->tail = add;%20%20%20%20  }%20%20  %20}%20/**%20 * @brief Remove all entries and cleanup vector string%20 * TODO: Remove all entries. Remember head and tail are pointers.%20 * Remember to remove vs as well; not just entries. or you will have memory%20 * leaks.%20 * @param vs: Pointer to vector_string struct%20 */%20void vector_string_deallocate(vector_string *vs) {%20  if (vs == NULL || vs->head == NULL) {%20    return;%20  }%20%20  vs_entry_t* p = vs->head;%20  vs_entry_t* next = p;;%20%20  while (next != NULL) {%20    next = p->next;%20    free(p->value);%20    free(p);%20    p = next;%20  }%20  p = NULL;%20%20  free(vs);%20  vs = NULL;%20}%20%20/**%20 * @brief Print all value in each entry of the vector string, in the following%20 * format. In this case hello and world are the unique words in the file.%20 * 1. hello%20 * 2. world%20 * @param vs%20 */%20void vector_string_print(vector_string *vs) {%20  if (vs == NULL || vs->head == NULL) {%20    return;%20  }%20%20  int count = 1;%20  vs_entry_t *entry = vs->head;%20  %20%20  while (entry->next != NULL) {%20    printf("%d. %s\n", count, entry->value);%20%20    entry = entry->next;%20    count++;%20  %20  }%20}%20%20  int count = 0;%20  vector_string* vs = vector_string_allocate();%20  vector_char_t* word = vector_char_allocate();%20  char* word_ptr;%20  int i = 0;%20  while (source[i] != '\0') {%20%20    if ((source[i] >= 65 && source[i] <= 90) || (source[i] >= 97 && source[i] <= 122)) {%20      vector_char_add(word, source[i]);%20%20    } else if (word->len > 0) {%20      vector_char_add(word, '\0');%20%20      word_ptr = (char*) malloc(sizeof(char) * word->len);%20      memcpy(word_ptr, vector_char_get_array(word), word->len);%20%20%20      vector_string_insert(vs, word_ptr);%20%20      vector_char_delete(word);%20      word = vector_char_allocate();%20%20    }%20    i++;%20  }%20%20  vector_string_print(vs);%20%20  vector_string_deallocate(vs);%20  vector_char_delete(word);%20 | Rating: 5  | 1
2025-09-18 21:52:01.373 | Query: Explain how I can track down a segfault | 1
2025-09-19 10:01:38.648 | Query: Consider the 6-bit number 0b110000. What number is it sign-extended 11 bits. ? | 1
2025-09-19 10:02:56.541 | Query: what is 0b1111100000 in decimal | 1
2025-09-19 10:04:02.654 | Query: what number is 0b1111100000 sign extended 11 bits%20%20-16%20%2017%20%20-2029%20%202036 | 1
2025-09-19 10:05:29.366 | Query: Consider the 4-bit number 0b1011. What number is it sign-extended 9 bits. ?%20Group of answer choices%20%20-5%20%206%20%20-504%20%20511 | 1
2025-09-19 10:08:18.118 | Query: Which of the following 12 bit numbers has the same value as the 7 bit number 0b1000111. ?%20Group of answer choices%20%200b100001000111%20%200b100011101001%20%200b000001000110%20%200b111111000111 | 1
2025-09-19 10:11:29.490 | Query: How many bits are required to represent the number -3740? in 2’s complement and sign-magnitude? ?%20Group of answer choices%20%2014 (2’s complement), 12 (Sign-mag)%20%2012 (2’s complement), 14 (Sign-mag)%20%2015 (2’s complement), 13 (Sign-mag)%20%2013 (2’s complement), 13 (Sign-mag) | 1
2025-09-19 10:15:15.401 | Query: If x is the following number 0x98,%20y = x<<(3)>>(4). Assume logical shift. Write all 8 bits%20What is y in binary ? | 1
2025-09-19 10:24:52.171 | Query: If x = 0x1 and y = 0xd What is the value of%20z = (A & ~A) after this statement (where x is A and y is B)?%20Write in binary 4 bits | 1
2025-09-19 10:29:31.773 | Query: If x = 0x7 and y = 0xb What is the value of%20z = (B & ~B) after this statement (where x is A and y is B)?%20Write in binary 4 bits | 1
2025-09-19 10:32:16.368 | Query: How many bits are required to represent the number 871? in unsigned, 2s complement, and sign-magnitude? ?%20Group of answer choices%20%2010 (Unsigned), 12 (2’s complement), 10 (Sign-mag)%20%2010 (Unsigned), 11 (2’s complement), 11 (Sign-mag)%20%2011 (Unsigned), 10 (2’s complement), 12 (Sign-mag)%20%2012 (Unsigned), 10 (2’s complement), 13 (Sign-mag) | 1
2025-09-19 10:33:52.762 | Query: Which of the following 9 bit numbers has the same value as the 4 bit number 0b1011. ?%20Group of answer choices%20%200b100001011%20%200b000001010%20%200b111111011%20%200b101101101 | 1
2025-09-19 11:37:47.425 | Query: Invalid read of size 1%20==66377==    at 0x4852EE0: memmove (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)%20==66377==    by 0x109814: main (mapcount.c:109)%20%20main 109: memcpy(newWord, wordPointer, word->len + 1); | 1
2025-09-19 14:16:00.698 | Query: Walk me through assignment 2%20 | 1
2025-09-19 15:23:35.099 | Query: How does a "hash-based" table type data-structure work? | 1
2025-09-19 15:26:59.943 | Query: How should i allocate a table-based data structure on the heap | 1
2025-09-19 15:29:38.613 | Query: Why should we cast malloc to the type we are allocating for in C | 1
2025-09-19 15:30:48.806 | Query: Would this be a good way of allocating a table data structure:%20table_string *ts = (table_string*)malloc(buckets * sizeof(tab | 1
2025-09-19 16:54:14.199 | Query: Address 0x4a90410 is 16 bytes inside a block of size 32 free'd%20==5805==    at 0x488C868: realloc%20What causes this error%20 | 1
2025-09-19 16:55:49.433 | Query: Address 0x4a90410 is 16 bytes inside a block of size 32 free'd%20==5805==    at 0x488C868: realloc%20What causes this error%20Does realloc free any memory?%20 | 1
2025-09-19 20:47:52.180 | Query: Give me practice questions from week 1 and 2 | 1
2025-09-20 11:29:56.170 | Query: if you make an arraylist struct, why would you make a pointer to a pointer to allocated memory like void **buffer?%20 | 1
2025-09-20 11:36:28.684 | Query: what do you mean by "you can allocate more memory to buffer without needing to copy the existing elements to a different memory location"? don't I always need to copy all the existing things to a different place with more memory?%20 | 1
2025-09-20 11:43:39.914 | Query: Would this reallocate the array of pointers to a bigger memory location?%20a->buffer = (void**) realloc(a->buffer, a->buffer_size*2);%20(I'm unsure if the * are in the right places)%20 | 1
2025-09-20 11:45:28.734 | Query: If it turns out there's an adjacent memory block to which we can expand, do I understand correctly that realloc will return null and therefore it will make a->buffer also a null? that will be an error...%20a->buffer = (void**) realloc(a->buffer, a->buffer_size*2);%20%20 | 1
2025-09-20 11:53:31.227 | Query: How exactly does the free() function work? If I have a pointer array, would I need to call free() once to the pointer to the whole array or would I need to free() each pointer in the array and then the pointer to the whole array? | 1
2025-09-20 14:01:56.266 | Query: Debug:%20%20typedef struct table_string {%20  vs_entry_t **heads; // Array to maintain the heads of each bucket.%20  int buckets;        // Buckets can only be a power of 2.%20} table_string;%20%20typedef struct vs_entry {%20  char *value;%20  struct vs_entry *next;%20%20  int* pos; // This keeps track of each pos the word is found in%20  int  size_of_pos; // This keeps size of pos. Remember in C we track array size explicitly.%20%20} vs_entry_t;%20%20vs_entry_t* table_string_find(table_string* ts, unsigned int buckets, char* word) {%20  if (ts == NULL) {%20    return NULL;%20  }%20  vs_entry_t* p = ts->heads[buckets];%20%20  while (p != NULL) {%20    if (!my_str_cmp(word, p->value)) {%20      return p;%20    }%20    p = p->next;%20  }%20%20  return NULL;%20} | 1
2025-09-20 14:14:49.332 | Query: Debug why tablestring find:%20%20typedef struct table_string {%20  vs_entry_t **heads; // Array to maintain the heads of each bucket.%20  int buckets;        // Buckets can only be a power of 2.%20} table_string;%20%20typedef struct vs_entry {%20  char *value;%20  struct vs_entry *next;%20%20  int* pos; // This keeps track of each pos the word is found in%20  int  size_of_pos; // This keeps size of pos. Remember in C we track array size explicitly.%20%20} vs_entry_t;%20%20#include <ctype.h>%20#include <fcntl.h>%20#include <stdio.h>%20#include <stdlib.h>%20#include <string.h>%20#include <table_string.h>%20#include <vector_char.h>%20#include "str_cmp.h"%20%20// Function to read file content into a string%20char* read_file_content(char* filename) {%20  char *source = NULL;%20  FILE *fp = fopen(filename, "r");%20  if (fp == NULL) {%20    printf("Error reading file: %s\n", filename);%20    exit(1);%20  }%20  %20  if (fseek(fp, 0L, SEEK_END) == 0) {%20    long bufsize = ftell(fp);%20    if (bufsize == -1) {%20      printf("Error reading file: %s\n", filename);%20      exit(1);%20    }%20    source = malloc(sizeof(char) * (bufsize + 1));%20    if (fseek(fp, 0L, SEEK_SET) != 0) {%20      printf("Error reading file: %s\n", filename);%20      exit(1);%20    }%20    size_t newLen = fread(source, sizeof(char), bufsize, fp);%20    if (ferror(fp) != 0) {%20      printf("Error reading file: %s\n", filename);%20      exit(1);%20    } else {%20      source[newLen++] = '\0';%20    }%20  }%20  fclose(fp);%20  return source;%20}%20%20// Helper function%20vs_entry_t* table_string_find(table_string* ts, unsigned int buckets, char* word) {%20  if (ts == NULL || ts->buckets != buckets) {%20    return NULL;%20  }%20  vs_entry_t* p = ts->heads[buckets];%20%20  while (p != NULL) {%20    if (!my_str_cmp(word, p->value)) {%20      return p;%20    }%20    p = p->next;%20  }%20%20  return NULL;%20}%20%20int main(int argc, char **argv) {%20  if (argc != 3) {%20    printf("Usage: ./mapcount.bin [FIRST_FILE] [SECOND_FILE]\n");%20    exit(1);%20  }%20  %20  // Read both files%20  char *first_file_content = read_file_content(argv[1]);%20  char *second_file_content = read_file_content(argv[2]);%20%20%20  int buckets = 8;%20  /** Process first file and build table_string with word positions */%20  table_string* table1 = table_string_allocate(buckets);%20  vector_char_t* word = vector_char_allocate();%20%20%20  int w = 0;%20  int line = 0;%20%20  while (first_file_content[w] != '\0') {%20    if ((first_file_content[w] >= 65 && first_file_content[w] <= 90) || (first_file_content[w] >= 97 && first_file_content[w] <= 122)) {%20      vector_char_add(word, first_file_content[w]);%20%20    } else if (word->len > 0){%20%20      vector_char_add(word, '\0');%20%20      char* word_ptr = (char*) malloc(sizeof(char) * word->len);%20      memcpy(word_ptr, vector_char_get_array(word), word->len);%20%20      table_string_insert_or_add(table1, word_ptr, line);%20%20      vector_char_delete(word);%20      word = vector_char_allocate();%20      line++;%20%20%20    }%20    w++;%20  }%20%20%20  /** Process second file and search for consecutive word pairs */%20  int i = 0;%20%20  char* cur = NULL;%20  char* next = NULL;%20%20  vector_char_t *word2 = vector_char_allocate();%20%20  while (second_file_content[i + 1] != '\0') {%20%20    if ((second_file_content[i] >= 65 && second_file_content[i] <= 90) || (second_file_content[i] >= 97 && second_file_content[i] <= 122)) {%20      vector_char_add(word2, second_file_content[i]);%20    %20    } else if (word2->len > 0){%20      vector_char_add(word2, '\0');%20%20      char* word_ptr = vector_char_get_array(word2);%20  %20      printf("%s\n", word_ptr);%20%20      cur = next;%20      next = word_ptr;%20%20      if (cur != NULL) {%20        int bucket1 = djb2_word_to_bucket(cur,buckets);      %20      }%20      int bucket2 = djb2_word_to_bucket(next,buckets);%20%20%20%20      if (cur != NULL) {%20        vs_entry_t* q = table_string_find(table1, buckets, cur);%20        int* cur_pos = q->pos;%20        int cur_pos_size = q->size_of_pos;%20      %20%20%20        vs_entry_t* l = table_string_find(table1, buckets, next);%20        int* next_pos = l->pos;%20        int next_pos_size = l->size_of_pos;%20%20        if (q != NULL && l != NULL) {%20          for (int k = 0; k < line; k++) {%20            for (int a = 0; a < cur_pos_size; a++) {%20              for (int b = 0; b < next_pos_size; b++) {%20                if (b == a + 1) {%20                  printf("%s %s %d", cur, next, cur_pos[a]);%20                }%20              }%20            }%20          }%20        }%20      }%20%20      vector_char_delete(word2);%20      word2 = vector_char_allocate();%20    } %20    i++;%20  }%20  %20  vector_char_delete(word2);%20  vector_char_delete(word);%20  table_string_deallocate(table1);%20  free(first_file_content);%20  free(second_file_content);%20  return 0;%20} | 1
2025-09-20 14:27:19.954 | Query: Debug why cur and next are always the same:%20%20typedef struct table_string {%20  vs_entry_t **heads; // Array to maintain the heads of each bucket.%20  int buckets;        // Buckets can only be a power of 2.%20} table_string;%20%20typedef struct vs_entry {%20  char *value;%20  struct vs_entry *next;%20%20  int* pos; // This keeps track of each pos the word is found in%20  int  size_of_pos; // This keeps size of pos. Remember in C we track array size explicitly.%20%20} vs_entry_t;%20#include <ctype.h>%20#include <fcntl.h>%20#include <stdio.h>%20#include <stdlib.h>%20#include <string.h>%20#include <table_string.h>%20#include <vector_char.h>%20#include "str_cmp.h"%20%20// Function to read file content into a string%20char* read_file_content(char* filename) {%20  char *source = NULL;%20  FILE *fp = fopen(filename, "r");%20  if (fp == NULL) {%20    printf("Error reading file: %s\n", filename);%20    exit(1);%20  }%20  %20  if (fseek(fp, 0L, SEEK_END) == 0) {%20    long bufsize = ftell(fp);%20    if (bufsize == -1) {%20      printf("Error reading file: %s\n", filename);%20      exit(1);%20    }%20    source = malloc(sizeof(char) * (bufsize + 1));%20    if (fseek(fp, 0L, SEEK_SET) != 0) {%20      printf("Error reading file: %s\n", filename);%20      exit(1);%20    }%20    size_t newLen = fread(source, sizeof(char), bufsize, fp);%20    if (ferror(fp) != 0) {%20      printf("Error reading file: %s\n", filename);%20      exit(1);%20    } else {%20      source[newLen++] = '\0';%20    }%20  }%20  fclose(fp);%20  return source;%20}%20%20// Helper function%20vs_entry_t* table_string_find(table_string* ts, unsigned int maxBucket, char* word) {%20  if (ts == NULL || ts->buckets != maxBucket) {%20    return NULL;%20  }%20%20  int bucket = djb2_word_to_bucket(word, maxBucket);      %20%20  vs_entry_t* p = ts->heads[bucket];%20%20  while (p != NULL) {%20    if (!my_str_cmp(word, p->value)) {%20      return p;%20    }%20    p = p->next;%20  }%20%20  return NULL;%20}%20%20int main(int argc, char **argv) {%20  if (argc != 3) {%20    printf("Usage: ./mapcount.bin [FIRST_FILE] [SECOND_FILE]\n");%20    exit(1);%20  }%20  %20  // Read both files%20  char *first_file_content = read_file_content(argv[1]);%20  char *second_file_content = read_file_content(argv[2]);%20%20%20  int buckets = 8;%20  /** Process first file and build table_string with word positions */%20  table_string* table1 = table_string_allocate(buckets);%20  vector_char_t* word = vector_char_allocate();%20%20%20  int w = 0;%20  int line = 0;%20%20  while (first_file_content[w] != '\0') {%20    if ((first_file_content[w] >= 65 && first_file_content[w] <= 90) || (first_file_content[w] >= 97 && first_file_content[w] <= 122)) {%20      vector_char_add(word, first_file_content[w]);%20%20    } else if (word->len > 0){%20%20      vector_char_add(word, '\0');%20%20      char* word_ptr = (char*) malloc(sizeof(char) * word->len);%20      memcpy(word_ptr, vector_char_get_array(word), word->len);%20%20      table_string_insert_or_add(table1, word_ptr, line);%20%20      vector_char_delete(word);%20      word = vector_char_allocate();%20      line++;%20%20%20    }%20    w++;%20  }%20%20%20  /** Process second file and search for consecutive word pairs */%20  int i = 0;%20%20  char* cur = NULL;%20  char* next = NULL;%20%20  vector_char_t *word2 = vector_char_allocate();%20%20  while (second_file_content[i + 1] != '\0') {%20%20    if ((second_file_content[i] >= 65 && second_file_content[i] <= 90) || (second_file_content[i] >= 97 && second_file_content[i] <= 122)) {%20      vector_char_add(word2, second_file_content[i]);%20    %20    } else if (word2->len > 0){%20      vector_char_add(word2, '\0');%20%20      char* word_ptr = (char*) malloc(sizeof(char) * word2->len);%20      memcpy(word_ptr, vector_char_get_array(word2), word2->len);%20  %20      // printf("%s\n", word_ptr);%20%20      next = word_ptr;%20%20%20      if (cur != NULL) {%20%20      printf("Cur:%s \t Next:%s\n", cur,next);%20%20        vs_entry_t* q = table_string_find(table1, buckets, cur);%20        int* cur_pos = q->pos;%20        int cur_pos_size = q->size_of_pos;%20      %20%20%20        vs_entry_t* l = table_string_find(table1, buckets, next);%20        int* next_pos = l->pos;%20        int next_pos_size = l->size_of_pos;%20%20        if (q != NULL && l != NULL) {%20          for (int k = 0; k < line; k++) {%20            for (int a = 0; a < cur_pos_size; a++) {%20              for (int b = 0; b < next_pos_size; b++) {%20                if (b == a + 1) {%20                  // printf("%s %s %d\n", cur, next, cur_pos[a]);%20                }%20              }%20            }%20          }%20        }%20      }%20%20      vector_char_delete(word2);%20      word2 = vector_char_allocate();%20%20%20      cur = next;%20      free(word_ptr);%20    } %20    i++;%20  }%20  %20  vector_char_delete(word2);%20  vector_char_delete(word);%20  table_string_deallocate(table1);%20  free(first_file_content);%20  free(second_file_content);%20  return 0;%20} | 1
2025-09-20 14:37:45.485 | Query: Debug the first and last read pair does not print:%20%20typedef struct table_string {%20  vs_entry_t **heads; // Array to maintain the heads of each bucket.%20  int buckets;        // Buckets can only be a power of 2.%20} table_string;%20%20typedef struct vs_entry {%20  char *value;%20  struct vs_entry *next;%20%20  int* pos; // This keeps track of each pos the word is found in%20  int  size_of_pos; // This keeps size of pos. Remember in C we track array size explicitly.%20%20} vs_entry_t;%20#include <ctype.h>%20#include <fcntl.h>%20#include <stdio.h>%20#include <stdlib.h>%20#include <string.h>%20#include <table_string.h>%20#include <vector_char.h>%20#include "str_cmp.h"%20%20// Function to read file content into a string%20char* read_file_content(char* filename) {%20  char *source = NULL;%20  FILE *fp = fopen(filename, "r");%20  if (fp == NULL) {%20    printf("Error reading file: %s\n", filename);%20    exit(1);%20  }%20  %20  if (fseek(fp, 0L, SEEK_END) == 0) {%20    long bufsize = ftell(fp);%20    if (bufsize == -1) {%20      printf("Error reading file: %s\n", filename);%20      exit(1);%20    }%20    source = malloc(sizeof(char) * (bufsize + 1));%20    if (fseek(fp, 0L, SEEK_SET) != 0) {%20      printf("Error reading file: %s\n", filename);%20      exit(1);%20    }%20    size_t newLen = fread(source, sizeof(char), bufsize, fp);%20    if (ferror(fp) != 0) {%20      printf("Error reading file: %s\n", filename);%20      exit(1);%20    } else {%20      source[newLen++] = '\0';%20    }%20  }%20  fclose(fp);%20  return source;%20}%20%20// Helper function%20vs_entry_t* table_string_find(table_string* ts, unsigned int maxBucket, char* word) {%20  if (ts == NULL || ts->buckets != maxBucket) {%20    return NULL;%20  }%20%20  int bucket = djb2_word_to_bucket(word, maxBucket);      %20%20  vs_entry_t* p = ts->heads[bucket];%20%20  while (p != NULL) {%20    if (!my_str_cmp(word, p->value)) {%20      return p;%20    }%20    p = p->next;%20  }%20%20  return NULL;%20}%20%20int main(int argc, char **argv) {%20  if (argc != 3) {%20    printf("Usage: ./mapcount.bin [FIRST_FILE] [SECOND_FILE]\n");%20    exit(1);%20  }%20  %20  // Read both files%20  char *first_file_content = read_file_content(argv[1]);%20  char *second_file_content = read_file_content(argv[2]);%20%20%20  int buckets = 8;%20  /** Process first file and build table_string with word positions */%20  table_string* table1 = table_string_allocate(buckets);%20  vector_char_t* word = vector_char_allocate();%20%20%20  int w = 0;%20  int line = 0;%20%20  while (first_file_content[w] != '\0') {%20    if ((first_file_content[w] >= 65 && first_file_content[w] <= 90) || (first_file_content[w] >= 97 && first_file_content[w] <= 122)) {%20      vector_char_add(word, first_file_content[w]);%20%20    } else if (word->len > 0){%20%20      vector_char_add(word, '\0');%20%20      char* word_ptr = (char*) malloc(sizeof(char) * word->len);%20      memcpy(word_ptr, vector_char_get_array(word), word->len);%20%20      table_string_insert_or_add(table1, word_ptr, line);%20%20      vector_char_delete(word);%20      word = vector_char_allocate();%20      line++;%20%20%20    }%20    w++;%20  }%20%20%20  /** Process second file and search for consecutive word pairs */%20  int i = 0;%20%20  char* cur = NULL;%20  char* next = NULL;%20%20  vector_char_t *word2 = vector_char_allocate();%20%20  while (second_file_content[i] != '\0') {%20%20    if ((second_file_content[i] >= 65 && second_file_content[i] <= 90) || (second_file_content[i] >= 97 && second_file_content[i] <= 122)) {%20      vector_char_add(word2, second_file_content[i]);%20%20    } else if (word2->len > 0){%20      vector_char_add(word2, '\0');%20%20      char* word_ptr = (char*) malloc(sizeof(char) * word2->len);%20      memcpy(word_ptr, vector_char_get_array(word2), word2->len);%20%20      if (cur != NULL) {%20        free(cur);%20      }%20      cur = next;%20      next = word_ptr;%20%20%20      if (cur != NULL) {%20%20      // printf("Cur:%s \t Next:%s\n", cur,next);%20        vs_entry_t* q = table_string_find(table1, buckets, cur);%20        int* cur_pos = q->pos;%20        int cur_pos_size = q->size_of_pos;%20      %20%20%20        vs_entry_t* l = table_string_find(table1, buckets, next);%20        int* next_pos = l->pos;%20        int next_pos_size = l->size_of_pos;%20%20        if (q != NULL && l != NULL) {%20            for (int a = 0; a < cur_pos_size; a++) {%20              for (int b = 0; b < next_pos_size; b++) {%20                if (b == a + 1) {%20                  printf("%s %s %d\n", cur, next, cur_pos[a]);%20                }%20              }%20            }%20        }%20      }%20%20      vector_char_delete(word2);%20      word2 = vector_char_allocate();%20%20%20%20    } %20    i++;%20  }%20%20  free(cur);%20  free(next);%20  %20  vector_char_delete(word2);%20  vector_char_delete(word);%20  table_string_deallocate(table1);%20  free(first_file_content);%20  free(second_file_content);%20  return 0;%20} | 1
2025-09-20 21:43:07.021 | Query: Lets start off by talking about assignment 1 | 1
2025-09-21 00:48:58.112 | Query: Assignment 1 unit_test_str_cmp.c I'm confused on the task at hand | 1
2025-09-21 12:37:19.732 | Query: what do i need to know for first midterm pls help me i will die | 1
2025-09-21 12:37:47.886 | Query: no like what r the questions that will be asked on the first midterm | 1
2025-09-21 12:38:11.840 | Query: tytpe of questions on first midterm | 1
2025-09-21 12:38:50.409 | Query: Explain pointer arithmetic in C with examples | 1
2025-09-21 14:26:54.440 | Query: What does vector_char_allocate() allocate? space for string OR space for pointer to string? | 1
2025-09-21 15:43:17.748 | Query: try to think like the professor, make me a study guide of the most likely questions on the midterm 1 which is just week 1 and week 2. give me the most important definitions, step by step general ways to solve all the possible questions, a way to deduce all the types of questions and what they expect of us and how to solve or think of them when at exam, and anything else to ensure ill smash the exam. | 1
2025-09-22 00:09:28.963 | Query: try to think like the professor, make me a study guide of the most likely questions on the midterm 1 which is just week 1 and week 2. give me the most important definitions, step by step general ways to solve all the possible questions, a way to deduce all the types of questions and what they expect of us and how to solve or think of them when at exam, and anything else to ensure ill smash the exam. based on the fact that midterms are usually pretty much the same just diff numbrs give me a kind of go to way of thinking lke if i see this do this or think this yk break down the main types of problems or questions i can get%20 | 1
2025-09-22 10:59:31.526 | Query: In simple terms, please help me understand and summarize the tasks I need to complete:%20%20#include "table_string.h"%20#include "str_cmp.h"%20#include <stdbool.h>%20#include <stdint.h>%20#include <stdio.h>%20#include <stdlib.h>%20#include <string.h>%20%20#define BUCKETS%20// DO NOT ADD ANY NEW FUNCTIONS BEFORE djb2%20// Hash a character array to integer value between 0 and buckets-1.%20// See here for more details: https://theartincode.stanis.me/008-djb2/%20unsigned int djb2_word_to_bucket(char *word, int buckets) {%20  if (!word) {%20    printf("Invoked with null string");%20    exit(EXIT_FAILURE);%20  }%20  unsigned long hash = 5381;%20  uint32_t i;%20%20  for (i = 0; i < strlen(word); i++)%20    hash = ((hash << 5) + hash) + word[i];%20%20  return hash & (buckets - 1);%20}%20// ADD YOUR HELPER FUNCTIONS AFTER djb2%20/**%20 * @brief Instantiate a table string%20 *%20 * @param buckets%20 * @return table_string*%20 */%20table_string *table_string_allocate(unsigned int buckets) {%20  // Instantiate a bucket number of heads%20}%20%20/**%20 * @brief Insert the string pointed to by word into the table string.%20 *   If word is already found increment count.%20 *   If word is not found insert at the end of the corresponding bucket%20 * @param ts - Pointer to table_string datastructure%20 * @param word - Pointer to string to search for%20 * @return * Find*%20 */%20void table_string_insert_or_add(table_string *ts, char *word, int line) {%20  // Find the bucket for word. djb2 will return a value between 0-buckets-1.%20  // Rule: buckets can only be power of 2.%20  int bucket = djb2_word_to_bucket(word, ts->buckets);%20  // TODO:%20  // Case head == NULL: bucket hasn't been initialized yet%20  // Case word already in list, add to line array.%20  // Case word not found, insert word and return.%20}%20%20void table_string_deallocate(table_string *ts) {%20  // TODO:%20  // Free the linked list of each bucket%20  // Free the array of head pointers%20  // Free the structure itself%20  return;%20}%20%20void table_string_print(table_string *ts) {%20  /** TODO:%20   for each bucket%20    for each entry in bucket%20      print entry->word: line line line%20  */%20}%20 | 1
2025-09-22 11:10:44.169 | Query: How does my allocate function look?%20#include "table_string.h"%20#include "str_cmp.h"%20#include <stdbool.h>%20#include <stdint.h>%20#include <stdio.h>%20#include <stdlib.h>%20#include <string.h>%20%20#define BUCKETS%20// DO NOT ADD ANY NEW FUNCTIONS BEFORE djb2%20// Hash a character array to integer value between 0 and buckets-1.%20// See here for more details: https://theartincode.stanis.me/008-djb2/%20unsigned int djb2_word_to_bucket(char *word, int buckets) {%20  if (!word) {%20    printf("Invoked with null string");%20    exit(EXIT_FAILURE);%20  }%20  unsigned long hash = 5381;%20  uint32_t i;%20%20  for (i = 0; i < strlen(word); i++)%20    hash = ((hash << 5) + hash) + word[i];%20%20  return hash & (buckets - 1);%20}%20// ADD YOUR HELPER FUNCTIONS AFTER djb2%20/**%20 * @brief Instantiate a table string%20 *%20 * @param buckets%20 * @return table_string*%20 */%20table_string *table_string_allocate(unsigned int buckets) {%20  // Instantiate a bucket number of heads%20  table_string = new table_string();%20  table_string -> buckets = buckets;%20}%20%20/**%20 * @brief Insert the string pointed to by word into the table string.%20 *   If word is already found increment count.%20 *   If word is not found insert at the end of the corresponding bucket%20 * @param ts - Pointer to table_string datastructure%20 * @param word - Pointer to string to search for%20 * @return * Find*%20 */%20void table_string_insert_or_add(table_string *ts, char *word, int line) {%20  // Find the bucket for word. djb2 will return a value between 0-buckets-1.%20  // Rule: buckets can only be power of 2.%20  int bucket = djb2_word_to_bucket(word, ts->buckets);%20  // TODO:%20  // Case head == NULL: bucket hasn't been initialized yet%20  // Case word already in list, add to line array.%20  // Case word not found, insert word and return.%20}%20%20void table_string_deallocate(table_string *ts) {%20  // TODO:%20  // Free the linked list of each bucket%20  // Free the array of head pointers%20  // Free the structure itself%20  return;%20}%20%20void table_string_print(table_string *ts) {%20  /** TODO:%20   for each bucket%20    for each entry in bucket%20      print entry->word: line line line%20  */%20}%20%20%20#ifndef table_string_H%20#define table_string_H%20#define POS_COUNT%20%20#include "vector_string.h"%20#include <stdbool.h>%20%20// Struct describing the data structure table_string%20// head* points to the entry which is the start of vector string%20typedef struct table_string {%20  vs_entry_t **heads; // Array to maintain the heads of each bucket.%20  int buckets;        // Buckets can only be a power of 2.%20} table_string;%20%20/**%20 * @brief Memory allocate a vector string so that we can start inserting entries%20 * into it.%20 *%20 */%20table_string *table_string_allocate(unsigned int buckets);%20%20/**%20 * @brief function that returns a value between 1%20 */%20unsigned int djb2_word_to_bucket(char *key, int buckets);%20%20/**%20 * @brief If word does not exist, Insert the string pointed to by key into the%20 * table string If word exists, then simply increment the count in vs_entry_t%20 *%20 * @param vs - Pointer to table_string datastructure%20 * @param key - Pointer to string to search for%20 * @return * .%20 */%20void table_string_insert_or_add(table_string *vs, char *word, int line);%20/**%20 * @brief Remove all entries and cleanup vector string%20 * TODO: Remove all entries. Remember head and tail are pointers.%20 * Remember to remove vs as well; not just entries. or you will have memory%20 * leaks.%20 * @param vs: Pointer to table_string struct%20 */%20void table_string_deallocate(table_string *vs);%20%20/**%20 * @brief Print all value in each entry of the vector string, one line at a time%20 * [hello]%20 * [world]%20 * @param vs%20 */%20void table_string_print(table_string *vs);%20#endif%20 | 1
2025-09-22 11:59:18.608 | Query: How do I add a line to a bucket?%20#include "table_string.h"%20#include "str_cmp.h"%20#include <stdbool.h>%20#include <stdint.h>%20#include <stdio.h>%20#include <stdlib.h>%20#include <string.h>%20%20#define BUCKETS%20// DO NOT ADD ANY NEW FUNCTIONS BEFORE djb2%20// Hash a character array to integer value between 0 and buckets-1.%20// See here for more details: https://theartincode.stanis.me/008-djb2/%20unsigned int djb2_word_to_bucket(char *word, int buckets) {%20  if (!word) {%20    printf("Invoked with null string");%20    exit(EXIT_FAILURE);%20  }%20  unsigned long hash = 5381;%20  uint32_t i;%20%20  for (i = 0; i < strlen(word); i++)%20    hash = ((hash << 5) + hash) + word[i];%20%20  return hash & (buckets - 1);%20}%20// ADD YOUR HELPER FUNCTIONS AFTER djb2%20/**%20 * @brief Instantiate a table string%20 *%20 * @param buckets%20 * @return table_string*%20 */%20table_string *table_string_allocate(unsigned int buckets) {%20  // Instantiate a bucket number of heads%20  table_string = new table_string();%20  table_string -> buckets = buckets;%20}%20%20/**%20 * @brief Insert the string pointed to by word into the table string.%20 *   If word is already found increment count.%20 *   If word is not found insert at the end of the corresponding bucket%20 * @param ts - Pointer to table_string datastructure%20 * @param word - Pointer to string to search for%20 * @return * Find*%20 */%20void table_string_insert_or_add(table_string *ts, char *word, int line) {%20  // Find the bucket for word. djb2 will return a value between 0-buckets-1.%20  // Rule: buckets can only be power of 2.%20  int bucket = djb2_word_to_bucket(word, ts->buckets);%20  // TODO:%20  // Case head == NULL: bucket hasn't been initialized yet%20  // Case word already in list, add to line array.%20  // Case word not found, insert word and return.%20}%20%20void table_string_deallocate(table_string *ts) {%20  // TODO:%20  // Free the linked list of each bucket%20  // Free the array of head pointers%20  // Free the structure itself%20  return;%20}%20%20void table_string_print(table_string *ts) {%20  /** TODO:%20   for each bucket%20    for each entry in bucket%20      print entry->word: line line line%20  */%20}%20%20%20#ifndef table_string_H%20#define table_string_H%20#define POS_COUNT%20%20#include "vector_string.h"%20#include <stdbool.h>%20%20// Struct describing the data structure table_string%20// head* points to the entry which is the start of vector string%20typedef struct table_string {%20  vs_entry_t **heads; // Array to maintain the heads of each bucket.%20  int buckets;        // Buckets can only be a power of 2.%20} table_string;%20%20/**%20 * @brief Memory allocate a vector string so that we can start inserting entries%20 * into it.%20 *%20 */%20table_string *table_string_allocate(unsigned int buckets);%20%20/**%20 * @brief function that returns a value between 1%20 */%20unsigned int djb2_word_to_bucket(char *key, int buckets);%20%20/**%20 * @brief If word does not exist, Insert the string pointed to by key into the%20 * table string If word exists, then simply increment the count in vs_entry_t%20 *%20 * @param vs - Pointer to table_string datastructure%20 * @param key - Pointer to string to search for%20 * @return * .%20 */%20void table_string_insert_or_add(table_string *vs, char *word, int line);%20/**%20 * @brief Remove all entries and cleanup vector string%20 * TODO: Remove all entries. Remember head and tail are pointers.%20 * Remember to remove vs as well; not just entries. or you will have memory%20 * leaks.%20 * @param vs: Pointer to table_string struct%20 */%20void table_string_deallocate(table_string *vs);%20%20/**%20 * @brief Print all value in each entry of the vector string, one line at a time%20 * [hello]%20 * [world]%20 * @param vs%20 */%20void table_string_print(table_string *vs);%20#endif%20 | 1
2025-09-22 12:10:33.902 | Query: How do I add a line to a bucket?%20#include "table_string.h"%20#include "str_cmp.h"%20#include <stdbool.h>%20#include <stdint.h>%20#include <stdio.h>%20#include <stdlib.h>%20#include <string.h>%20%20#define BUCKETS%20// DO NOT ADD ANY NEW FUNCTIONS BEFORE djb2%20// Hash a character array to integer value between 0 and buckets-1.%20// See here for more details: https://theartincode.stanis.me/008-djb2/%20unsigned int djb2_word_to_bucket(char *word, int buckets) {%20  if (!word) {%20    printf("Invoked with null string");%20    exit(EXIT_FAILURE);%20  }%20  unsigned long hash = 5381;%20  uint32_t i;%20%20  for (i = 0; i < strlen(word); i++)%20    hash = ((hash << 5) + hash) + word[i];%20%20  return hash & (buckets - 1);%20}%20// ADD YOUR HELPER FUNCTIONS AFTER djb2%20/**%20 * @brief Instantiate a table string%20 *%20 * @param buckets%20 * @return table_string*%20 */%20table_string *table_string_allocate(unsigned int buckets) {%20  // Instantiate a bucket number of heads%20  table_string = new table_string();%20  table_string -> buckets = buckets;%20}%20%20/**%20 * @brief Insert the string pointed to by word into the table string.%20 *   If word is already found increment count.%20 *   If word is not found insert at the end of the corresponding bucket%20 * @param ts - Pointer to table_string datastructure%20 * @param word - Pointer to string to search for%20 * @return * Find*%20 */%20void table_string_insert_or_add(table_string *ts, char *word, int line) {%20  // Find the bucket for word. djb2 will return a value between 0-buckets-1.%20  // Rule: buckets can only be power of 2.%20  int bucket = djb2_word_to_bucket(word, ts->buckets);%20  // TODO:%20  // Case head == NULL: bucket hasn't been initialized yet%20  // Case word already in list, add to line array.%20  // Case word not found, insert word and return.%20}%20%20void table_string_deallocate(table_string *ts) {%20  // TODO:%20  // Free the linked list of each bucket%20  // Free the array of head pointers%20  // Free the structure itself%20  return;%20}%20%20void table_string_print(table_string *ts) {%20  /** TODO:%20   for each bucket%20    for each entry in bucket%20      print entry->word: line line line%20  */%20}%20%20%20#ifndef table_string_H%20#define table_string_H%20#define POS_COUNT%20%20#include "vector_string.h"%20#include <stdbool.h>%20%20// Struct describing the data structure table_string%20// head* points to the entry which is the start of vector string%20typedef struct table_string {%20  vs_entry_t **heads; // Array to maintain the heads of each bucket.%20  int buckets;        // Buckets can only be a power of 2.%20} table_string;%20%20/**%20 * @brief Memory allocate a vector string so that we can start inserting entries%20 * into it.%20 *%20 */%20table_string *table_string_allocate(unsigned int buckets);%20%20/**%20 * @brief function that returns a value between 1%20 */%20unsigned int djb2_word_to_bucket(char *key, int buckets);%20%20/**%20 * @brief If word does not exist, Insert the string pointed to by key into the%20 * table string If word exists, then simply increment the count in vs_entry_t%20 *%20 * @param vs - Pointer to table_string datastructure%20 * @param key - Pointer to string to search for%20 * @return * .%20 */%20void table_string_insert_or_add(table_string *vs, char *word, int line);%20/**%20 * @brief Remove all entries and cleanup vector string%20 * TODO: Remove all entries. Remember head and tail are pointers.%20 * Remember to remove vs as well; not just entries. or you will have memory%20 * leaks.%20 * @param vs: Pointer to table_string struct%20 */%20void table_string_deallocate(table_string *vs);%20%20/**%20 * @brief Print all value in each entry of the vector string, one line at a time%20 * [hello]%20 * [world]%20 * @param vs%20 */%20void table_string_print(table_string *vs);%20#endif%20%20typedef struct vs_entry {%20  char *value;%20  struct vs_entry *next;%20%20// Conditionally compiled in code. Not relevant for part 2. You can assume the%20// int count declaration does not exist and is irrelevant for part 2.%20#ifdef POS_COUNT%20  int* pos; // This keeps track of each pos the word is found in%20  int  size_of_pos; // This keeps size of pos. Remember in C we track array size explicitly.%20#endif%20} vs_entry_t;%20%20// Struct describing the data structure vector_string%20// head* points to the entry which is the start of vector string%20typedef struct vector_string {%20  vs_entry_t *head;%20  vs_entry_t *tail;%20} vector_string;%20%20/**%20 * @brief Memory allocate a vector string so that we can start inserting entries%20 * into it.%20 *%20 */%20vector_string *vector_string_allocate();%20%20/**%20 * @brief Search the vector string pointed to by vs and return the entry if the%20 * vs_entry.value == key.%20 * TODO:%20 * @param vs - Pointer to vector_string datastructure%20 * @param key - Pointer to string to search for%20 * @return * Find*%20 */%20bool vector_string_find(vector_string *vs, char *key);%20%20/**%20 * @brief Insert the string pointed to by key into the vector string.%20 *  TODO: char* is externally allocated. You do not have to allocate internally%20 * @param vs - Pointer to vector_string datastructure%20 * @param key - Pointer to string to search for%20 * @return * Find*%20 */%20void vector_string_insert(vector_string *vs, char *key);%20/ | 1
2025-09-22 12:28:29.418 | Topic: How do pointers work | 1
2025-09-22 12:28:30.663 | Topic: How do pointers work | 1
2025-09-22 12:28:32.008 | Topic: How do pointers work | 1
2025-09-22 12:28:49.394 | Query: What is assignment 1? | 1
2025-09-22 12:29:55.435 | Query: How would I write a C function that bit shifts arg x by 6 bits | 1
2025-09-22 13:25:47.540 | Query: where in the course dud we cver how to know what is the umer f nits needed to reepresemt a 3 digit nase 6 number | 1
2025-09-22 13:26:13.574 | Query: where in the course did we cover how to know what is the numebr of bits needed to represent a 3 digit base 6 number | 1
2025-09-22 13:26:16.591 | Topic: where in the course did we cover how to know what is the numebr of bits needed to represent a 3 digit base 6 number | 1
2025-09-22 13:26:17.732 | Topic: where in the course did we cover how to know what is the numebr of bits needed to represent a 3 digit base 6 number | 1
2025-09-22 13:26:18.312 | Topic: where in the course did we cover how to know what is the numebr of bits needed to represent a 3 digit base 6 number | 1
2025-09-22 13:26:29.702 | Topic: where in the course did we cover how to know what is the numebr of bits needed to represent a 3 digit base 6 number | 1
2025-09-22 13:26:35.348 | Query: where in the course did we cover how to know what is the numebr of bits needed to represent a 3 digit base 6 number | 1
2025-09-22 14:15:30.158 | Query: remind me again we got nested arrays and then the array of pointers right %20the nested arrays basically are a contiguous block of memory, thus any nested array can be represented as one big array but what about an array of pointers, not the same at all we store memory address of sub arrays%20not at all need to be contugous right %20am i getting it? what else should i know to be able to answer any a+ level question on this topic and the surroudning topics%20 | 1
2025-09-22 16:49:37.590 | Query: 28. What base 6 number XXX represents 0? (That is, your answer needs to have 3%20base-6 characters.)? [1]%20Hint%202556%20A 8-bit bias-encoded number presented in class has a bias of -127 so that roughly half the numbers are%20negative. but there’s one more positive than negative number i.e., [-127 to +128]. Using an equivalent%20scheme for choosing the bias,%20There is one more positive number%20Hence answer is 2556%20%20which set of lecture slides cover this%20 | 1
2025-09-22 16:50:37.355 | Query: what lectures cover bias encoding%20%20 | 1
2025-09-22 20:01:49.291 | Query: hi what is the layout of stack heap and static%20 | 1
2025-09-22 20:03:31.495 |  Query: can you give an example for stack heap static and code | Rating: 4  | 1
2025-09-22 20:03:39.850 | Query: can you give an example for stack heap static and code | 1
2025-09-22 20:05:18.144 | Query: how does shifting work | 1
2025-09-22 20:08:36.283 | Query: how does offsets in arrays work | 1
2025-09-22 20:32:17.820 | Query: how many bytes does each type need in a 32 and 64 bit system | 1
2025-09-22 20:33:01.736 | Query: how many bits does each type need in a 32 and 64 bit system | 1
2025-09-22 20:37:55.213 | Query: what is word size | 1
2025-09-22 20:45:02.194 | Query: what is the difference between multi level and nested arrays%20 | 1
2025-09-22 20:46:01.100 | Query: how does padding work | 1
2025-09-22 20:46:40.887 | Query: is there padding after? | 1
2025-09-22 20:47:18.224 | Query: how does padding after a struct work | 1
2025-09-22 20:47:55.849 | Query: who picks kmax | 1
2025-09-22 20:48:08.024 | Query: what is kmax | 1
2025-09-22 20:49:25.395 | Query: how do bit masks work%20 | 1
2025-09-22 20:56:27.883 | Query: what is the formula for accessing nested arrays%20 | 1
2025-09-22 20:57:33.988 | Query: what is the formula for accessing 3d nested arrays%20 | 1
2025-09-22 21:01:18.275 | Topic: what is the formula for accessing 3d nested arrays | 1
2025-09-22 21:01:18.893 | Topic: what is the formula for accessing 3d nested arrays | 1
2025-09-22 21:05:55.627 | Query: what are all the casting surprises%20 | 1
2025-09-22 23:38:40.221 | Query: If x = 0xb and y = 0x5 What is the value of%20z = (A | A) after this statement?%20Write in binary 4 bits | 1
2025-09-23 00:46:25.062 | Query: teach me this asap in bullet points simply%20Revising bitwise operators (!, ~, &, ^, |, <<, >>).%20 | 1
2025-09-23 15:13:57.926 | Topic: What is the number of bits needed to represent a 3 digit base-6 number ? Lets use MSB (most-significant digit) for sign (1- postiive 0-ve) How many numbers can be represented ? | 1
2025-09-23 15:14:14.316 | Query: What is the number of bits needed to represent a 3 digit base-6 number ? Lets use MSB (most-significant digit) for sign (1- postiive 0-ve) How many numbers can be represented ?   | 1
2025-09-23 15:14:50.755 | Topic: What is the number of bits needed to represent a 3 digit base-6 number ? Lets use MSB (most-significant digit) for sign (1- postiive 0-ve) How many numbers can be represented ? | 1
2025-10-06 18:07:43.445 | Query: what are the difference opcodes | 1
2025-10-06 18:08:01.933 | Query: what are the opcodes for each type of instruction | 1
2025-10-06 18:08:40.706 | Query: what type of instruction is load byte | 1
2025-10-06 18:09:07.608 | Query: is load byte an I instruction | 1
2025-10-06 18:09:38.907 | Query: if load byte is an I instruction, why is the opcode different than the I instruction type opcode | 1
2025-10-06 18:10:19.749 | Query: For assignment 2, do I need to include the secondary opcode for load byte instructions? | 1
2025-10-06 21:35:39.902 | Query: what is jump offset | 1
2025-10-06 21:36:05.526 | Query: how to calculate jump offset | 1
2025-10-06 21:39:47.770 | Query: how to calculate store offset | 1
2025-10-06 21:59:39.356 | Query: how to calculate branch offset | 1
2025-10-06 22:00:01.023 | Query: how to calculate branch offset if you have the immediate value%20 | 1
2025-10-07 12:27:58.966 | Query: Does a union in C allocate memory for all the stored structs or only the one that gets used?%20 | 1
2025-10-07 13:08:24.820 | Query: why is this the instruction to obtain the rd%20instruction.rtype.rd = instruction_bits & ((1U << 5) - 1);%20when instruction_bits is on bit 7? wouldn't this only get 4 bits when rd is 5 bits? | 1
2025-10-07 13:13:29.785 | Query: Can you explain how to get the answer?%20For the branch instruction with encoding 0x8e460863 what is the offset. Hint:13 bits (hex or decimal) ? ? | 1
2025-10-07 13:18:18.828 | Query: // case for I-type%20  case 0x13:%20  case 0x03:%20    instruction.itype.rd = instruction_bits & ((1U << 5) - 1);%20    instruction_bits >>= 5;%20%20    instruction.itype.funct3 = instruction_bits & ((1U << 3) - 1);%20    instruction_bits >>= 3;%20    %20    instruction.itype.rs1 = instruction_bits & ((1U << 5) - 1);%20    instruction_bits >>= 5;%20%20    instruction.itype.imm = instruction_bits & ((1U << 12) - 1);%20    break;%20Is this correct? | 1
2025-10-07 13:20:16.557 | Query: instruction.itype.imm = (original_instruction_bits >> 20) & ((1U << 12) - 1); // store original instruction_bits%20How does this get the immediate value from an I-type instruction? | 1
2025-10-07 13:21:14.090 | Query: instruction.itype.imm = (original_instruction_bits >> 20) & ((1U << 12) - 1); // store original instruction_bits%20How does this get the immediate value from an I-type instruction? Why is this better than instruction.itype.imm = instruction_bits & ((1U << 12) - 1); after shifting to bit 20 after retrieving the other fields? | 1
2025-10-07 13:22:43.681 | Query: instruction.itype.imm = (original_instruction_bits >> 20) & ((1U << 12) - 1); // store original instruction_bits%20How does this get the immediate value from an I-type instruction? Why is this better than instruction.itype.imm = instruction_bits & ((1U << 12) - 1);%20in this code?%20%20// case for I-type%20  case 0x13:%20  case 0x03:%20    instruction.itype.rd = instruction_bits & ((1U << 5) - 1);%20    instruction_bits >>= 5;%20%20    instruction.itype.funct3 = instruction_bits & ((1U << 3) - 1);%20    instruction_bits >>= 3;%20    %20    instruction.itype.rs1 = instruction_bits & ((1U << 5) - 1);%20    instruction_bits >>= 5;%20%20    instruction.itype.imm = instruction_bits & ((1U << 12) - 1);%20    break; | 1
2025-10-07 22:18:17.176 | Query: what would this assembly look like in c, assume a0 = n, a1 = int *array. %20%20li s7, 0%20li s3, 0x7fffffff%20loop:%20slli s2, s7, 2%20add s2, a1, s2%20lw_slt s5, s3, (s2)%20addi s7, s7, 2%20blt s7,a0, loop%20end:%20mv a0, s5                               %20%20 | 1
2025-10-07 22:20:48.070 | Query: what would this assembly look like in c, assume a0 = n, a1 = int *array. assume lw_slt logic is if(rs1 < MEM[rs2]) then rd = rs1, else rd = MEM[rs2].%20%20li s7, 0%20li s3, 0x7fffffff%20loop:%20slli s2, s7, 2%20add s2, a1, s2%20lw_slt s5, s3, (s2)%20addi s7, s7, 2%20blt s7,a0, loop%20end:%20mv a0, s5                               %20%20 | 1
2025-10-07 22:24:27.800 | Query: what would this assembly look like in c, assume a0 = n, a1 = int *array. assume lw_slt logic is if(rs1 < MEM[rs2]) then rd = rs1, else rd = MEM[rs2].%20%20li s7, 0%20li s3, 0x7fffffff%20loop:%20slli s2, s7, 2%20add s2, a1, s2%20lw_slt s5, s3, (s2)%20addi s7, s7, 2%20blt s7,a0, loop%20end:%20mv a0, s5                               %20%20 | 1
2025-10-07 22:24:53.929 | Query: what would this assembly look like in c, assume a0 = n, a1 = int *array. assume lw_slt logic is if(rs1 < MEM[rs2]) then rd = rs1 else rd = MEM[rs2].%20%20li s7, 0%20li s3, 0x7fffffff%20loop:%20slli s2, s7, 2%20add s2, a1, s2%20lw_slt s5, s3, (s2)%20addi s7, s7, 2%20blt s7,a0, loop%20end:%20mv a0, s5                               %20%20 | 1
2025-10-07 22:26:31.922 | Query: what would this assembly look like in c, assume a0 = n, a1 = int *array. assume lw_slt logic is if(rs1 < MEM[rs2]) then rd = rs1 else rd = MEM[rs2].%20%20li s7, 0%20li s3, 0x7fffffff%20loop:%20slli s2, s7, 2%20add s2, a1, s2%20lw_slt s5, s3, (s2)%20addi s7, s7, 2%20blt s7,a0, loop%20end:%20mv a0, s5     %20%20%20also does this code translate it, %20%20unsigned int s7 = 0;%20   unsigned int s3 = 0x7fffffff;%20   int *s2;%20   unsigned int s5;%20%20   do {%20      // pointer arithmatic multiplies s7 by 4 already.%20      s2 = array + s7;%20      %20      if(s3 < (unsigned int)*s2)%20         s5 = s3;%20      else%20         s5 = *s2;%20%20%20      s7 = s7 + 2;%20%20   } while(s7 < (unsigned int)n);%20   %20   n = s5;%20   return n;                          %20%20 | 1
2025-10-07 22:28:43.591 | Query: what would this assembly look like in c, assume a0 = n, a1 = int *array. assume lw_slt logic is if(rs1 < MEM[rs2]) then rd = rs1 else rd = MEM[rs2].%20%20li s7, 0%20li s3, 0x7fffffff%20loop:%20slli s2, s7, 2%20add s2, a1, s2%20lw_slt s5, s3, (s2)%20addi s7, s7, 2%20blt s7,a0, loop%20end:%20mv a0, s5     %20%20%20also what is wrong with how this code is translating it, %20%20unsigned int s7 = 0;%20   unsigned int s3 = 0x7fffffff;%20   int *s2;%20   unsigned int s5;%20%20   do {%20      // pointer arithmatic multiplies s7 by 4 already.%20      s2 = array + s7;%20      %20      if(s3 < (unsigned int)*s2)%20         s5 = s3;%20      else%20         s5 = *s2;%20%20%20      s7 = s7 + 2;%20%20   } while(s7 < (unsigned int)n);%20   %20   n = s5;%20   return n;                          %20%20 | 1
2025-10-07 23:03:40.488 | Query: instruction.rtype.rs1 = instruction_bits & ((1U << 5) - 1);%20Explain "1U" in this code%20 | 1
2025-10-08 00:42:31.473 | Query: Assignment 2, Part 2:%20Word load(Byte *memory, Address address, Alignment alignment) {%20%20    // CHANGE THIS%20    Word word = 0;%20%20    if (alignment == LENGTH_WORD) {%20        word |= memory[address];%20        word |= (memory[address + 1] << 8);%20        word |= (memory[address + 2] << 16);%20        word |= (memory[address + 3] << 24);%20    }%20    %20    return word;%20}%20%20This function is only loading the first instruction multiple times. Why is that?  | 1
2025-10-08 00:49:07.595 | Query: return (int)field << (32-n) >> (32-n);%20Explain%20 | 1
2025-10-08 00:54:44.619 | Query: Explain how to calculate branch and jump offsets in riscv | 1
2025-10-08 01:06:30.781 | Query: Explain how to calculate branch and jump offsets in riscv%20For either (or both) if I had the value of PC somewhere, and the position of the instruction where either would jump to, could i do:%20offset = jumpinstructionposition - PC?%20 | 1
2025-10-08 01:16:14.979 | Query: Does information about a given instruction (i.e. opcode, etc) have any information regarding its position? (i.e. jump, branch offset calcs) | 1
2025-10-08 01:17:56.157 | Query: Explain what the fields of a b-type and a j-type instruction indicate%20 | 1
2025-10-08 01:18:34.395 | Query: Explain what the fields of a b-type and a j-type instruction indicate%20If i were extracting the offset for use in C code, would i need to sign extend it?%20%20 | 1
2025-10-08 01:22:03.153 | Query: Explain how I can extract the offset of a B-type in C code%20%20%20 | 1
2025-10-08 01:23:45.677 | Query: Word load(Byte *memory, Address address, Alignment alignment) {%20    /* YOUR CODE HERE */%20%20    Word load = 0;%20%20    if (alignment == LENGTH_WORD) {%20        for (int i = 0; i < 4; i++) {%20            load |= (memory[address + i] << (8 * i));%20        }%20    }%20%20    return load;%20}%20%20Does this function work as intended? | 1
2025-10-08 09:29:22.603 | Query: R-type | 1
2025-10-08 13:40:44.494 | Query: does this code fit the assembly I'm gonna give after.%20%20int blackbox(int n, int *array) {%20   /* Fill here */   %20   int s7 = 0;%20   int s3 = 0x7fffffff;%20   //int s2;%20   int s5;%20%20   while (s7 < n) {%20      // pointer arithmatic multiplies s7 by 4 already.%20      %20      if(s3 < array[s7])%20         s5 = s3;%20      else%20         s5 = array[s7];%20%20%20      s7 = s7 + 4;%20%20   }%20   %20   n = s5;%20   return n;%20}%20%20%20the assembly:%20%20li s7, 0%20li s3, 0x7fffffff%20loop:%20slli s2, s7, 2%20add s2, a1, s2%20lw_slt s5, s3, (s2)%20addi s7, s7, 2%20blt s7,a0, loop%20end:%20mv a0, s5         | 1
2025-10-08 13:42:25.455 | Query: does this code fit the assembly I'm gonna give after, I need the code to be equivalent to the assembly.%20%20int blackbox(int n, int *array) {%20   /* Fill here */   %20   int s7 = 0;%20   int s3 = 0x7fffffff;%20   //int s2;%20   int s5;%20%20   while (s7 < n) {%20      // pointer arithmatic multiplies s7 by 4 already.%20      %20      if(s3 < array[s7])%20         s5 = s3;%20      else%20         s5 = array[s7];%20%20%20      s7 = s7 + 4;%20%20   }%20   %20   n = s5;%20   return n;%20}%20%20%20the assembly:%20%20li s7, 0%20li s3, 0x7fffffff%20loop:%20slli s2, s7, 2%20add s2, a1, s2%20lw_slt s5, s3, (s2)%20addi s7, s7, 2%20blt s7,a0, loop%20end:%20mv a0, s5         | 1
2025-10-08 13:49:58.099 | Query: write code that is equivalent to the assembly below, assume that lw_slt has this logic: **lw_slt rd, rs1, (rs2).** %20- **if** (rs1 < MEM[rs2]) **then** rd=rs1, **else** rd = MEM[rs2].%20%20%20the assembly:%20%20li s7, 0%20li s3, 0x7fffffff%20loop:%20slli s2, s7, 2%20add s2, a1, s2%20lw_slt s5, s3, (s2)%20addi s7, s7, 2%20blt s7,a0, loop%20end:%20mv a0, s5         | 1
2025-10-08 21:02:14.900 | Query: For Lab 5, when and how do I update my program counter for a RISCV emulator? | 1
2025-10-08 23:38:48.429 | Query: Explain how I can extract the offset of a B-type in C code, given I have a function that will sign extend for me.%20%20%20 | 1
2025-10-08 23:41:22.532 | Query: Explain how I can extract the offset of a B-type in C code, given I have a function that will sign extend for me.%20%20Explain |=%20%20%20%20 | 1
2025-10-08 23:49:36.871 | Query: offset |= ((instruction.sbtype.imm5 >> 4) & 1) << 12; %20Review this line of code | 1
2025-10-08 23:53:07.636 | Query: //Extract the 5th byte of imm7 (12th bit of offset)%20  offset |= ((instruction.sbtype.imm7 >> 6) & 1) << 12;%20  //Extract the 0th bit of imm5 (11th bit of offset)%20  offset |= (instruction.sbtype.imm5 & 1) << 11;%20  //Extract the 4th bit of imm7 (10th bit of offset)%20  offset |= ((instruction.sbtype.imm7 >> 5) & 1) << 10;%20Review this code | 1
2025-10-09 00:23:27.512 | Query:   //Extract bit 6 of imm7 (12th bit of offset)%20  offset |= ((instruction.sbtype.imm7 >> 6) & 1) << 12;%20  //Extract bit 0 of imm5 (11th bit of offset)%20  offset |= (instruction.sbtype.imm5 & 1) << 11;%20  //Extract bit 5 of imm7 (10th bit of offset)%20  offset |= ((instruction.sbtype.imm7 >> 5) & 1) << 10;%20  //Extract bit 4 of imm7 (9th bit of offset)%20  offset |= ((instruction.sbtype.imm7 >> 4) & 1) << 9;%20  //Extract bit 3 of imm7 (8th bit of offset)%20  offset |= ((instruction.sbtype.imm7 >> 3) & 1) << 8;%20  //Extract bit 2 of imm7 (7th bit of offset)%20  offset |= ((instruction.sbtype.imm7 >> 2) & 1) << 7;%20  //Extract bit 1 of imm7 (6th bit of offset)%20  offset |= ((instruction.sbtype.imm7 >> 1) & 1) << 6;%20  //Extract bit 0 of imm7 (5th bit of offset)%20  offset |= (instruction.sbtype.imm7 & 1) << 5;%20  //Extract bit 5 of imm5 (4th bit of offset)%20  offset |= ((instruction.sbtype.imm7 >> 5) & 1) << 4;%20  //Extract bit 4 of imm5 (3rd bit of offset)%20  offset |= ((instruction.sbtype.imm7 >> 4) & 1) << 3;%20  //Extract bit 3 of imm5 (2nd bit of offset)%20  offset |= ((instruction.sbtype.imm7 >> 3) & 1) << 2;%20  //Extract bit 2 of imm5 (1st bit of offset)%20  offset |= ((instruction.sbtype.imm7 >> 32) & 1) << 1; | 1
2025-10-09 01:09:31.744 | Query: How many times should I bit shift the immediate of j-type to extract the 20th bit%20 | 1
2025-10-09 01:10:17.601 | Query: If i have a j-type instruction and have just its immediate value, how many times should i bit shift to extract its MSB | 1
2025-10-09 14:48:29.021 | Query: why does sizeof(Instruction)==4 | 1
2025-10-09 16:51:16.814 | Query: Does jalr count for this?%20get_*_offset(instruction) (utils.c): For the corresponding instruction type (either branch, jump, or store), this function unpacks the immediate value and returns the number of bytes to offset by. In this case of branches and jumps, these functions should return the number of bytes to add to the PC to get to the desired label. In the case of stores, the corresponding function will return the offset on the destination address. | 1
2025-10-09 16:57:34.818 | Query: instruction.sbtype.imm5 & (1U);%20does this code give the first bit from the right? | 1
2025-10-09 17:26:40.102 | Query: the immediate gives exactly how many bytes to offset by right? | 1
2025-10-09 17:27:42.168 | Query: the immediate gives exactly how many bytes to offset by right (when not a branch instruction)? | 1
2025-10-09 17:31:49.661 | Query: imm7 & (1U << 6);%20This grabs the first bit if imm7 is 7 bits long right? | 1
2025-10-09 17:35:05.626 | Query: (n12 << 11) + (n11 << 10) + (imm7 << 4) + imm5;%20does this give a 12 bit string? (assuming imm7 is 6 bits and imm 5 is 4) | 1
2025-10-09 17:36:17.797 | Query: case 0x63:%20      Byte imm5 = instruction.sbtype.imm5;%20      Byte imm4;%20      Byte n11 = imm5 & (1U);%20      imm5 >>= 1;%20      Byte imm7 = instruction.sbtype.imm7;%20      Byte n12 = imm7 & (1U << 6);%20      imm7 <<= 1;%20      imm7 >>= 1;%20      return (n12 << 11) + (n11 << 10) + (imm7 << 4) + imm5;%20does this give the offset in a branch instruction? | 1
2025-10-09 17:36:45.484 | Query: case 0x63:%20      Byte imm5 = instruction.sbtype.imm5;%20      Byte imm4;%20      Byte n11 = imm5 & (1U);%20      imm5 >>= 1;%20      Byte imm7 = instruction.sbtype.imm7;%20      Byte n12 = imm7 & (1U << 6);%20      imm7 <<= 1;%20      imm7 >>= 1;%20      return (n12 << 11) + (n11 << 10) + (imm7 << 4) + (imm5 << 1);%20does this give the offset in a branch instruction? | 1
2025-10-09 17:39:41.032 | Query: Are J-types stored assuming that you will add a 0 to the end after decoding? | 1
2025-10-09 17:39:53.682 | Query: Are J-type instructions stored assuming that you will add a 0 to the end after decoding? | 1
2025-10-09 17:40:29.780 | Query: Are J-type instructions stored assuming that you will add a 0 to the end after decoding?%20In the riscv reference card it doesn't say where the 0th bit is stored | 1
2025-10-09 17:41:04.389 | Query: Are J-type instructions stored assuming that you will add a 0 to the end after decoding?%20In the riscv reference card it doesn't say where the 0th bit is stored, so do we put a 0 there after decoding? | 1
2025-10-09 17:41:38.921 | Query: How do I get the offset from a J-type instruction?%20 | 1
2025-10-09 17:47:18.180 | Query: How do I get the offset from a J-type instruction? where do i get the 0th bit?%20 | 1
2025-10-09 17:47:49.775 | Query: Byte imm5 = instruction.sbtype.imm5;%20      Byte imm4;%20      Byte n11 = imm5 & (1U);%20      imm5 >>= 1;%20      Byte imm7 = instruction.sbtype.imm7;%20      Byte n12 = imm7 & (1U << 6);%20      imm7 = imm7 & ((1U << 6) - 1);%20      return (n12 << 12) + (n11 << 11) + (imm7 << 5) + (imm5 << 1);%20does this correctly get the offset from a B-type instruction? | 1
2025-10-09 17:50:18.615 | Query: Can I combine uints of different bit lengths? For example if i wanted to add  a uint8_t and a uint16_t | 1
2025-10-09 17:50:47.992 | Query: If i have a uint8 and I shift it left will it cut off all bits above the 7th? | 1
2025-10-09 18:07:31.793 | Query: if (n == 0 || n == 32) {%20    return (int)field;%20  }%20  Word mask = (1U << 31);%20  return (int)(field & mask);%20Does this code correctly sign extend to 32 bits? | 1
2025-10-09 18:14:21.899 | Query: if (n == 0 || n == 32) {%20    return (int)field;%20  }%20  Word result = (Word)field;%20  if (field & (1U << (n-1))) {%20    result += ((1U << 32) - 1) - ((1U << n) - 1);%20  }%20  return (int)(result);%20Does this code correctly sign extend to 32 bits? | 1
2025-10-09 18:16:58.076 | Query: /* Sign extends the given field to a 32-bit integer where field is%20 * interpreted an n-bit integer. */%20int sign_extend_number(unsigned int field, unsigned int n) {%20  /* YOUR CODE HERE */%20  if (n == 0 || n == 32) {%20    return (int)field;%20  }%20  Word result = (Word)field;%20  if (field & (1U << (n-1))) {%20    result += ((1U << 32) - 1) - ((1U << n) - 1);%20  }%20  return (int)(result);%20}%20%20Does this code correctly sign extend to 32 bits? | 1
2025-10-09 19:03:37.942 | Query: what is the offset in a branch type 32bit Riscv instruction  | 1
2025-10-09 19:04:14.362 | Query: what is the offset in a branch type 32bit Riscv instruction 0x007d9863 | 1
2025-10-09 19:40:46.832 | Query: debug why this code does not work with twos complememnt numbers and ways to fix.%20%20int get_branch_offset(Instruction instruction) {%20  /* YOUR CODE HERE */%20  int imm7 = instruction.sbtype.imm7;%20  int imm5 = instruction.sbtype.imm5;%20%20  int offset = 0x00000000;%20%20  offset |= (imm7 >> 6) & 1;%20  printf(" = %d = ", offset);%20%20  offset <<= 1;%20%20  offset |= (imm5 >> 4) & 1;%20  printf(" = %d = ", offset);%20%20  offset <<= 6;%20%20  // 0b 0011 1111%20  offset |= (imm7 & 0x3f);%20  printf(" = %d = ", offset);%20  %20  offset <<= 4;%20%20  // 0b 0001 1110%20  offset |= (imm5 & 0x1e);%20  printf(" = %d = ", offset);%20%20  return offset;%20}%20 | 1
2025-10-09 19:48:59.679 | Query: when finding the imm of a 32bit riscv branch instruction, if the imm is a negative number, does it get decoded into a normal binary first or after assembling the imm. | 1
2025-10-09 19:50:58.411 | Query: when finding the imm of a 32bit riscv branch instruction, if the imm is a negative number, does it get decoded into a normal binary first or after assembling the imm.%20%20int imm7 = instruction.sbtype.imm7;%20int imm5 = instruction.sbtype.imm5;%20%20Show how it would work in code using imm7 and imm5 | 1
2025-10-09 19:53:23.163 | Query: what does the r-type instruction slt do in riscv | 1
2025-10-09 19:53:33.493 |  Query: what does the r-type instruction slt do in riscv | Rating: 5  | 1
2025-10-09 19:55:12.705 | Query: what does the r-type instruction slt do in riscv. does it compare signed values | 1
2025-10-09 19:59:39.042 | Query: what do sll and srl do in riscv | 1
2025-10-09 20:01:31.949 | Query: what's the difference between srl and sra in riscv | 1
2025-10-09 20:20:25.191 | Query: Debug why negative numbers do not turn%2032bit Riscv.%20%20int get_jump_offset(Instruction instruction) {%20  /* YOUR CODE HERE */%20  int imm = instruction.ujtype.imm;%20%20  int offset = (imm >> 19) << 8;%20%20  //0b 1111 1111%20  offset |= (imm & 0xff) << 1;%20%20  offset |= ((imm >> 8) & 1) << 10;%20%20  //0b 011 1111 1111%20  offset |= (imm >> 9 & 0x3ff);%20%20  offset <<= 1;%20%20  return sign_extend_number(offset, 20);%20} | 1
2025-10-09 20:26:55.953 | Query: 32bit Riscv. Decode this 0xfe1ff0ef.%20What is the imm in binary and what does it look like after sorting it%20 | 1
2025-10-09 20:35:40.814 | Query: what does slli do in riscv | 1
2025-10-09 20:36:35.760 | Query: what does slli do in riscv. does it get the lowest 5 bits? | 1
2025-10-09 20:49:51.173 | Query: 32bit Riscv. Decode this 0xfe1ff0ef.%20What is the imm in binary and the code to create the imm%20 | 1
2025-10-09 21:14:19.947 | Query: 32bit Riscv.%20%20What is the difference between Mul and Mulh and Mulsu%20 | 1
2025-10-09 21:17:04.218 | Query: 32bit Riscv.%20%20What is the difference between div and divu%20 | 1
2025-10-09 21:18:45.069 | Query: 32bit Riscv.%20%20What is the difference between srl sra | 1
2025-10-09 21:33:58.051 | Query: in which position is the sign bit in an itype immediate | 1
2025-10-09 21:34:10.163 | Query: in which position is the sign bit in the immediate in an itype immediate | 1
2025-10-09 21:36:43.276 | Query: how do you tell whether to do slli or srli given an immediate | 1
2025-10-09 21:37:14.174 | Query: how do you tell whether to do srai or srli given an immediate | 1
2025-10-09 21:41:22.425 | Query: is the sign bit of the immediate field what decides logical vs arithmetic shift | 1
2025-10-09 21:44:56.294 | Query: so srli and srai have a funct7 | 1
2025-10-09 21:45:30.006 | Query: do srli and srai have a funct7 even though other i-type instructions don't? where in the instruction is it located | 1
2025-10-09 21:46:26.540 | Query: if the funct7 is in bits 31:25 for srli and sraai, then where is the immediate. does it have a smaller range | 1
2025-10-10 00:30:23.832 | Query: why is lui rd = imm << 12 instead of rd = imm >> 12 | 1
2025-10-10 12:52:22.086 | Topic: how many bits is the immediate in lw, lh and lb | 1
2025-10-10 12:52:28.161 | Query: how many bits is the immediate in lw, lh and lb | 1
2025-10-10 12:54:17.416 | Query: do lh and lb not read all bits of the immediate | 1
2025-10-10 13:02:53.814 | Query: all registers are 32 bits? | 1
2025-10-10 13:03:26.338 | Query: all registers are 32 bits? so to clarify, in assignment2, we have to sign extend lh, lb and lw to 32 bits? | 1
2025-10-10 13:04:34.200 | Query: in assignment 2, we have to sign extend the itype immediate to 32 bits when using it? | 1
2025-10-10 13:10:07.378 | Query: what type of instruction is store | 1
2025-10-10 13:10:20.334 | Query: where is the link to the riscv green card | 1
2025-10-10 13:16:02.361 | Query: how does jal work | 1
2025-10-10 13:24:44.348 | Query: how does lui work | 1
2025-10-10 13:28:00.788 | Query: how does lui work. is it a utype | 1
2025-10-10 13:33:25.371 | Query: does lui shift the immediate left by 12 bits to store it in the destination register | 1
2025-10-10 13:46:22.806 | Query: 0x1f to binary | 1
2025-10-10 15:25:01.871 | Query: in s-type instructions rs2 is being stored in an offset of rs1?%20 | 1
2025-10-10 21:16:44.364 | Query: explain the instructions for part 3 of assignment 2 | 1
2025-10-10 21:17:46.062 | Query: explain the instructions for part 3 of assignment 2. Part 3 Custom Instructions%20DO NOT ATTEMPT THIS WITHOUT COMPLETING PART 1 and 2%20%20The RISC-V ISA enables the designer to customize and extend the ISA. It reserves bits in the opcode space so that designers can define new operations. We are going to add support for a custom instructions.%20%20if MEM[rs1] < rs2:%20    MEM[rs1] = rs2%20rd = MEM[rs1]%20In programs, custom load-modify-store is pretty common operation i.e., the instruction performs both a load and a store. The address is stored in rs1 (assume offset is effectively 0). The instruction operations are as follows: First, it loads the value at in MEM[rs1]. Then, it compares the value with rs2. If the value in memory is less than rs2, it stores rs2 in the memory location. Finally it returns the smaller value in rd.%20%20Instruction	Type	Opcode	Funct3	Funct7	Operation%20lswc rd,rs1,rs2	R	0x2a	0x1	0x0	if (MEM[rs1] < rs2) MEM[rs1] = rs2, rd = MEM[rs1]%20We are going to add one such new instruction to our disassembler (part 1) and emulator (part 2). You may need new or modify existing functions in part1.c, part2.c, utils.c.%20%20# The test file is custom%20$ ./riscv -d ./code/input/custom_lswc.input > ./code/out/custom_lswc.solution%20$ diff ./code/out/custom_lswc.solution ./code/ref/custom_lswc.solution%20$ ./riscv -t -e -r -s ./code/input/lswc_data.input  -a 0x8,0x3000 ./code/input/custom_lswc.input > code/out/custom_lswc.trace%20$ python3 part2_tester.py custom_lswc%20We have added two more options to the riscv emulator.%20%20Option	Description%20-s	Loads data from the file into the memory starting at 0x3000.%20-a	loads argument registers starting at a0. e.g., -a 0x8,0x3000 means set a0=0x8 and a1=0x3000 when program starts up | 1
2025-10-10 21:20:00.079 | Query: for part 3 of assignment 2, does the printlswc function only require the argument instruction to print the instruction | 1
2025-10-10 21:20:06.507 | Query: for part 3 of assignment 2, does the printlswc function only require the argument instruction | 1
2025-10-10 21:20:21.630 | Query: for part 3 of assignment 2, does the function that prints lswc only require the argument instruction | 1
2025-10-10 21:37:50.676 | Query: for assignment2 part 3 in order to print the lswc command do we need to give the function the pc | 1
2025-10-10 22:37:13.643 | Query: does the pc print the location of the instruction | 1
2025-10-10 22:37:32.557 | Query: does the pc print the location of the instruction. do i need it to print the address of lwsc in assignment2 part 3 | 1
2025-10-10 22:38:26.201 | Query: how to print hex | 1
2025-10-10 22:40:35.859 | Query: #define RTYPE_FORMAT "%s\tx%d, x%d, x%d\n" in rtype format what does tx do | 1
2025-10-10 22:41:10.456 | Query: how to print hex without 0x | 1
2025-10-10 22:57:19.284 | Query: Part 3 Custom Instructions%20DO NOT ATTEMPT THIS WITHOUT COMPLETING PART 1 and 2%20%20The RISC-V ISA enables the designer to customize and extend the ISA. It reserves bits in the opcode space so that designers can define new operations. We are going to add support for a custom instructions.%20%20if MEM[rs1] < rs2:%20    MEM[rs1] = rs2%20rd = MEM[rs1]%20In programs, custom load-modify-store is pretty common operation i.e., the instruction performs both a load and a store. The address is stored in rs1 (assume offset is effectively 0). The instruction operations are as follows: First, it loads the value at in MEM[rs1]. Then, it compares the value with rs2. If the value in memory is less than rs2, it stores rs2 in the memory location. Finally it returns the smaller value in rd.%20%20Instruction	Type	Opcode	Funct3	Funct7	Operation%20lswc rd,rs1,rs2	R	0x2a	0x1	0x0	if (MEM[rs1] < rs2) MEM[rs1] = rs2, rd = MEM[rs1]%20We are going to add one such new instruction to our disassembler (part 1) and emulator (part 2). You may need new or modify existing functions in part1.c, part2.c, utils.c.%20%20# The test file is custom%20$ ./riscv -d ./code/input/custom_lswc.input > ./code/out/custom_lswc.solution%20$ diff ./code/out/custom_lswc.solution ./code/ref/custom_lswc.solution%20$ ./riscv -t -e -r -s ./code/input/lswc_data.input  -a 0x8,0x3000 ./code/input/custom_lswc.input > code/out/custom_lswc.trace%20$ python3 part2_tester.py custom_lswc%20We have added two more options to the riscv emulator.%20%20Option	Description%20-s	Loads data from the file into the memory starting at 0x3000.%20-a	loads argument registers starting at a0. e.g., -a 0x8,0x3000 means set a0=0x8 and a1=0x3000 when program starts up what do we need to here in part3 | 1
2025-10-10 23:00:26.141 | Query: Part 3 Custom Instructions%20DO NOT ATTEMPT THIS WITHOUT COMPLETING PART 1 and 2%20%20The RISC-V ISA enables the designer to customize and extend the ISA. It reserves bits in the opcode space so that designers can define new operations. We are going to add support for a custom instructions.%20%20if MEM[rs1] < rs2:%20    MEM[rs1] = rs2%20rd = MEM[rs1]%20In programs, custom load-modify-store is pretty common operation i.e., the instruction performs both a load and a store. The address is stored in rs1 (assume offset is effectively 0). The instruction operations are as follows: First, it loads the value at in MEM[rs1]. Then, it compares the value with rs2. If the value in memory is less than rs2, it stores rs2 in the memory location. Finally it returns the smaller value in rd.%20%20Instruction	Type	Opcode	Funct3	Funct7	Operation%20lswc rd,rs1,rs2	R	0x2a	0x1	0x0	if (MEM[rs1] < rs2) MEM[rs1] = rs2, rd = MEM[rs1]%20We are going to add one such new instruction to our disassembler (part 1) and emulator (part 2). You may need new or modify existing functions in part1.c, part2.c, utils.c.%20%20# The test file is custom%20$ ./riscv -d ./code/input/custom_lswc.input > ./code/out/custom_lswc.solution%20$ diff ./code/out/custom_lswc.solution ./code/ref/custom_lswc.solution%20$ ./riscv -t -e -r -s ./code/input/lswc_data.input  -a 0x8,0x3000 ./code/input/custom_lswc.input > code/out/custom_lswc.trace%20$ python3 part2_tester.py custom_lswc%20We have added two more options to the riscv emulator.%20%20Option	Description%20-s	Loads data from the file into the memory starting at 0x3000.%20-a	loads argument registers starting at a0. e.g., -a 0x8,0x3000 means set a0=0x8 and a1=0x3000 when program starts up in part3, do we need to pass the pc somewhere | 1
2025-10-10 23:01:05.264 | Query: Part 3 Custom Instructions%20DO NOT ATTEMPT THIS WITHOUT COMPLETING PART 1 and 2%20%20The RISC-V ISA enables the designer to customize and extend the ISA. It reserves bits in the opcode space so that designers can define new operations. We are going to add support for a custom instructions.%20%20if MEM[rs1] < rs2:%20    MEM[rs1] = rs2%20rd = MEM[rs1]%20In programs, custom load-modify-store is pretty common operation i.e., the instruction performs both a load and a store. The address is stored in rs1 (assume offset is effectively 0). The instruction operations are as follows: First, it loads the value at in MEM[rs1]. Then, it compares the value with rs2. If the value in memory is less than rs2, it stores rs2 in the memory location. Finally it returns the smaller value in rd.%20%20Instruction	Type	Opcode	Funct3	Funct7	Operation%20lswc rd,rs1,rs2	R	0x2a	0x1	0x0	if (MEM[rs1] < rs2) MEM[rs1] = rs2, rd = MEM[rs1]%20We are going to add one such new instruction to our disassembler (part 1) and emulator (part 2). You may need new or modify existing functions in part1.c, part2.c, utils.c.%20%20# The test file is custom%20$ ./riscv -d ./code/input/custom_lswc.input > ./code/out/custom_lswc.solution%20$ diff ./code/out/custom_lswc.solution ./code/ref/custom_lswc.solution%20$ ./riscv -t -e -r -s ./code/input/lswc_data.input  -a 0x8,0x3000 ./code/input/custom_lswc.input > code/out/custom_lswc.trace%20$ python3 part2_tester.py custom_lswc%20We have added two more options to the riscv emulator.%20%20Option	Description%20-s	Loads data from the file into the memory starting at 0x3000.%20-a	loads argument registers starting at a0. e.g., -a 0x8,0x3000 means set a0=0x8 and a1=0x3000 when program starts up in part3, how is lwsc printed | 1
2025-10-10 23:01:32.081 | Query: Part 3 Custom Instructions%20DO NOT ATTEMPT THIS WITHOUT COMPLETING PART 1 and 2%20%20The RISC-V ISA enables the designer to customize and extend the ISA. It reserves bits in the opcode space so that designers can define new operations. We are going to add support for a custom instructions.%20%20if MEM[rs1] < rs2:%20    MEM[rs1] = rs2%20rd = MEM[rs1]%20In programs, custom load-modify-store is pretty common operation i.e., the instruction performs both a load and a store. The address is stored in rs1 (assume offset is effectively 0). The instruction operations are as follows: First, it loads the value at in MEM[rs1]. Then, it compares the value with rs2. If the value in memory is less than rs2, it stores rs2 in the memory location. Finally it returns the smaller value in rd.%20%20Instruction	Type	Opcode	Funct3	Funct7	Operation%20lswc rd,rs1,rs2	R	0x2a	0x1	0x0	if (MEM[rs1] < rs2) MEM[rs1] = rs2, rd = MEM[rs1]%20We are going to add one such new instruction to our disassembler (part 1) and emulator (part 2). You may need new or modify existing functions in part1.c, part2.c, utils.c.%20%20# The test file is custom%20$ ./riscv -d ./code/input/custom_lswc.input > ./code/out/custom_lswc.solution%20$ diff ./code/out/custom_lswc.solution ./code/ref/custom_lswc.solution%20$ ./riscv -t -e -r -s ./code/input/lswc_data.input  -a 0x8,0x3000 ./code/input/custom_lswc.input > code/out/custom_lswc.trace%20$ python3 part2_tester.py custom_lswc%20We have added two more options to the riscv emulator.%20%20Option	Description%20-s	Loads data from the file into the memory starting at 0x3000.%20-a	loads argument registers starting at a0. e.g., -a 0x8,0x3000 means set a0=0x8 and a1=0x3000 when program starts up in part3, what does the function printing lwsc need to print%20 | 1
2025-10-11 00:15:24.302 | Query: bash ./scripts/localci.sh this command takes more than a minute to run | 1
2025-10-11 00:15:52.376 | Query: one of my test commands takes more than a minute to run | 1
2025-10-11 00:16:28.935 | Query: one of my test commands takes more than a minute to run and then i think it crashes and i don't get the mark for one part even though my code works | 1
2025-10-11 15:27:16.770 | Query: does the mul instruction cast rs1 and rs2 to a signed word | 1
2025-10-11 15:27:30.776 | Query: is mul instruction signed | 1
2025-10-11 15:28:19.587 | Query: does the mul instruction result in a 32 bit unsigned int | 1
2025-10-11 15:29:16.622 | Query: how does mulh work | 1
2025-10-11 15:43:10.445 | Query: Debug if there is anything wrong with the load function:%20RISCV 32bit%20%20typedef uint8_t  Byte; /* unsigned, 8-bit */%20typedef uint16_t Half; /* unsigned, 16-bit */%20typedef uint32_t Word; /* unsigned, 32-bit */%20typedef uint64_t Double; /* unsigned, 64-bit */%20%20typedef int8_t  sByte; /* signed, 8-bit */%20typedef int16_t sHalf; /* signed, 16-bit */%20typedef int32_t sWord; /* signed, 32-bit */%20typedef int64_t sDouble; /* signed, 64-bit */%20%20/* A memory address */%20typedef Word Address; /* unsigned, 32-bit */%20%20/* A register value */%20typedef Word Register; /* unsigned 32-bit*/%20%20/* The processor data: %20    32 registers%20    LO & HI special registers%20    PC program counter */%20typedef struct {%20    Register R[32];%20    Register PC;%20} Processor;%20%20/* Possible lengths of data, and their lengths in bytes.%20 These are used to align memory*/%20typedef enum {%20    LENGTH_BYTE = 1,%20    LENGTH_HALF_WORD = 2,%20    LENGTH_WORD = 4,%20} Alignment;%20%20void execute_load(Instruction instruction, Processor *processor, Byte *memory) {%20    switch (instruction.itype.funct3) {%20        case 0x0:%20            // LB%20            processor->R[instruction.itype.rd] = %20                load(%20                    memory,%20                    (sByte) processor->R[instruction.itype.rs1] + %20                    ((sByte) sign_extend_number(instruction.itype.imm, 12)),%20                    LENGTH_BYTE%20                );%20            break;%20        case 0x1:%20            // LH%20            processor->R[instruction.itype.rd] = %20                load(%20                    memory,%20                    (sHalf) processor->R[instruction.itype.rs1] + %20                    ((sHalf) sign_extend_number(instruction.itype.imm, 12)),%20                    LENGTH_HALF_WORD%20                );%20            break;%20        case 0x2:%20            // LW%20            processor->R[instruction.itype.rd] = %20                load(%20                    memory,%20                    (sWord) processor->R[instruction.itype.rs1] + %20                    ((sWord) sign_extend_number(instruction.itype.imm, 12)),%20                    LENGTH_WORD%20                );%20            break;%20        default:%20            handle_invalid_instruction(instruction);%20            break;%20    }%20}%20%20int sign_extend_number(unsigned int field, unsigned int n) {%20  /* YOUR CODE HERE */%20  int extend = field >> (n - 1);%20%20  if (extend) {%20    extend = 0xffffffff;%20    extend >>= n;%20    extend <<= n;%20    extend |= field;%20  } else {%20    extend = 0x00000000;%20    extend |= field;%20  }%20%20  return extend;%20}%20%20Word load(Byte *memory, Address address, Alignment alignment) {%20    /* YOUR CODE HERE */%20    Word word = 0x00000000;%20    if (alignment == LENGTH_WORD) {%20        word |= memory[address];%20        word |= (memory[address + 1] << 8);%20        word |= (memory[address + 2] << 16);%20        word |= (memory[address + 3] << 24);%20    } else if (alignment == LENGTH_HALF_WORD) {%20        word |= memory[address];%20        word |= (memory[address + 1] << 8);%20%20    } else if (alignment == LENGTH_BYTE) {%20        word |= memory[address];%20%20    }%20%20    return word;%20} | 1
2025-10-11 16:18:05.474 | Query: what is mulh? Is it just multiplyhing rs1 and rs2 and then only taking the upper bits? | 1
2025-10-11 16:22:12.294 | Query: what does slt actually do?%20 | 1
2025-10-11 16:26:16.762 | Query: Does div return an integer? | 1
2025-10-11 16:26:47.230 | Query: Does div return an integer? would something like (int)(a/b) replicate it? | 1
2025-10-11 16:29:53.301 | Query: what's the difference between srl and sra?%20 | 1
2025-10-11 16:36:37.891 | Query: what's the difference between srl and sra?%20((sWord)processor->R[instruction.rtype.rs1]) >>%20((sWord)processor->R[instruction.rtype.rs2]);%20would this work for sra given that sword is int32_t ? | 1
2025-10-11 16:38:05.781 | Query: what's the difference between srl and sra?%20If i have a int32_t then the 32nd bit will be 1 if it's negative right? | 1
2025-10-11 16:41:24.951 | Query: int result =%20       ((sWord)processor->R[instruction.rtype.rs1]) >>%20       ((sWord)processor->R[instruction.rtype.rs2]);%20proecssor->R[instruction.rtype.rd] = sign_extend_number(result, 32 - (sWord)processor->R[instruction.rtype.rs2]);        %20would this code give sra? | 1
2025-10-11 16:42:31.658 | Query: int result =%20       ((sWord)processor->R[instruction.rtype.rs1]) >>%20       ((sWord)processor->R[instruction.rtype.rs2]);%20proecssor->R[instruction.rtype.rd] = sign_extend_number(result, 32 - (sWord)processor->R[instruction.rtype.rs2]);        %20would this code give the same result as sra? | 1
2025-10-11 16:44:42.817 | Query: How can I emulate sra in C?%20 | 1
2025-10-11 16:48:21.569 | Query: How can I emulate sra in C?%20would performing int_32 rs1 >> in_32 rs2 do it? | 1
2025-10-11 16:56:56.830 | Query:             switch (instruction.rtype.funct7) {%20                case 0x0:%20                    // SRL%20                    processor->R[instruction.rtype.rd] =%20                        ((Word)processor->R[instruction.rtype.rs1]) >>%20                        ((Word)processor->R[instruction.rtype.rs2]);%20                    break;%20                case 0x20:%20                    // SRA%20                    int result =%20                        ((sWord)processor->R[instruction.rtype.rs1]) >>%20                        ((Word)processor->R[instruction.rtype.rs2]);%20                    proecssor->R[instruction.rtype.rd] = sign_extend_number(result, 32 - (sWord)processor->R[instruction.rtype.rs2]);                    %20                    break;%20Is this correct? | 1
2025-10-11 16:59:48.185 | Query:                 case 0x0:%20                    // SRL%20                    processor->R[instruction.rtype.rd] =%20                        ((Word)processor->R[instruction.rtype.rs1]) >>%20                        ((Word)processor->R[instruction.rtype.rs2]);%20                    break;%20                case 0x20:%20                    // SRA%20                    processor->R[instruction.rtype.rd] =  =%20                        ((sWord)processor->R[instruction.rtype.rs1]) >>%20                        ((Word)processor->R[instruction.rtype.rs2]);             %20                    break;%20Is this correct? | 1
2025-10-11 17:00:11.690 | Query:                 case 0x0:%20                    // SRL%20                    processor->R[instruction.rtype.rd] =%20                        ((Word)processor->R[instruction.rtype.rs1]) >>%20                        ((Word)processor->R[instruction.rtype.rs2]);%20                    break;%20                case 0x20:%20                    // SRA%20                    processor->R[instruction.rtype.rd] =%20                        ((sWord)processor->R[instruction.rtype.rs1]) >>%20                        ((Word)processor->R[instruction.rtype.rs2]);             %20                    break;%20Is this correct? | 1
2025-10-11 17:02:49.446 | Query: Does the ^ symbol for XOR exist in C? | 1
2025-10-11 17:03:28.564 | Query: Is % for remainder in C?%20 | 1
2025-10-12 12:56:10.027 | Query: RISCV 32 bit.%20Why does lb not get access to the correct memory. %20%20Code:%20void execute_load(Instruction instruction, Processor *processor, Byte *memory) {%20    switch (instruction.itype.funct3) {%20        case 0x0:%20            // LB%20            processor->R[instruction.itype.rd] = %20                load(%20                    memory,%20                    (sByte) processor->R[instruction.itype.rs1] + %20                    ((sByte)sign_extend_number(instruction.itype.imm, 12)),%20                    LENGTH_BYTE%20                );%20            break;%20        case 0x1:%20            // LH%20            processor->R[instruction.itype.rd] = %20                load(%20                    memory,%20                    (sHalf) processor->R[instruction.itype.rs1] + %20                    ((sHalf) sign_extend_number(instruction.itype.imm, 12)),%20                    LENGTH_HALF_WORD%20                );%20            break;%20        case 0x2:%20            // LW%20            processor->R[instruction.itype.rd] = %20                load(%20                    memory,%20                    (sWord) processor->R[instruction.itype.rs1] + %20                    ((sWord) sign_extend_number(instruction.itype.imm, 12)),%20                    LENGTH_WORD%20                );%20            break;%20        default:%20            handle_invalid_instruction(instruction);%20            break;%20    }%20    processor->PC += 4; %20%20}%20%20Word load(Byte *memory, Address address, Alignment alignment) {%20    /* YOUR CODE HERE */%20    Word word = 0x00000000;%20    if (alignment == LENGTH_WORD) {%20        word |= memory[address];%20        word |= (memory[address + 1] << 8);%20        word |= (memory[address + 2] << 16);%20        word |= (memory[address + 3] << 24);%20%20    } else if (alignment == LENGTH_HALF_WORD) {%20        Half half = 0x0000;%20        half |= memory[address];%20        half |= (memory[address + 1] << 8);%20        return half;%20%20    } else if (alignment == LENGTH_BYTE) {%20        Byte byte = 0x00;%20        printf(" = BYTE %d= \n",memory[address]);%20        byte |= memory[address];%20        return byte;%20%20    }%20%20    return word;%20}%20%20RISCV instructions:%200x40050513%200x40050513%200x40050513%200x40050513%200x00052583%200x00051603   %200x00050683   %200x01052703%200x01852783 %200x02052803%20Which translates to%2000001000: addi	x10, x10, 1024%2000001004: addi	x10, x10, 1024%2000001008: addi	x10, x10, 1024%200000100c: addi	x10, x10, 1024%2000001010: lw	x11, 0(x10)%2000001014: lh	x12, 0(x10)%2000001018: lb	x13, 0(x10)%200000101c: lw	x14, 16(x10)%2000001020: lw	x15, 24(x10)%2000001024: lw	x16, 32(x10)%20    | 1
2025-10-12 13:30:00.584 | Query: RISCV 32bit %20What is the difference between mul and mulh%20 | 1
2025-10-12 14:33:15.208 | Query: RISCV 32bit %20Explain why lb and lh at address 1018 and 101c are loading the entire address instead of the byte and half%20%20Instructions :%2000001000: lui	x5, 1048575%2000001004: ori	x5, x5, 2047%2000001008: addi	x2, x2, -3%200000100c: sb	x5, 0(x2)%2000001010: sh	x5, 1(x2)%2000001014: xori	x5, x5, 2047%2000001018: lb	x8, 0(x2)%200000101c: lh	x9, 1(x2)%2000001020: srai	x5, x5, 31%2000001024: slt	x10, x5, x0%2000001028: add	x5, x5, x10%200000102c: addi	x10, x0, 20%2000001030: srli	x10, x10, 1%2000001034: addi	x6, x0, 10%2000001038: beq	x10, x6, 24%200000103c: lui	x11, 1048575%2000001040: lui	x18, 2989%2000001044: lui	x19, 57005%2000001048: lui	x20, 48879%200000104c: addi	x10, x10, 10%2000001050: ecall%20%20%20 | 1
2025-10-12 14:37:27.576 | Query: The semantics of add instruction is rd = rs1 + rs2. rd and rs1 and rs2 are specified by the instruction. Under the switch case in Line 60: part2.c // Add in function execute_rtype(Instruction instruction, Processor *processor) . you will be implementing the instruction. To implement add do the following.%20%20processor->R[instruction.rtype.rd] =%20                ((sWord)processor->R[instruction.rtype.rs1]) +%20                ((sWord)processor->R[instruction.rtype.rs2]);%20%20What is the above statement doing ? It gets the registers to be modified from instruction bits passed to the function instruction.rtype.rs1,rs2,rd. It then reads and writes the processor->R registers. Since the R[32] is an unsigned variable and + is a signed operator, we cast the Rs to signed (sWord) before updating the destination register. Similarly we can implement multiply.%20%20processor->R[instruction.rtype.rd] =%20                ((sWord)processor->R[instruction.rtype.rs1]) *%20                ((sWord)processor->R[instruction.rtype.rs2]);%20%20%20in which cases would we not convert the rs1 or rs2 value to sWord? | 1
2025-10-12 14:38:40.725 | Query: The semantics of add instruction is rd = rs1 + rs2. rd and rs1 and rs2 are specified by the instruction. Under the switch case in Line 60: part2.c // Add in function execute_rtype(Instruction instruction, Processor *processor) . you will be implementing the instruction. To implement add do the following.%20%20processor->R[instruction.rtype.rd] =%20                ((sWord)processor->R[instruction.rtype.rs1]) +%20                ((sWord)processor->R[instruction.rtype.rs2]);%20%20What is the above statement doing ? It gets the registers to be modified from instruction bits passed to the function instruction.rtype.rs1,rs2,rd. It then reads and writes the processor->R registers. Since the R[32] is an unsigned variable and + is a signed operator, we cast the Rs to signed (sWord) before updating the destination register. Similarly we can implement multiply.%20%20processor->R[instruction.rtype.rd] =%20                ((sWord)processor->R[instruction.rtype.rs1]) *%20                ((sWord)processor->R[instruction.rtype.rs2]);%20%20%20in which cases would we not convert the rs1 or rs2 value to sWord? Would a >> operation or a | operation need it? | 1
2025-10-12 14:41:18.298 | Query: The semantics of add instruction is rd = rs1 + rs2. rd and rs1 and rs2 are specified by the instruction. Under the switch case in Line 60: part2.c // Add in function execute_rtype(Instruction instruction, Processor *processor) . you will be implementing the instruction. To implement add do the following.%20%20processor->R[instruction.rtype.rd] =%20                ((sWord)processor->R[instruction.rtype.rs1]) +%20                ((sWord)processor->R[instruction.rtype.rs2]);%20%20What is the above statement doing ? It gets the registers to be modified from instruction bits passed to the function instruction.rtype.rs1,rs2,rd. It then reads and writes the processor->R registers. Since the R[32] is an unsigned variable and + is a signed operator, we cast the Rs to signed (sWord) before updating the destination register. Similarly we can implement multiply.%20%20processor->R[instruction.rtype.rd] =%20                ((sWord)processor->R[instruction.rtype.rs1]) *%20                ((sWord)processor->R[instruction.rtype.rs2]);%20%20%20in which cases would we not convert the rs1 or rs2 value to sWord? Would a >> operation or a == operation need it? | 1
2025-10-12 14:52:50.373 | Query: what does the {imm, 1b'0} mean?:%20jal rd, imm:%20R[rd] <- PC + 4%20PC <- PC + {imm, 1b'0} | 1
2025-10-12 15:07:44.576 | Query: RISCV 32bit %20Why does the SRLI return b instead of a? The RD is changed to 10 and it still is b%20%20Instructions :%2000001000: lui	x5, 1048575%2000001004: ori	x5, x5, 2047%2000001008: addi	x2, x2, -3%200000100c: sb	x5, 0(x2)%2000001010: sh	x5, 1(x2)%2000001014: xori	x5, x5, 2047%2000001018: lb	x8, 0(x2)%200000101c: lh	x9, 1(x2)%2000001020: srai	x5, x5, 31%2000001024: slt	x10, x5, x0%2000001028: add	x5, x5, x10%200000102c: addi	x10, x0, 20%2000001030: srli	x10, x10, 1%2000001034: addi	x6, x0, 10%2000001038: beq	x10, x6, 24%200000103c: lui	x11, 1048575%2000001040: lui	x18, 2989%2000001044: lui	x19, 57005%2000001048: lui	x20, 48879%200000104c: addi	x10, x10, 10%2000001050: ecall%20%20Code:%20          case 0x00:%20            printf(" = %d RD %d= ",processor->R[instruction.itype.rd], instruction.itype.rd );%20            printf(" = %d RS1 %d= ",processor->R[instruction.itype.rs1], instruction.itype.rs1 );%20            printf(" = %d imm %d= ",processor->R[instruction.itype.imm], instruction.itype.imm );%20%20%20            processor->R[instruction.itype.rd] =%20                ((sWord)processor->R[instruction.itype.rs1]) >> %20                (sign_extend_number(instruction.itype.imm, 12) & 0x1f);%20            printf(" = %d AFTER RD %d= ",processor->R[instruction.itype.rd], instruction.itype.rd );%20            printf(" = %d AFTER RS1 %d= ",processor->R[instruction.itype.rs1], instruction.itype.rs1 );%20            printf(" = %d imm %d= ",processor->R[instruction.itype.imm], instruction.itype.imm );%20%20                break;%20 | 1
2025-10-12 15:49:20.103 | Query: RISCV 32bit %20What is wrong with the BEQ%20%20Code:%20  void execute_branch(Instruction instruction, Processor *processor) {%20    switch (instruction.sbtype.funct3) {%20        case 0x0:%20            // BEQ%20            if (processor->R[instruction.sbtype.rs1] == processor->R[instruction.sbtype.rs2]) {%20                processor->PC += get_branch_offset(instruction);%20            }%20            break;%20        case 0x1:%20            // BNE%20            if (instruction.sbtype.rs1 != instruction.sbtype.rs2) {%20                processor->PC += get_branch_offset(instruction);%20            }%20            break;%20        default:%20            handle_invalid_instruction(instruction);%20            exit(-1);%20            break;%20    }%20} | 1
2025-10-12 16:14:36.865 | Query: RISCV 32bit %20What is wrong with the BNE%20%20Code:%20  void execute_branch(Instruction instruction, Processor *processor) {%20    switch (instruction.sbtype.funct3) {%20        case 0x0:%20            // BEQ%20            if (processor->R[instruction.sbtype.rs1] == processor->R[instruction.sbtype.rs2]) {%20                processor->PC += get_branch_offset(instruction);%20            } else {%20                processor->PC += 4; %20            }%20            break;%20        case 0x1:%20            // BNE%20            if (instruction.sbtype.rs1 != instruction.sbtype.rs2) {%20                processor->PC += get_branch_offset(instruction);%20            } else {%20                processor->PC += 4; %20            }%20            break;%20        default:%20            handle_invalid_instruction(instruction);%20            exit(-1);%20            break;%20    }%20} | 1
2025-10-12 19:42:03.619 | Query: RISCV 32bit %20Explain what is happening at address 1014%20%20lswc is :%20if MEM[rs1] < rs2:%20    MEM[rs1] = rs2%20rd = MEM[rs1]%20%20Instructions:%20 00001000: addi	x28, x0, 8%20r 0=00000000 r 1=00000000 r 2=000effff r 3=00003000 %20r 4=00000000 r 5=00000000 r 6=00000000 r 7=00000000 %20r 8=00000000 r 9=00000000 r10=00000008 r11=00003000 %20r12=00000000 r13=00000000 r14=00000000 r15=00000000 %20r16=00000000 r17=00000000 r18=00000000 r19=00000000 %20r20=00000000 r21=00000000 r22=00000000 r23=00000000 %20r24=00000000 r25=00000000 r26=00000000 r27=00000000 %20r28=00000008 r29=00000000 r30=00000000 r31=00000000 %20%2000001004: addi	x28, x28, -1%20r 0=00000000 r 1=00000000 r 2=000effff r 3=00003000 %20r 4=00000000 r 5=00000000 r 6=00000000 r 7=00000000 %20r 8=00000000 r 9=00000000 r10=00000008 r11=00003000 %20r12=00000000 r13=00000000 r14=00000000 r15=00000000 %20r16=00000000 r17=00000000 r18=00000000 r19=00000000 %20r20=00000000 r21=00000000 r22=00000000 r23=00000000 %20r24=00000000 r25=00000000 r26=00000000 r27=00000000 %20r28=00000007 r29=00000000 r30=00000000 r31=00000000 %20%2000001008: slli	x31, x28, 2%20r 0=00000000 r 1=00000000 r 2=000effff r 3=00003000 %20r 4=00000000 r 5=00000000 r 6=00000000 r 7=00000000 %20r 8=00000000 r 9=00000000 r10=00000008 r11=00003000 %20r12=00000000 r13=00000000 r14=00000000 r15=00000000 %20r16=00000000 r17=00000000 r18=00000000 r19=00000000 %20r20=00000000 r21=00000000 r22=00000000 r23=00000000 %20r24=00000000 r25=00000000 r26=00000000 r27=00000000 %20r28=00000007 r29=00000000 r30=00000000 r31=0000001c %20%200000100c: add	x31, x11, x31%20r 0=00000000 r 1=00000000 r 2=000effff r 3=00003000 %20r 4=00000000 r 5=00000000 r 6=00000000 r 7=00000000 %20r 8=00000000 r 9=00000000 r10=00000008 r11=00003000 %20r12=00000000 r13=00000000 r14=00000000 r15=00000000 %20r16=00000000 r17=00000000 r18=00000000 r19=00000000 %20r20=00000000 r21=00000000 r22=00000000 r23=00000000 %20r24=00000000 r25=00000000 r26=00000000 r27=00000000 %20r28=00000007 r29=00000000 r30=00000000 r31=0000301c %20%2000001010: lw	x10, 0(x31)%20r 0=00000000 r 1=00000000 r 2=000effff r 3=00003000 %20r 4=00000000 r 5=00000000 r 6=00000000 r 7=00000000 %20r 8=00000000 r 9=00000000 r10=00000000 r11=00003000 %20r12=00000000 r13=00000000 r14=00000000 r15=00000000 %20r16=00000000 r17=00000000 r18=00000000 r19=00000000 %20r20=00000000 r21=00000000 r22=00000000 r23=00000000 %20r24=00000000 r25=00000000 r26=00000000 r27=00000000 %20r28=00000007 r29=00000000 r30=00000000 r31=0000301c %20%2000001014: lswc	x10, x31, x0%20r 0=00000000 r 1=00000000 r 2=000effff r 3=00003000 %20r 4=00000000 r 5=00000000 r 6=00000000 r 7=00000000 %20r 8=00000000 r 9=00000000 r10=00000000 r11=00003000 %20r12=00000000 r13=00000000 r14=00000000 r15=00000000 %20r16=00000000 r17=00000000 r18=00000000 r19=00000000 %20r20=00000000 r21=00000000 r22=00000000 r23=00000000 %20r24=00000000 r25=00000000 r26=00000000 r27=00000000 %20r28=00000007 r29=00000000 r30=00000000 r31=0000301c %20%2000001018: lw	x10, 0(x31)%20r 0=00000000 r 1=00000000 r 2=000effff r 3=00003000 %20r 4=00000000 r 5=00000000 r 6=00000000 r 7=00000000 %20r 8=00000000 r 9=00000000 r10=00000000 r11=00003000 %20r12=00000000 r13=00000000 r14=00000000 r15=00000000 %20r16=00000000 r17=00000000 r18=00000000 r19=00000000 %20r20=00000000 r21=00000000 r22=00000000 r23=00000000 %20r24=00000000 r25=00000000 r26=00000000 r27=00000000 %20r28=00000007 r29=00000000 r30=00000000 r31=0000301c %20 | 1
2025-10-12 19:59:09.073 | Query: RISCV 32bit %20Explain what is happening at address 1014%20%20%20Instruction	Type	Opcode	Funct3	Funct7	Operation%20lswc rd,rs1,rs2	R	0x2a	0x1	0x0	if (MEM[rs1] < rs2) MEM[rs1] = rs2, rd = MEM[rs1]%20 First, it loads the value at in MEM[rs1]. Then, it compares the value with rs2. If the value in memory is less than rs2, it stores rs2 in the memory location. Finally it returns the smaller value in rd.%20lswc psudo code is :%20if MEM[rs1] < rs2:%20    MEM[rs1] = rs2%20rd = MEM[rs1]%20%20Instructions:%20 00001000: addi	x28, x0, 8%20r 0=00000000 r 1=00000000 r 2=000effff r 3=00003000 %20r 4=00000000 r 5=00000000 r 6=00000000 r 7=00000000 %20r 8=00000000 r 9=00000000 r10=00000008 r11=00003000 %20r12=00000000 r13=00000000 r14=00000000 r15=00000000 %20r16=00000000 r17=00000000 r18=00000000 r19=00000000 %20r20=00000000 r21=00000000 r22=00000000 r23=00000000 %20r24=00000000 r25=00000000 r26=00000000 r27=00000000 %20r28=00000008 r29=00000000 r30=00000000 r31=00000000 %20%2000001004: addi	x28, x28, -1%20r 0=00000000 r 1=00000000 r 2=000effff r 3=00003000 %20r 4=00000000 r 5=00000000 r 6=00000000 r 7=00000000 %20r 8=00000000 r 9=00000000 r10=00000008 r11=00003000 %20r12=00000000 r13=00000000 r14=00000000 r15=00000000 %20r16=00000000 r17=00000000 r18=00000000 r19=00000000 %20r20=00000000 r21=00000000 r22=00000000 r23=00000000 %20r24=00000000 r25=00000000 r26=00000000 r27=00000000 %20r28=00000007 r29=00000000 r30=00000000 r31=00000000 %20%2000001008: slli	x31, x28, 2%20r 0=00000000 r 1=00000000 r 2=000effff r 3=00003000 %20r 4=00000000 r 5=00000000 r 6=00000000 r 7=00000000 %20r 8=00000000 r 9=00000000 r10=00000008 r11=00003000 %20r12=00000000 r13=00000000 r14=00000000 r15=00000000 %20r16=00000000 r17=00000000 r18=00000000 r19=00000000 %20r20=00000000 r21=00000000 r22=00000000 r23=00000000 %20r24=00000000 r25=00000000 r26=00000000 r27=00000000 %20r28=00000007 r29=00000000 r30=00000000 r31=0000001c %20%200000100c: add	x31, x11, x31%20r 0=00000000 r 1=00000000 r 2=000effff r 3=00003000 %20r 4=00000000 r 5=00000000 r 6=00000000 r 7=00000000 %20r 8=00000000 r 9=00000000 r10=00000008 r11=00003000 %20r12=00000000 r13=00000000 r14=00000000 r15=00000000 %20r16=00000000 r17=00000000 r18=00000000 r19=00000000 %20r20=00000000 r21=00000000 r22=00000000 r23=00000000 %20r24=00000000 r25=00000000 r26=00000000 r27=00000000 %20r28=00000007 r29=00000000 r30=00000000 r31=0000301c %20%2000001010: lw	x10, 0(x31)%20r 0=00000000 r 1=00000000 r 2=000effff r 3=00003000 %20r 4=00000000 r 5=00000000 r 6=00000000 r 7=00000000 %20r 8=00000000 r 9=00000000 r10=00000000 r11=00003000 %20r12=00000000 r13=00000000 r14=00000000 r15=00000000 %20r16=00000000 r17=00000000 r18=00000000 r19=00000000 %20r20=00000000 r21=00000000 r22=00000000 r23=00000000 %20r24=00000000 r25=00000000 r26=00000000 r27=00000000 %20r28=00000007 r29=00000000 r30=00000000 r31=0000301c %20%2000001014: lswc	x10, x31, x0%20r 0=00000000 r 1=00000000 r 2=000effff r 3=00003000 %20r 4=00000000 r 5=00000000 r 6=00000000 r 7=00000000 %20r 8=00000000 r 9=00000000 r10=00000000 r11=00003000 %20r12=00000000 r13=00000000 r14=00000000 r15=00000000 %20r16=00000000 r17=00000000 r18=00000000 r19=00000000 %20r20=00000000 r21=00000000 r22=00000000 r23=00000000 %20r24=00000000 r25=00000000 r26=00000000 r27=00000000 %20r28=00000007 r29=00000000 r30=00000000 r31=0000301c %20%2000001018: lw	x10, 0(x31)%20r 0=00000000 r 1=00000000 r 2=000effff r 3=00003000 %20r 4=00000000 r 5=00000000 r 6=00000000 r 7=00000000 %20r 8=00000000 r 9=00000000 r10=00000000 r11=00003000 %20r12=00000000 r13=00000000 r14=00000000 r15=00000000 %20r16=00000000 r17=00000000 r18=00000000 r19=00000000 %20r20=00000000 r21=00000000 r22=00000000 r23=00000000 %20r24=00000000 r25=00000000 r26=00000000 r27=00000000 %20r28=00000007 r29=00000000 r30=00000000 r31=0000301c %20 | 1
2025-10-12 20:01:15.783 | Query: RISCV 32bit %20Explain what is happening at address 1014%20%20%20Instruction	Type	Opcode	Funct3	Funct7	Operation%20lswc rd,rs1,rs2	R	0x2a	0x1	0x0	if (MEM[rs1] < rs2) MEM[rs1] = rs2, rd = MEM[rs1]%20 First, it loads the value at in MEM[rs1]. Then, it compares the value with rs2. If the value in memory is less than rs2, it stores rs2 in the memory location. Finally it returns the smaller value in rd.%20lswc psudo code is :%20if MEM[rs1] < rs2:%20    MEM[rs1] = rs2%20rd = MEM[rs1]%20%20Instructions:%2000001000: addi	x28, x0, 8%2000001004: addi	x28, x28, -1%2000001008: slli	x31, x28, 2%200000100c: add	x31, x11, x31%2000001010: lw	x10, 0(x31)%2000001014: lswc	x10, x31, x0%2000001018: lw	x10, 0(x31)%200000101c: bne	x28, x0, -24%2000001020: addi	x10, x0, 10%2000001024: ecall%20%20%20 | 1
2025-10-12 20:04:48.638 | Query: RISCV 32bit %20Explain what is happening at address 1014 after it gets looped back and why register 10 is supposed to be 19%20%20%20Instruction	Type	Opcode	Funct3	Funct7	Operation%20lswc rd,rs1,rs2	R	0x2a	0x1	0x0	if (MEM[rs1] < rs2) MEM[rs1] = rs2, rd = MEM[rs1]%20 First, it loads the value at in MEM[rs1]. Then, it compares the value with rs2. If the value in memory is less than rs2, it stores rs2 in the memory location. Finally it returns the smaller value in rd.%20lswc psudo code is :%20if MEM[rs1] < rs2:%20    MEM[rs1] = rs2%20rd = MEM[rs1]%20%20Instructions:%2000001000: addi	x28, x0, 8%2000001004: addi	x28, x28, -1%2000001008: slli	x31, x28, 2%200000100c: add	x31, x11, x31%2000001010: lw	x10, 0(x31)%2000001014: lswc	x10, x31, x0%2000001018: lw	x10, 0(x31)%200000101c: bne	x28, x0, -24%2000001020: addi	x10, x0, 10%2000001024: ecall%20%20%20 | 1
2025-10-12 20:14:12.616 | Query: RISCV 32bit %20Trace and explain what is heppening in the code%20%20%20Instruction	Type	Opcode	Funct3	Funct7	Operation%20lswc rd,rs1,rs2	R	0x2a	0x1	0x0	if (MEM[rs1] < rs2) MEM[rs1] = rs2, rd = MEM[rs1]%20 First, it loads the value at in MEM[rs1]. Then, it compares the value with rs2. If the value in memory is less than rs2, it stores rs2 in the memory location. Finally it returns the smaller value in rd.%20lswc psudo code is :%20if MEM[rs1] < rs2:%20    MEM[rs1] = rs2%20rd = MEM[rs1]%20%20Instructions:%2000001000: addi	x28, x0, 8%2000001004: addi	x28, x28, -1%2000001008: slli	x31, x28, 2%200000100c: add	x31, x11, x31%2000001010: lw	x10, 0(x31)%2000001014: lswc	x10, x31, x0%2000001018: lw	x10, 0(x31)%200000101c: bne	x28, x0, -24%2000001020: addi	x10, x0, 10%2000001024: ecall%20%20%20 | 1
2025-10-12 20:15:10.483 | Query: void execute_lui(Instruction instruction, Processor *processor) {%20    /* YOUR CODE HERE */%20    processor->R[instruction.utype.rd] = (sWord)sign_extend_number(instruction.utype.imm, 20) << 12;%20}%20Can you figure out why this isn't sign extending properly?%20 | 1
2025-10-12 20:35:46.144 | Query: void execute_lui(Instruction instruction, Processor *processor) {%20    /* YOUR CODE HERE */%20    processor->R[instruction.utype.rd] = (sWord)instruction.utype.imm << 12;%20}%20Can you figure out why it's not sign extended? | 1
2025-10-12 20:38:22.086 | Query: void execute_lui(Instruction instruction, Processor *processor) {%20    /* YOUR CODE HERE */%20    processor->R[instruction.utype.rd] = (sWord)instruction.utype.imm << 12;%20}%20Can you figure out why this instruction 00001000: lui	x5, 1048575%20gives me < r 8=000000ff r 9=00000000 r10=00000000 r11=00000000%20instead of < r 8=ffffffff r 9=00000000 r10=00000000 r11=00000000 which is the expected output? | 1
2025-10-12 20:39:42.878 | Query: void execute_lui(Instruction instruction, Processor *processor) {%20    /* YOUR CODE HERE */%20    processor->R[instruction.utype.rd] = instruction.utype.imm << 12;%20}%20Can you figure out why this instruction 00001000: lui	x5, 1048575%20gives me < r 8=000000ff r 9=00000000 r10=00000000 r11=00000000%20instead of < r 8=ffffffff r 9=00000000 r10=00000000 r11=00000000 which is the expected output? | 1
2025-10-12 20:40:27.744 | Query: void execute_lui(Instruction instruction, Processor *processor) {%20    /* YOUR CODE HERE */%20    processor->R[instruction.utype.rd] = (Word)instruction.utype.imm << 12;%20}%20Can you figure out why this instruction 00001000: lui	x5, 1048575%20gives me < r 8=000000ff r 9=00000000 r10=00000000 r11=00000000%20instead of < r 8=ffffffff r 9=00000000 r10=00000000 r11=00000000 which is the expected output? | 1
2025-10-12 20:47:45.006 | Query: RISCV 32bit %20Debug what the difference is between the explaination and the code:%20void execute_lswc(Instruction instruction, Processor *processor, Byte *memory) { %20    if (memory[processor->R[instruction.rtype.rs1]] < processor->R[instruction.rtype.rs2]) {%20%20        memory[processor->R[instruction.rtype.rs1]] = processor->R[instruction.rtype.rs2];%20    }%20    processor->R[instruction.rtype.rd] = memory[processor->R[instruction.rtype.rs1]];%20%20    processor->PC += 4;%20}%20%20instructions:%20if MEM[rs1] < rs2:%20    MEM[rs1] = rs2%20rd = MEM[rs1]%20The instruction operations are as follows: First, it loads the value at in MEM[rs1]. Then, it compares the value with rs2. If the value in memory is less than rs2, it stores rs2 in the memory location. Finally it returns the smaller value in rd.%20%20Instruction	Type	Opcode	Funct3	Funct7	Operation%20lswc rd,rs1,rs2	R	0x2a	0x1	0x0	if (MEM[rs1] < rs2) MEM[rs1] = rs2, rd = MEM[rs1]%20%20%20%20 | 1
2025-10-12 20:56:21.683 | Query: RISCV 32bit %20How would I code this function? %20%20instructions:%20if MEM[rs1] < rs2:%20    MEM[rs1] = rs2%20rd = MEM[rs1]%20The instruction operations are as follows: First, it loads the value at in MEM[rs1]. Then, it compares the value with rs2. If the value in memory is less than rs2, it stores rs2 in the memory location. Finally it returns the smaller value in rd.%20%20Instruction	Type	Opcode	Funct3	Funct7	Operation%20lswc rd,rs1,rs2	R	0x2a	0x1	0x0	if (MEM[rs1] < rs2) MEM[rs1] = rs2, rd = MEM[rs1]%20%20%20%20 | 1
2025-10-12 20:57:05.243 | Query: RISCV 32bit %20How would I code this function in c? %20%20instructions:%20if MEM[rs1] < rs2:%20    MEM[rs1] = rs2%20rd = MEM[rs1]%20The instruction operations are as follows: First, it loads the value at in MEM[rs1]. Then, it compares the value with rs2. If the value in memory is less than rs2, it stores rs2 in the memory location. Finally it returns the smaller value in rd.%20%20Instruction	Type	Opcode	Funct3	Funct7	Operation%20lswc rd,rs1,rs2	R	0x2a	0x1	0x0	if (MEM[rs1] < rs2) MEM[rs1] = rs2, rd = MEM[rs1]%20%20%20%20 | 1
2025-10-12 21:11:23.669 | Query: RISCV 32bit %20Is there anything wrong with loadword? %20%20void execute_load(Instruction instruction, Processor *processor, Byte *memory) {%20    switch (instruction.itype.funct3) {%20        case 0x0:%20            // LB%20            processor->R[instruction.itype.rd] = sign_extend_number(%20                load(%20                    memory,%20                    (sWord) processor->R[instruction.itype.rs1] + %20                    ((sWord)sign_extend_number(instruction.itype.imm, 12)),%20                    LENGTH_BYTE%20                ), 8);%20            break;%20        case 0x1:%20            // LH%20            processor->R[instruction.itype.rd] = sign_extend_number(%20                load(%20                    memory,%20                    (sWord) processor->R[instruction.itype.rs1] + %20                    ((sWord)sign_extend_number(instruction.itype.imm, 12)),%20                    LENGTH_HALF_WORD%20                ), 16);%20            break;%20        case 0x2:%20            // LW%20            processor->R[instruction.itype.rd] = %20                load(%20                    memory,%20                    (sWord) processor->R[instruction.itype.rs1] + %20                    ((sWord) sign_extend_number(instruction.itype.imm, 12)),%20                    LENGTH_WORD%20                );%20            break;%20        default:%20            handle_invalid_instruction(instruction);%20            break;%20    }%20    processor->PC += 4; %20%20} | 1
2025-10-12 21:22:47.066 | Query: void execute_lui(Instruction instruction, Processor *processor) {%20    /* YOUR CODE HERE */%20    processor->R[instruction.utype.rd] = (Word)instruction.utype.imm << 12;%20}%20Can you figure out why this instruction 00001000: lui	x5, 1048575%20gives me < r 8=000000ff r 9=00000000 r10=00000000 r11=00000000%20instead of < r 8=ffffffff r 9=00000000 r10=00000000 r11=00000000 which is the expected output?%20(1048575 is stored as unsigned int imm : 20; | 1
2025-10-12 21:26:31.063 | Query: RISCV 32bit %20Debug why the function always saves the last 2 bytes of the previous register value.%20%20void execute_lswc(Instruction instruction, Processor *processor, Byte *memory) { %20    if (memory[processor->R[instruction.rtype.rs1]] < instruction.rtype.rs2) {%20        printf("MEM[RS1] is smaller\n\n");%20        memory[processor->R[instruction.rtype.rs1]] = instruction.rtype.rs2;%20    }%20    %20    processor->R[instruction.rtype.rd] = memory[processor->R[instruction.rtype.rs1]];%20    processor->PC += 4;%20}%20%20    struct {%20	unsigned int opcode : 7;%20	unsigned int rd : 5;%20	unsigned int funct3 : 3;%20	unsigned int rs1 : 5;%20	unsigned int rs2 : 5;%20	unsigned int funct7 : 7;%20    } rtype;%20    %20typedef struct {%20    Register R[32];%20    Register PC;%20} Processor;%20%20%20%20instructions:%2000001000: addi	x28, x0, 8%2000001004: addi	x28, x28, -1%2000001008: slli	x31, x28, 2%200000100c: add	x31, x11, x31%2000001010: lw	x10, 0(x31)%2000001014: lswc	x10, x31, x0%2000001018: lw	x10, 0(x31)%200000101c: bne	x28, x0, -24%2000001020: addi	x10, x0, 10%2000001024: ecall%20%20 | 1
2025-10-12 21:27:49.587 | Query: RISCV 32bit %20Debug why the function always saves the last 2 bytes of the previous register value.%20%20%20The address is stored in rs1 (assume offset is effectively 0). The instruction operations are as follows: First, it loads the value at in MEM[rs1]. Then, it compares the value with rs2. If the value in memory is less than rs2, it stores rs2 in the memory location. Finally it returns the smaller value in rd.%20%20Instruction	Type	Opcode	Funct3	Funct7	Operation%20lswc rd,rs1,rs2	R	0x2a	0x1	0x0	if (MEM[rs1] < rs2) MEM[rs1] = rs2, rd = MEM[rs1]%20%20void execute_lswc(Instruction instruction, Processor *processor, Byte *memory) { %20    if (memory[processor->R[instruction.rtype.rs1]] < instruction.rtype.rs2) {%20        printf("MEM[RS1] is smaller\n\n");%20        memory[processor->R[instruction.rtype.rs1]] = instruction.rtype.rs2;%20    }%20    %20    processor->R[instruction.rtype.rd] = memory[processor->R[instruction.rtype.rs1]];%20    processor->PC += 4;%20}%20%20    struct {%20	unsigned int opcode : 7;%20	unsigned int rd : 5;%20	unsigned int funct3 : 3;%20	unsigned int rs1 : 5;%20	unsigned int rs2 : 5;%20	unsigned int funct7 : 7;%20    } rtype;%20    %20typedef struct {%20    Register R[32];%20    Register PC;%20} Processor;%20%20%20%20instructions:%2000001000: addi	x28, x0, 8%2000001004: addi	x28, x28, -1%2000001008: slli	x31, x28, 2%200000100c: add	x31, x11, x31%2000001010: lw	x10, 0(x31)%2000001014: lswc	x10, x31, x0%2000001018: lw	x10, 0(x31)%200000101c: bne	x28, x0, -24%2000001020: addi	x10, x0, 10%2000001024: ecall%20%20 | 1
2025-10-13 01:57:15.706 | Query: My SFU VDI can't seem to push to github, is this normal? | 1
2025-10-13 01:57:22.957 | Query: SFU VDI can't seem to push to github, is this normal? | 1
2025-10-13 12:23:38.285 | Query: what is the convention for functions in risc-v | 1
2025-10-13 12:25:01.406 | Query: what is the convention for functions in risc-v, and can you show what it looks like in assembly to save the registers and then load them back at the end of the function | 1
2025-10-13 15:10:56.051 | Query: Getting this error in a riscv emulator program:%20%20expected: 00001020: srai  x5, x5, 31%20%20actual: 00001020: srai  x5, x5, 1055%20%20r 0=00000000 r 1=00000000 r 2=000efffc r 3=00003000 %20%20Invalid Instruction: 0x41f2d293%20%20ERROR: found an invalid instruction in the student trace file. Line: Invalid Instruction: 0x41f2d293%20%20Here is a code snippet that calls the function that prints these:%20case 0x5:%20            shiftOp = instruction.itype.imm >> 10;%20            switch(shiftOp) {%20                case 0x0:%20                    print_itype_except_load("srli", instruction, instruction.itype.imm & 0x1F);%20                    break;%20                case 0x1:%20                    print_itype_except_load("srai", instruction, instruction.itype.imm & 0x1F);%20                    break;%20                default:%20                    handle_invalid_instruction(instruction);%20                    break;%20            }%20            break; | 1
2025-10-13 15:56:54.852 | Query: explain this error:  error: a label can only be part of a statement and a declaration is not a statement%20 | 1
2025-10-13 15:57:24.687 | Query: utils.c:79:5: error: a label can only be part of a statement and a declaration is not a statement%20   79 |     unsigned int immBit11 = instruction_bits & 1U; | 1
2025-10-13 16:32:22.064 | Query: is lswc an itype? | 1
2025-10-13 16:33:32.964 | Query: is lswc an itype? how does it work? Isn't the imm value stored in itype only 12 bits while if we load rs1 from the memory it's 32 bits? | 1
2025-10-13 16:37:26.279 | Query: what does lswc store in rd? | 1
2025-10-13 16:37:40.209 | Query: what does lswc store in rd? what about rs1? | 1
2025-10-13 16:40:16.930 | Query: What is the funct 7 and op code of lswc? | 1
2025-10-13 16:40:19.552 | Query: What is the funct 7 and op code of lswc? | 1
2025-10-13 16:40:34.208 | Query: What are the funct 7, funct 3 and op code of lswc? | 1
2025-10-13 16:40:51.267 | Query: can you tell me what the funct 7 and opcode of lswc are? | 1
2025-10-13 16:43:43.106 | Query: How can I implement lswc? | 1
2025-10-13 17:06:12.105 | Query: How can I implement lswc? what are its opcode and funct 3? | 1
2025-10-13 17:30:49.532 | Query: When we execute lswc we get the offset by adding the immediate to rs1 and then checking if the value at mem[rs1] is greater than mem[rs1 + offset]?%20 | 1
2025-10-13 17:30:53.889 | Query: When we execute lswc we get the offset by adding the immediate to rs1 and then checking if the value at mem[rs1] is greater than mem[rs1 + offset]?%20 | 1
2025-10-13 17:31:05.594 | Query: Is it the case that when we execute lswc we get the offset by adding the immediate to rs1 and then checking if the value at mem[rs1] is greater than mem[rs1 + offset]?%20 | 1
2025-10-13 17:31:40.853 | Query: To execute lswc do I get the offset by adding the immediate to rs1 and then checking if the value at mem[rs1] is greater than mem[rs1 + offset]?%20 | 1
2025-10-14 01:10:40.970 | Query: can you please explain what part 3 of assignment 2 is asking us to do? Part 3 Custom Instructions%20DO NOT ATTEMPT THIS WITHOUT COMPLETING PART 1 and 2%20%20The RISC-V ISA enables the designer to customize and extend the ISA. It reserves bits in the opcode space so that designers can define new operations. We are going to add support for a custom instructions.%20%20if MEM[rs1] < rs2:%20    MEM[rs1] = rs2%20rd = MEM[rs1]%20In programs, custom load-modify-store is pretty common operation i.e., the instruction performs both a load and a store. The address is stored in rs1 (assume offset is effectively 0). The instruction operations are as follows: First, it loads the value at in MEM[rs1]. Then, it compares the value with rs2. If the value in memory is less than rs2, it stores rs2 in the memory location. Finally it returns the smaller value in rd.%20%20Instruction	Type	Opcode	Funct3	Funct7	Operation%20lswc rd,rs1,rs2	R	0x2a	0x1	0x0	if (MEM[rs1] < rs2) MEM[rs1] = rs2, rd = MEM[rs1]%20We are going to add one such new instruction to our disassembler (part 1) and emulator (part 2). You may need new or modify existing functions in part1.c, part2.c, utils.c.%20%20# The test file is custom%20$ ./riscv -d ./code/input/custom_lswc.input > ./code/out/custom_lswc.solution%20$ diff ./code/out/custom_lswc.solution ./code/ref/custom_lswc.solution%20$ ./riscv -t -e -r -s ./code/input/lswc_data.input  -a 0x8,0x3000 ./code/input/custom_lswc.input > code/out/custom_lswc.trace%20$ python3 part2_tester.py custom_lswc%20We have added two more options to the riscv emulator.%20%20Option	Description%20-s	Loads data from the file into the memory starting at 0x3000.%20-a	loads argument registers starting at a0. e.g., -a 0x8,0x3000 means set a0=0x8 and a1=0x3000 when program starts up | 1
2025-10-16 19:03:37.980 | Query: Riscv registers.%20Can s, a, and t registers be used interchangeably or do they have to be used for a specific purpose%20 | 1
2025-10-16 19:25:04.129 | Query: Debug why is this code segfaulting%20int blackbox(int n, int *array) {%20   /* Fill here */   %20   int s1, s4, s7;%20   s4 = 0;%20   s1 = 0x7fffffff;%20%20   while (s4 < n) {%20      s7 = s4 << 2;%20      s7 = array[s7];%20      if (s1 < s7) {%20         s1 = array[s1];%20      } else {%20         s1 = array[s7];%20      }%20      s4 = s4 + 2;%20%20   } ;%20%20   return s1;%20}%20 | 1
2025-10-16 20:21:33.103 | Query: Riscv assembly files.%20What are the .[name] lines do in the file?%20What is the differerence of .word 1 2 3 and .word 1 .word 2 .word 3 | 1
2025-10-17 00:18:12.722 | Query: Risv 32 bit.%20%20How to calculate addresses of symbols? What is the size of an instruction? | 1
2025-10-17 00:20:31.797 | Query: Risv 32 bit.%20How to calculate the addresses of the symbols.%20%20%20main:%20 add sp,sp -4%20 sw ra, 0 (sp)%20 mv a1, zero%20 li x9, 100%20 j check%20loop:%20 mul s2,x9,x9%20 add a1,a1,s2%20 add x9,x9,-1%20chk:%20 bnez x9, loop%20 la a0, str%20 jal printf%20 mv a0,zero%20 lw ra, 0(sp)%20 addi sp,sp,4%20 ret%20 | 1
2025-10-17 00:22:22.931 | Query: Risv 32 bit.%20How to calculate the addresses of a riscv instruction | 1
2025-10-17 23:05:16.740 | Query: Stack and Register Management:%20%20    Familiarity with which registers need to be saved during different points of function calls.%20    Calculating the number of bytes allocated on the stack.%20    Practice with stack frame allocation and register management in function calls.%20%20RISC-V Assembly:%20%20    Encoding RISC-V instructions manually.%20    Understanding instruction format fields such as rs1, rs2, rd, and immediate values.%20    Working with new instructions and understanding their behavior, including conditional statements.%20    Working with loads and stores (What is the difference between lw vs st and li)%20%20Floating-Point Representation:%20%20    Encoding and decoding IEEE-like floating-point values.%20    Calculating bias, minimum and maximum exponent values.%20    Understanding how to convert between binary and floating-point values.%20%20Can you provide me some practice questions for midterm 2%20 | 1
2025-10-18 11:27:52.275 | Query: For week 4 lecture video calling conventions. I felt like it was a pretty loaded video. For midterm 2 I need to know what is expected of me to perform because I am tight on time. Right now this is most of my notes from that video what else is important that I should know? %20**Course:** [[Week 4 - 295]]%20**Date:** 2025-10-18  %20**Tags:** #{{course}} %20%20---%20%20## Core Idea%20> A set of generally accepted rules as to which registers will be unchanged after a procedure call (jal) and which may be changed.%20%20---%20%20## Ideas%20%20### Risc V Calling Convention%20%20**Function Arguments**%20- The first 8 args are passed in registers a0-a7%20- If more than 8 arguments the extras are passed onto the stack%20%20**Return Values**%20- Returned in a0 if two the second one would be in a1%20%20**Layout of the stack frame**%20- Incoming arguments (Parameters)%20- Saved return address (ra)%20- Saved frame pointer (fp) links this frame to the callers%20- Saved registers (s0, s7) callee saved registers the function must restore before returning%20- Local variables temp data or arrays%20- Space for arguments to callee functions (If the function calls other functions)%20%20%20**Prologue**%20- Start of a stack frame allocation for a new function call (The setup)%20- Preserves any registers that must be restored later [[Saved Registers]]%20- Makes room for local variables %20- Sets up the frame pointer if needed%20%20**Epilogue**%20- This is the cleanup section at the end of the function %20- It restores the registers that were needed to be saved%20- Returns control to the calling function%20%20%20**Caller**%20- With have registers and values assigned to them and may want to call a function to do more operations%20- However if they are registers t0-t6 or a0-a7 its the Callers responsibility to save them because they are technically **temp** registers (**Volatile Registers**)%20	- t0-t6%20	- a0-a7%20	- Will change if **Callee** invokes another function%20**Callee**%20- When the callee is called its a basic convention that since we have finite registers its the callee's responsibility to save the register values of the caller before it uses the registers for its own operations. This is so that when the callee returns back to the caller the caller's registers are not all overwritten.%20	- This applies for the [[Saved Registers]]%20		- s0-s11%20		- sp%20		- ra%20- However the temp registers are fair game to be overwritten to save them is on the caller%20%20%20**Basic Philosophy behind this**%20- If every function saved everything we would waste time %20- If every function saved nothing we would lose data%20- **We find the fine line**%20%20%20**Hand Tracing Assembly Programs (Tracing Register Saving)**%20- Method is to go line by line writing what registers are saving what C variable%20%20%20 | 1
2025-10-18 11:32:18.704 | Query: For calling conventions week 4 can you provide a concise view of the concepts and what would be relevant for midterm 2 prep | 1
2025-10-18 11:33:44.548 | Query: For midterm 2 what should I put on my cheat sheet and what are the highest leverage things I can do to study for it | 1
2025-10-18 12:55:46.093 | Query: For week 5 Can you create a comprehensive guide for all relevant and main concepts that could come up on the midterm 2. I want detailed step by step notes that can easily be understood | 1
2025-10-18 12:56:08.011 | Query: For week 5 Can you create a comprehensive guide. I want detailed step by step notes that can easily be understood | 1
2025-10-18 12:56:43.814 | Query: For multi level and nested arrays in week 5 where we go over arrays in assembly can you break those concepts down | 1
2025-10-18 13:04:45.982 | Query: can you explain how to solve question 6 on quiz4 Answer questions for code below%20%201   .text%202   lw t0, 16(zero)%203   addi t1,zero,384%204   add t0,t0,t1%205   sw t0,16(zero)%206   add s11,s10,s8%207   exit:%20%20For line 6: add what is rs1 ? x26 (write answer as x register e.g., if zero answer is x0)%20For line 6: add what is rs2 ? x24 (write answer as x register e.g., if zero answer is x0)%20For line 6: add what is rd ? x27 (write answer as x register e.g. if zero answer is x0) | 1
2025-10-18 13:05:00.731 | Query: can you explain how to solve question 6 on quiz4 | 1
2025-10-18 13:05:10.804 | Query: Answer questions for code below%20%201   .text%202   lw t0, 16(zero)%203   addi t1,zero,384%204   add t0,t0,t1%205   sw t0,16(zero)%206   add s11,s10,s8%207   exit:%20%20For line 6: add what is rs1 ? x26 (write answer as x register e.g., if zero answer is x0)%20For line 6: add what is rs2 ? x24 (write answer as x register e.g., if zero answer is x0)%20For line 6: add what is rd ? x27 (write answer as x register e.g. if zero answer is x0) | 1
2025-10-18 13:05:23.914 | Query: Answer questions for code below%20%201   .text%202   lw t0, 16(zero)%203   addi t1,zero,384%204   add t0,t0,t1%205   sw t0,16(zero)%206   add s11,s10,s8%207   exit:%20%20For line 6: add what is rs1 ? x26 (write answer as x register e.g., if zero answer is x0)%20For line 6: add what is rs2 ? x24 (write answer as x register e.g., if zero answer is x0)%20For line 6: add what is rd ? x27 (write answer as x register e.g. if zero answer is x0) the answer for the third question is x30  | 1
2025-10-18 13:05:39.780 | Query: Answer questions for code below%20%201   .text%202   lw t0, 16(zero)%203   addi t1,zero,384%204   add t0,t0,t1%205   sw t0,16(zero)%206   add s11,s10,s8%207   exit:%20%20For line 6: add what is rs1 ? (write answer as x register e.g., if zero answer is x0)%20For line 6: add what is rs2 ? (write answer as x register e.g., if zero answer is x0)%20For line 6: add what is rd ? (write answer as x register e.g. if zero answer is x0)  | 1
2025-10-18 14:29:07.302 | Query: https://www.youtube.com/watch?v=JBglAgFhSBI&t=946s%20Reference that video "Linkers" and break it down for me all the detailed information so its as if I watched the video | 1
2025-10-18 15:54:09.473 | Query: Consider an IEEE-like floating point format Exponent: 8 bits, Mantissa: 5 bits What is the largest number? ?%20 | 1
2025-10-18 19:36:04.671 | Query: Riscv %20what is the purpose of fp%20 | 1
2025-10-18 19:37:07.371 | Query: Riscv %20why do some assembly files addi a negative number to the sp?%20 | 1
2025-10-18 19:43:52.085 | Query: Explain the assembly line of c file to assembly to obj and what each section does%20 | 1
2025-10-19 11:31:36.597 | Query: so in risc v when we are storing u type immediate the card stores that the value stored is imm[31:12] so are the digits 11:0 all 0s? | 1
2025-10-19 11:48:18.579 | Query: void print_rtype(char *name, Instruction instruction) {%20  printf(RTYPE_FORMAT, name, instruction.rtype.rd, instruction.rtype.rs1,%20         instruction.rtype.rs2);        // might cause problems%20  // who wrote this, wth, i dont think it was me%20  /* YOUR CODE HERE */%20}%20this is code that has been given to us(no clue why). would this cause problems? (Do we need to do something like sign extend the rd and the rs1? or is that only for offsets) | 1
2025-10-19 11:49:50.620 | Query: void print_rtype(char *name, Instruction instruction) {%20  printf(RTYPE_FORMAT, name, instruction.rtype.rd, instruction.rtype.rs1,%20         instruction.rtype.rs2);        // might cause problems%20  // who wrote this, wth, i dont think it was me%20  /* YOUR CODE HERE */%20}%20this is code that has been given to us(no clue why). would this cause problems? (Do we need to do something like sign extend the rd and the rs1? or is that only for offsets)(rd is just 5 bits, and rs1 is also just 4 bits, so should i be sign extending them or no..?) | 1
2025-10-19 12:01:00.693 | Query: how would you sign extend a number  | 1
2025-10-19 12:02:26.793 | Query: int sign_extend_number(unsigned int field, unsigned int n) {%20  /* YOUR CODE HERE */%20  //int sign = field >> n;%20  Word ans_1 = (field << (31-n));%20  int ans = (ans_1 >> (31-n));%20  return ans;%20}%20why do you think a code like this wouldn't work | 1
2025-10-19 12:03:43.402 | Query: /* Sign extends the given field to a 32-bit integer where field is%20 * interpreted an n-bit integer. */%20int sign_extend_number(unsigned int field, unsigned int n) {%20  /* YOUR CODE HERE */%20  //int sign = field >> n;%20  Word ans_1 = (field << (31-n));%20  int ans = (ans_1 >> (31-n));%20  return ans;%20}%20%20why do you think a code like this wouldn't work | 1
2025-10-19 12:37:45.403 | Query: is this code correct%20%20#define LUI_FORMAT "lui\tx%d, %d\n"%20typedef union {%20   struct {%20	unsigned int opcode : 7;%20	unsigned int rd : 5;%20	unsigned int imm : 20;%20    } utype;%20} Instruction;%20Instruction parse_instruction(uint32_t instruction_bits) {%20Instruction instruction;%20instruction.opcode = instruction_bits & ((1U << 7) - 1);%20instruction_bits >>= 7;%20switch (instruction.opcode) {%20case 0x37 :%20    // u type lu%20    instruction.utype.rd = instruction_bits & ((1U << 5) - 1);%20    instruction_bits >>= 5;%20%20    instruction.utype.imm = instruction_bits & ((1U << (32-12)) - 1);%20%20    break;%20}%20void print_lui(Instruction instruction) {%20    /* YOUR CODE HERE */%20    printf(LUI_FORMAT, instruction.utype.rd, (instruction.utype.imm << 12));%20} | 1
2025-10-19 12:38:31.928 | Query: is this code correct%20%20#define LUI_FORMAT "lui\tx%d, %d\n"%20typedef union {%20   struct {%20	unsigned int opcode : 7;%20	unsigned int rd : 5;%20	unsigned int imm : 20;%20    } utype;%20    uint32_t bits;%20} Instruction;%20Instruction parse_instruction(uint32_t instruction_bits) {%20Instruction instruction;%20instruction.opcode = instruction_bits & ((1U << 7) - 1);%20instruction_bits >>= 7;%20switch (instruction.opcode) {%20case 0x37 :%20    // u type lu%20    instruction.utype.rd = instruction_bits & ((1U << 5) - 1);%20    instruction_bits >>= 5;%20%20    instruction.utype.imm = instruction_bits & ((1U << (32-12)) - 1);%20%20    break;%20}%20void print_lui(Instruction instruction) {%20    /* YOUR CODE HERE */%20    printf(LUI_FORMAT, instruction.utype.rd, (instruction.utype.imm << 12));%20} | 1
2025-10-19 12:38:55.409 | Query: is this code correct%20%20#define LUI_FORMAT "lui\tx%d, %d\n"%20typedef union {%20struct {%20	unsigned int opcode : 7;%20        unsigned int rest : 25;%20    };%20    %20   struct {%20	unsigned int opcode : 7;%20	unsigned int rd : 5;%20	unsigned int imm : 20;%20    } utype;%20    uint32_t bits;%20} Instruction;%20Instruction parse_instruction(uint32_t instruction_bits) {%20Instruction instruction;%20instruction.opcode = instruction_bits & ((1U << 7) - 1);%20instruction_bits >>= 7;%20switch (instruction.opcode) {%20case 0x37 :%20    // u type lu%20    instruction.utype.rd = instruction_bits & ((1U << 5) - 1);%20    instruction_bits >>= 5;%20%20    instruction.utype.imm = instruction_bits & ((1U << (32-12)) - 1);%20%20    break;%20}%20void print_lui(Instruction instruction) {%20    /* YOUR CODE HERE */%20    printf(LUI_FORMAT, instruction.utype.rd, (instruction.utype.imm << 12));%20} | 1
2025-10-19 12:43:00.558 | Query: is this code correct%20%20#define LUI_FORMAT "lui\tx%d, %d\n"%20typedef union {%20struct {%20	unsigned int opcode : 7;%20        unsigned int rest : 25;%20    };%20    %20   struct {%20	unsigned int opcode : 7;%20	unsigned int rd : 5;%20	unsigned int imm : 20;%20    } utype;%20    uint32_t bits;%20} Instruction;%20Instruction parse_instruction(uint32_t instruction_bits) {%20Instruction instruction;%20instruction.opcode = instruction_bits & ((1U << 7) - 1);%20instruction_bits >>= 7;%20switch (instruction.opcode) {%20case 0x37 :%20    // u type lu%20    instruction.utype.rd = instruction_bits & ((1U << 5) - 1);%20    instruction_bits >>= 5;%20%20    instruction.utype.imm = instruction_bits & ((1U << (32-12)) - 1);%20%20    break;%20}%20void print_lui(Instruction instruction) {%20    /* YOUR CODE HERE */%20    printf(LUI_FORMAT, instruction.utype.rd, (instruction.utype.imm << 12));%20}%20%20(ignore some stuff, i just copy pasted parts of the code out, that is not the complete union and so on, just think about the logic of things, how is the logic wrong) | 1
2025-10-19 12:44:39.025 | Query: is this code correct%20%20#define LUI_FORMAT "lui\tx%d, %d\n"%20typedef union {%20struct {%20	unsigned int opcode : 7;%20        unsigned int rest : 25;%20    };%20    %20   struct {%20	unsigned int opcode : 7;%20	unsigned int rd : 5;%20	unsigned int imm : 20;%20    } utype;%20    uint32_t bits;%20} Instruction;%20Instruction parse_instruction(uint32_t instruction_bits) {%20Instruction instruction;%20instruction.opcode = instruction_bits & ((1U << 7) - 1);%20instruction_bits >>= 7; // removed the opcode, only imm and rd left%20switch (instruction.opcode) {%20case 0x37 :%20    // u type lu%20    instruction.utype.rd = instruction_bits & ((1U << 5) - 1);%20    instruction_bits >>= 5; // removed the rd, only imm left%20%20    instruction.utype.imm = instruction_bits & ((1U << (32-12)) - 1);%20%20    break;%20}%20void print_lui(Instruction instruction) {%20    /* YOUR CODE HERE */%20    printf(LUI_FORMAT, instruction.utype.rd, (instruction.utype.imm << 12));%20}%20%20(ignore some stuff, i just copy pasted parts of the code out, that is not the complete union and so on, just think about the logic of things, how is the logic wrong) | 1
2025-10-19 12:45:31.771 | Query: is this code correct%20%20#define LUI_FORMAT "lui\tx%d, %d\n"%20typedef union {%20struct {%20	unsigned int opcode : 7;%20        unsigned int rest : 25;%20    };%20    %20   struct {%20	unsigned int opcode : 7;%20	unsigned int rd : 5;%20	unsigned int imm : 20;%20    } utype;%20    uint32_t bits;%20} Instruction;%20Instruction parse_instruction(uint32_t instruction_bits) {%20Instruction instruction;%20instruction.opcode = instruction_bits & ((1U << 7) - 1);%20instruction_bits >>= 7; // removed the opcode, only imm and rd left%20switch (instruction.opcode) {%20case 0x37 :%20    // u type lu%20    instruction.utype.rd = instruction_bits & ((1U << 5) - 1);%20    instruction_bits >>= 5; // removed the rd, only imm left%20%20    instruction.utype.imm = instruction_bits & ((1U << (32-12)) - 1);%20%20    break;%20}%20}%20void print_lui(Instruction instruction) {%20    /* YOUR CODE HERE */%20    printf(LUI_FORMAT, instruction.utype.rd, (instruction.utype.imm << 12));%20}%20%20(ignore some stuff, i just copy pasted parts of the code out, that is not the complete union and so on, just think about the logic of things, how is the logic wrong) | 1
2025-10-19 12:46:11.114 | Query: is this code correct%20%20#define LUI_FORMAT "lui\tx%d, %d\n"%20typedef union {%20struct {%20	unsigned int opcode : 7;%20        unsigned int rest : 25;%20    };%20    %20   struct {%20	unsigned int opcode : 7;%20	unsigned int rd : 5;%20	unsigned int imm : 20;%20    } utype;%20    uint32_t bits;%20} Instruction;%20Instruction parse_instruction(uint32_t instruction_bits) {%20Instruction instruction;%20instruction.opcode = instruction_bits & ((1U << 7) - 1);%20instruction_bits >>= 7; // removed the opcode, only imm and rd left%20switch (instruction.opcode) {%20case 0x37 :%20    // u type lu%20    instruction.utype.rd = instruction_bits & ((1U << 5) - 1);%20    instruction_bits >>= 5; // removed the rd, only imm left%20%20    instruction.utype.imm = instruction_bits & ((1U << (32-12)) - 1);%20%20    break;%20}%20}%20void print_lui(Instruction instruction) {%20    /* YOUR CODE HERE */%20    printf(LUI_FORMAT, instruction.utype.rd, (instruction.utype.imm << 12));%20}%20%20(ignore some stuff, i just copy pasted parts of the code out, that is not the complete union and so on, just think about the logic of things, how is the logic wrong)%20HOW IS 32 - 12 WRONG, TELL ME WHAT IS THE VALUE OF 32 - 12 | 1
2025-10-19 12:47:14.345 | Query: is this code correct%20%20#define LUI_FORMAT "lui\tx%d, %d\n"%20typedef union {%20struct {%20	unsigned int opcode : 7;%20        unsigned int rest : 25;%20    };%20    %20   struct {%20	unsigned int opcode : 7;%20	unsigned int rd : 5;%20	unsigned int imm : 20;%20    } utype;%20    uint32_t bits;%20} Instruction;%20Instruction parse_instruction(uint32_t instruction_bits) {%20Instruction instruction;%20instruction.opcode = instruction_bits & ((1U << 7) - 1);%20instruction_bits >>= 7; // removed the opcode, only imm and rd left%20switch (instruction.opcode) {%20case 0x37 :%20    // u type lu%20    instruction.utype.rd = instruction_bits & ((1U << 5) - 1);%20    instruction_bits >>= 5; // removed the rd, only imm left%20%20    instruction.utype.imm = instruction_bits & ((1U << (32-12)) - 1);%20%20    break;%20}%20}%20void print_lui(Instruction instruction) {%20    /* YOUR CODE HERE */%20    printf(LUI_FORMAT, instruction.utype.rd, (instruction.utype.imm << 12));%20}%20%20(ignore some stuff, i just copy pasted parts of the code out, that is not the complete union and so on, just think about the logic of things, how is the logic wrong)%20HOW IS 32 - 12 WRONG, TELL ME WHAT IS THE VALUE OF 32 - 12%20and now, is the code right | 1
2025-10-19 13:05:07.341 | Query: %20void print_lui(Instruction instruction) {%20    /* YOUR CODE HERE */%20    printf(LUI_FORMAT, instruction.utype.rd, (instruction.utype.imm));%20    %20}%20THIS works, but%20%20void print_lui(Instruction instruction) {%20    /* YOUR CODE HERE */%20    printf(LUI_FORMAT, instruction.utype.rd, (instruction.utype.imm<<11));%20    %20}%20this doesn't %20why exactly do we not need to shift the bits | 1
2025-10-19 13:35:56.652 | Query: what exactly is 'mulh' instruction | 1
2025-10-19 13:45:23.693 | Query: difference between shift right logical/arithmetic, which one is which(i know what it means, but which one does it apply to is what i forgot) | 1
2025-10-19 13:56:05.480 | Query: full form of stli, slli and so on | 1
2025-10-19 13:58:12.939 | Query: full form of slti, slli and so on | 1
2025-10-19 14:02:52.590 | Query: in the case of srli, is there a thing such as 'handling both logical and arithmetic' like, we just shift the word as it is right...? | 1
2025-10-19 14:16:08.754 | Query: can you explain this to me%20for(i=p->R[11];i<MEMORY_SPACE && load(memory,i,LENGTH_BYTE);i++) { // what does this even mean T-T%20                printf("%c",load(memory,i,LENGTH_BYTE));%20            } | 1
2025-10-19 14:43:22.840 | Query: How does load work in riscv | 1
2025-10-19 14:44:59.209 | Query: how does MEM[smth] work  | 1
2025-10-19 14:45:31.711 | Query: how does MEM[smth] work , is it just *smth | 1
2025-10-19 14:47:04.032 | Query: how do *we* implement MEM[smth] when we build an emulator | 1
2025-10-19 14:48:41.842 | Query: Riscv 32bit %20what is the imm of jal? Do empty lines count as addresses, for example jal imm set to end?%20%20Instructions:%20loop:%20bgt t0, x0, end%20lw s0, 0(a0)%20addi s0, s0, 1%20sw s0, 0(a0)%20addi a0, a0, 4%20addi t0, t0, -1%20jal x0, loop%20%20end: | 1
2025-10-19 14:49:47.625 | Query: Riscv 32bit %20what is the imm of jal? Does it the count start 0 at jal or count jal inclusive%20%20Instructions:%20loop:%20bgt t0, x0, end%20lw s0, 0(a0)%20addi s0, s0, 1%20sw s0, 0(a0)%20addi a0, a0, 4%20addi t0, t0, -1%20jal x0, loop%20%20end: | 1
2025-10-19 14:50:11.626 | Query: Riscv 32bit %20what is the imm of jal? Does it the count start 0 at jal or count jal inclusive Is loop its own address?%20%20Instructions:%20loop:%20bgt t0, x0, end%20lw s0, 0(a0)%20addi s0, s0, 1%20sw s0, 0(a0)%20addi a0, a0, 4%20addi t0, t0, -1%20jal x0, loop%20%20end: | 1
2025-10-19 14:53:24.545 | Query: processor->R[instruction.itype.rd] = sign_extend_number((*((Address *)processor->R[instruction.itype.rs1]) + (sWord)(sign_extend_number(instruction.itype.imm,12))),LENGTH_BYTE);%20%20does this look alright | 1
2025-10-19 15:11:42.094 | Query: M[rs1+imm][0:7] = rs2[0:7]%20explain | 1
2025-10-19 15:12:55.597 | Query: M[rs1+imm][0:7] = rs2[0:7]%20explain%20%20(like, isnt rs2 just 4 bits?? | 1
2025-10-19 15:16:22.298 | Query: M[rs1+imm][0:7] = rs2[0:7]%20explain%20%20smth like this?%20%20            *(Address *)(get_store_offset(instruction)) =%20                (sWord)processor->R[instruction.stype.rs2] & (1U<< 7 - 1);%20or%20%20            *(Address *)(get_store_offset(instruction)) =%20                (sWord)processor->R[instruction.stype.rs2] & (1U<< 8 - 1); | 1
2025-10-19 15:18:00.238 | Query: M[rs1+imm][0:7] = rs2[0:7]%20explain%20%20smth like this?%20%20            *(Address *)(get_store_offset(instruction)) =%20                (sWord)processor->R[instruction.stype.rs2] & (1U<< 9 - 1);%20(do not give me a mask,fix my existing mask if its wrong) | 1
2025-10-19 15:18:25.840 | Query: M[rs1+imm][0:7] = rs2[0:7]%20explain%20%20smth like this?%20(dont give me 0xff, tell me if this mask is right)%20            *(Address *)(get_store_offset(instruction)) =%20                (sWord)processor->R[instruction.stype.rs2] & (1U<< 9 - 1); | 1
2025-10-19 15:18:47.513 | Query: M[rs1+imm][0:7] = rs2[0:7]%20explain%20%20(dont give me 0xff, tell me if this mask is right)%20            *(Address *)(get_store_offset(instruction)) =%20                (sWord)processor->R[instruction.stype.rs2] & (1U<< 8 - 1); | 1
2025-10-19 15:30:32.449 | Query: void store(Byte *memory, Address address, Alignment alignment, Word value) %20%20store(): This function takes an address, a size, and a value and stores the first -size- bytes of the given value at the given address%20%20explain | 1
2025-10-19 15:31:31.042 | Query: void store(Byte *memory, Address address, Alignment alignment, Word value) %20%20store(): This function takes an address, a size, and a value and stores the first -size- bytes of the given value at the given address%20%20explain%20%20what is the 'size' here, | 1
2025-10-19 15:32:05.906 | Query: void store(Byte *memory, Address address, Alignment alignment, Word value) %20%20store(): This function takes an address, a size, and a value and stores the first -size- bytes of the given value at the given address%20%20explain%20%20what is the 'size' here, (which input referes to size) | 1
2025-10-19 15:32:14.088 | Query: void store(Byte *memory, Address address, Alignment alignment, Word value) %20%20store(): This function takes an address, a size, and a value and stores the first -size- bytes of the given value at the given address%20%20explain%20%20what is the 'size' here, (which input referes to size) | 1
2025-10-19 22:03:46.844 | Query: what is the lswc instruction(custom instruction for assignment 2 part 3)%20 | 1
2025-10-19 22:04:55.424 | Query: what is the lswc instruction(custom instruction for assignment 2 part 3)%20Part 3 Custom Instructions%20DO NOT ATTEMPT THIS WITHOUT COMPLETING PART 1 and 2%20%20The RISC-V ISA enables the designer to customize and extend the ISA. It reserves bits in the opcode space so that designers can define new operations. We are going to add support for a custom instructions.%20%20if MEM[rs1] < rs2:%20    MEM[rs1] = rs2%20rd = MEM[rs1]%20In programs, custom load-modify-store is pretty common operation i.e., the instruction performs both a load and a store. The address is stored in rs1 (assume offset is effectively 0). The instruction operations are as follows: First, it loads the value at in MEM[rs1]. Then, it compares the value with rs2. If the value in memory is less than rs2, it stores rs2 in the memory location. Finally it returns the smaller value in rd.%20%20Instruction	Type	Opcode	Funct3	Funct7	Operation%20lswc rd,rs1,rs2	R	0x2a	0x1	0x0	if (MEM[rs1] < rs2) MEM[rs1] = rs2, rd = MEM[rs1]%20We are going to add one such new instruction to our disassembler (part 1) and emulator (part 2). You may need new or modify existing functions in part1.c, part2.c, utils.c.%20%20# The test file is custom%20$ ./riscv -d ./code/input/custom_lswc.input > ./code/out/custom_lswc.solution%20$ diff ./code/out/custom_lswc.solution ./code/ref/custom_lswc.solution%20$ ./riscv -t -e -r -s ./code/input/lswc_data.input  -a 0x8,0x3000 ./code/input/custom_lswc.input > code/out/custom_lswc.trace%20$ python3 part2_tester.py custom_lswc%20We have added two more options to the riscv emulator.%20%20Option	Description%20-s	Loads data from the file into the memory starting at 0x3000.%20-a	loads argument registers starting at a0. e.g., -a 0x8,0x3000 means set a0=0x8 and a1=0x3000 when program starts up%20Grading%20Congrats. You are now ready to receive your tentative grade.%20%20$ cd $REPO # $REPO refers to the top of your cloned repo.%20$ bash ./scripts/localci.sh # run from the repo folder%20# Check if SUCCESS OR FAILED was dumped by scripts%20# There will be a _Grade.json (this is your tentative grade). The file is in json format.%20# The mark component in each module indicates your score for that portion.%20# LOG.md contains the log of your runs. This might give you more information.%20This grade is only tentative. Based on additional test cases in our evaluation, you could score less points.%20%20Test	P1 Points	P2 Points%20R	12 (rpart1)	0 (rpart2)%20Ri	0 (rpart1)	12 (rpart2)%20I (Ls are also included)	24 (ipart1)	24 (ipart2)%20S	12 (spart1)	12 (spart2)%20SB	12 (sbpart1)	12 (sbpart2)%20U	12 (upart1)	12 (upart2)%20J	12 (ujpart1)	12 (ujpart2)%20Simple	30	30%20Multiply	30	30%20Random	30	30%20lswc	30	120%20FAQs and Suggestions for TA%20What does union and bitfield mean?%20What is struct Instruction ?%20What is struct Processor ?%20What is MEMORY_SPACE ?%20Debugging hints%20Symptom	What you should check%20Branch and Jump offsets are incorrect	Check the fields extracted against the example shown here. (https://www.cs.sfu.ca/~ashriram/Courses/CS295//hw/hw2_debug.html)%20Invalid instructuctions in part 2. Passed part 1 though	Check your load():line 450 in part2.c loads() of words need to function correctly for instruction fetch to work. Also see lab 5 video%20Running (-r) does not seem to make progress.	Check your program counter. Program counter needs to be updated on each step%20Register values appear wrong in programs	Check your arithmetic instructions (if those appear correct), then check your load addresses in load():line 450 part2.c, followed by memory values%20ERROR: student trace finished before reference trace	Pass -e when running part2. Also check to ensure you have handled all op cases%20Instruction execution mixed up. SRLI shifts but then also adds 1	Check if a break statement is missing in switch case%20Segfault error due to reading past instructions	See if you are passing -e option when running code. It should be used only for simple,multiply,random%20Having trouble with jump instructions	Read (https://www.cs.sfu.ca/~ashriram/Courses/CS295//assets/notebooks/RISCV/riscv-harry.pdf) page 71-74%20Having trouble with shifts	Check the actual shift values you see and compare against the instructions in ref/*.solution. Also read (https://www.cs.sfu.ca/~ashriram/Courses/CS295//assets/notebooks/RISCV/riscv-harry.pdf) - Page 54%20Having trouble with loads and stores (multiple bytes)	Check if you are reading the appropriate bytes and sign extending it. Also read (https://www.cs.sfu.ca/~ashriram/Courses/CS295//assets/notebooks/RISCV/riscv-harry.pdf) - Page 78%20Every instruction mismatches for program and custom	Check if you have included -v and -a flags to initialize registers%20TA Help%20We have a strict ‘No Print No Help` policy. Please refer to the policy and assignment page. Here is a suggested list of things to print for this assignment before you show up to a TA meeting%20%20PC and register values%20If you are asking about jumps, shifts etc then the fields of the ISA have to be printed in binary%20For load and store you have to print out address, byte, ` of memory locations print_bytes%20 | 1
2025-10-19 22:08:14.744 | Query: what is the lswc instruction(custom instruction for assignment 2 part 3)%20Part 3 Custom Instructions%20DO NOT ATTEMPT THIS WITHOUT COMPLETING PART 1 and 2%20%20The RISC-V ISA enables the designer to customize and extend the ISA. It reserves bits in the opcode space so that designers can define new operations. We are going to add support for a custom instructions.%20%20if MEM[rs1] < rs2:%20    MEM[rs1] = rs2%20rd = MEM[rs1]%20In programs, custom load-modify-store is pretty common operation i.e., the instruction performs both a load and a store. The address is stored in rs1 (assume offset is effectively 0). The instruction operations are as follows: First, it loads the value at in MEM[rs1]. Then, it compares the value with rs2. If the value in memory is less than rs2, it stores rs2 in the memory location. Finally it returns the smaller value in rd.%20%20Instruction	Type	Opcode	Funct3	Funct7	Operation%20lswc rd,rs1,rs2	R	0x2a	0x1	0x0	if (MEM[rs1] < rs2) MEM[rs1] = rs2, rd = MEM[rs1]%20We are going to add one such new instruction to our disassembler (part 1) and emulator (part 2). You may need new or modify existing functions in part1.c, part2.c, utils.c.%20%20# The test file is custom%20$ ./riscv -d ./code/input/custom_lswc.input > ./code/out/custom_lswc.solution%20$ diff ./code/out/custom_lswc.solution ./code/ref/custom_lswc.solution%20$ ./riscv -t -e -r -s ./code/input/lswc_data.input  -a 0x8,0x3000 ./code/input/custom_lswc.input > code/out/custom_lswc.trace%20$ python3 part2_tester.py custom_lswc%20We have added two more options to the riscv emulator.%20%20Option	Description%20-s	Loads data from the file into the memory starting at 0x3000.%20-a	loads argument registers starting at a0. e.g., -a 0x8,0x3000 means set a0=0x8 and a1=0x3000 when program starts up%20Grading%20Congrats. You are now ready to receive your tentative grade.%20%20$ cd $REPO # $REPO refers to the top of your cloned repo.%20$ bash ./scripts/localci.sh # run from the repo folder%20# Check if SUCCESS OR FAILED was dumped by scripts%20# There will be a _Grade.json (this is your tentative grade). The file is in json format.%20# The mark component in each module indicates your score for that portion.%20# LOG.md contains the log of your runs. This might give you more information.%20This grade is only tentative. Based on additional test cases in our evaluation, you could score less points.%20%20Address address = (Address)processor->R[instruction.rtype.rs1];%20    Word value_rs1 = load(memory, address, LENGTH_WORD);%20    Word rs2_ = processor->R[instruction.rtype.rs2];%20    switch (instruction.rtype.funct3) {%20        case 0x1:%20        switch (instruction.rtype.funct7)%20        {%20            case 0x0:%20                if ((sWord)value_rs1 < (sWord)(rs2_)) {%20                // if ((sWord)value_rs1 < (sWord)(instruction.rtype.rs2)) {%20                    store(memory,address,LENGTH_WORD,rs2_);%20                    processor->R[instruction.rtype.rd] = value_rs1;%20                }%20                else {%20                    processor->R[instruction.rtype.rd] = value_rs1;%20                }%20    %20does this snippet of code looks correct in logic | 1
2025-10-20 00:49:35.720 | Query: Riscv 32bits.%20When calculating offset for instructions, which types need to be multiplied y 2 | 1
2025-10-20 00:50:25.996 | Query: Riscv 32bits.%20Are branch instructions the only instructions where offset is multiplied by 2? What about jump | 1
2025-10-20 03:21:00.637 | Query: Jump and branch assembly offset calculation | 1
2025-10-20 11:37:47.763 | Query: explain the compiling and linking process in detail | 1
2025-10-22 11:59:41.643 | Query: Although the spec is quite long, please make sure to read through the whole thing as it contains a lot of important information about the functions provided, running Venus, and testing your code%20what does the prof mean by 'spec' here | 1
2025-10-22 17:53:17.819 | Query: in the riscv convention, are registers a0-a7 saved during functions%20 | 1
2025-10-24 10:26:40.300 | Query: in assignment three, when doing sparse matrix-dense matrix multiplication, how do we know the number of columns in the dense matrix%20 | 1
2025-10-24 16:26:36.839 | Query: how to make a for-loop in assembly | 1
2025-10-24 16:35:15.808 | Query: how to make a for-loop that accesses array in assembly | 1
2025-10-24 17:04:22.106 | Query: AssemblerError: dot.s:31: label a0 used but not defined%20la t3, a0 | 1
2025-10-24 17:05:00.517 | Query: how to load a0 register into a temp register | 1
2025-10-24 18:24:32.767 | Query: what is sparse dot product | 1
2025-10-25 14:33:47.249 | Query: What is the purpose of addi sp, sp, -8 and addi sp, sp, 8? | 1
2025-10-25 14:35:02.305 | Query: What is the purpose of addi sp, sp, -8 and addi sp, sp, 8?%20How to access that space and what would it be used for? | 1
2025-10-25 15:01:39.880 | Query: how do you check if the proper number of bytes has been allocated in assembly? | 1
2025-10-25 15:05:20.333 | Query: In read_bin.s, implement the read_bin function which uses the file operations we described above to read a binary matrix file into memory. If any file operation fails or doesn’t return the expected number of bytes, exit the program with exit code 1. The code to do this has been provided for you, simply jump to the eof_or_error label at the end of the file.%20%20how to implement this | 1
2025-10-25 15:24:52.267 | Query: What are the RISCV calling conventions%20 | 1
2025-10-25 15:26:22.566 | Query: what register should be used for array loop index? s or t | 1
2025-10-25 15:41:59.744 | Query: how to implement malloc error checking | 1
2025-10-25 17:28:03.490 | Query: how to check file path riscv? how to allocate memory in riscv? | 1
2025-10-26 16:30:37.503 | Query: how many bytes does lw load | 1
2025-10-26 17:33:20.321 | Query: How do I check the file path of this file in Assembly?%20file_path: .asciiz "./test_files/test_input.bin" | 1
2025-10-26 17:37:26.097 | Query: Which lecture discusses about syscalls? | 1
2025-10-26 18:38:00.412 | Query: when returning a pointer to a1 in ricsv, what instruction should be used?%20pointer is s3. Would mv, lw, or sw work   | 1
2025-10-26 18:38:41.168 | Query: when returning a pointer to a1 in ricsv, how would I get the value from it | 1
2025-10-27 11:20:45.564 | Query: for assignment 3, for task 5 SPMV, when it says "The filepaths for the v, m will all be passed in on the command line" how should we handle that | 1
2025-10-27 11:21:11.004 | Query: for assignment 3, for task 5 SPMV, when it says "The filepaths for the v, m will all be passed in on the command line" how should we handle that in assembly | 1
2025-10-27 11:34:06.630 | Query: for assignment 3, for task 5 SPMV, when it says "The filepaths for the v, m will all be passed in on the command line" it also says if the wrong number of command line arguments is found we should exit with error code 3, using help from utils.c. are we supposed to use the exit2 function and just load 3 into a1 so it says its exiting with error code 3? | 1
2025-10-27 19:50:16.956 | Query: riscv if statement | 1
2025-10-27 20:23:32.365 | Query: how to initialize a 3 int pointer to 0.%20Riscv%20 | 1
2025-10-27 20:24:07.502 | Query: how to initialize a int array pointer to 0.%20Riscv%20 | 1
2025-10-27 20:24:46.224 | Query: how to initialize all ints in int array pointer to 0.%20Riscv%20 | 1
2025-10-27 20:56:01.668 | Query: Riscv %20How to check for end of array | 1
2025-10-27 20:58:32.506 | Query: Riscv %20How to check for end of char array | 1
2025-10-27 21:03:13.617 | Query: Riscv %20What are char arrays ended with | 1
2025-10-27 21:03:41.069 | Query: Riscv %20What are char arrays ended with? How to do a branch instruction finding it%20 | 1
2025-10-27 21:11:47.022 | Query: Riscv %202 arguments v and m%20What is the argc%20 | 1
2025-10-27 21:12:49.379 | Query: Riscv %202 arguments%20main.s <VECTOR_PATH> <MATRIX_COO_PATH> %20What is the argc%20 | 1
2025-10-27 21:25:06.486 | Query: Riscv %20    # =====================================%20    # COMMAND LINE ARGUMENTS%20    # =====================================%20    # Args:%20    #   a0: int argc%20    #   a1: char** argv%20    #%20    # Usage:%20    #   main.s <VECTOR_PATH> <MATRIX_COO_PATH> %20%20How to get the access of the paths | 1
2025-10-28 00:04:15.925 | Query: # =====================================%20# LOAD Vector.%20# =====================================%20    lw a0, 0(s0)%20    jal read_bin%20%20    mv s1, a0   # 2Bfreed; ptr to vector%20    mv s2, a1   # 2Bfreed; ptr to row%20    mv s3, a2   # 2Bfreed; ptr to col%20# =====================================%20# LOAD COO Matrix%20# =====================================%20    lw a0, 4(s0)%20    jal read_coo_matrix%20    mv s4, a0   # 2Bfreed; ptr to coo matrix%20    mv s5, a1   # 2Bfreed; ptr to row%20    mv s6, a2   # 2Bfreed; ptr to col%20    mv s7, a3   # 2Bfreed; ptr to nnz%20%20%20    # Allocate dense result vector (# rows of matrix m)%20    lw a0, 0(s5)%20    slli a0, a0, 2%20    jal malloc%20    mv s8, a0   # 2Bfreed; ptr to result %20%20    # Loading args and calling spmv%20    mv a0, s4       # ptr to coo matrix%20    lw a1, 0(s5)    # loads num of rows for coo matrix%20    lw a2, 0(s6)    # loads num of cols for coo matrix%20    mv a3, s1       # ptr to vector%20    lw a4, 0(s2)    # loads num of rows for vector%20    lw a5, 0(s3)    # loads num of cols for vecotr%20    mv a6, s8       # ptr to result%20    lw a7, 0(s7)    # loads num of nnz for coo matrix%20    jal spmv%20%20Apparently I'm loading the arguments incorrectly. What am I doing wrong? | 1
2025-10-28 05:50:25.318 | Query: What could cause unexpected large numbers in riscv assembly%20 | 1
2025-10-28 06:08:16.808 | Query: My output is unexpectedly 2^28. What might be the issue?%20 | 1
2025-10-28 06:10:24.818 | Query: My output is unexpectedly 2^28. What might be the issue?%20.globl sdot%20%20.text%20# =======================================================%20# FUNCTION: Dot product of 1 sparse vectors and 1 dense vector%20# Arguments:%20#   a0 is the pointer to the start of v0 (sparse, coo format)%20#   a1 is the pointer to the start of v1 (dense)%20#   a2 is the number of non-zeros in vector v0%20# Returns:%20#   a0 is the sparse dot product of v0 and v1%20# =======================================================%20#%20# struct coo {%20#   int row;%20#   int index;%20#   int val;%20# };   %20# Since these are vectors row = 0 always for v0.%20#for (int i = 0 i < nnz; i++) {%20#    sum = sum + v0[i].value * v1[coo[i].index];%20# }%20sdot:%20    # Prologue    %20    addi sp, sp, -16%20    sw ra, 0(sp)%20    # Save arguments %20    # Set strides. Note that v0 is struct. v1 is array.%20    li t0, 12 # size of v0 element (struct) = 12%20    # Set loop index%20    li t2, 0%20    # Set accumulation to 0%20    li t3, 0%20%20loop_start:%20%20    # Check outer loop condition%20    beq t2, a2, loop_end%20    # load v0[i].value. The actual value is located at offset  from start of coo entry%20    lw t4, 8(a0)%20    # What is the index of the coo element?%20    lw t5, 4(a0)%20    # Lookup corresponding index in dense vector%20    slli t5, t5, 2%20    add t1, a1, t5%20    # Load v1[coo[i].index]%20    lw t6, 0(t1)%20    # Multiply and accumulate%20    mul t4, t4, t6%20    add t3, t3, t4%20    # Bump ptr to coo entry%20    add a0, a0, t0%20    # Increment loop index%20    addi t2, t2, 1%20    %20    j loop_start%20%20loop_end:%20	mv a0, t3 # >a0 is the sparse dot product of v0 and v1%20    # Epilogue%20    lw ra, 0(sp)%20    addi sp, sp, 16%20%20    ret%20%20%20 | 1
2025-10-28 12:29:10.323 | Query: If I have a pointer stored at a register, I have to use the lw instruction to actually read the number, right? | 1
2025-10-28 12:31:52.221 | Query: in assembly, do i have use lw twice on a double pointer? | 1
2025-10-28 13:01:34.686 | Query: .text%20main:%20    # =====================================%20    # COMMAND LINE ARGUMENTS%20    # =====================================%20    # Args:%20    #   a0: int argc%20    #   a1: char** argv%20    #%20    # Usage:%20    #   main.s <VECTOR_PATH> <MATRIX_COO_PATH> %20%20    # Exit if incorrect number of command line args%20    li t0 3%20    bne a0, t0, incorrect_args%20    mv s0, a1%20    %20# =====================================%20# LOAD Vector.%20# =====================================%20    lw a0, 0(s0)%20    lw a0, 0(a0)%20    jal read_bin%20%20    mv s1, a0   # 2Bfreed; ptr to vector%20    mv s2, a1   # 2Bfreed; ptr to row%20    mv s3, a2   # 2Bfreed; ptr to col%20# =====================================%20# LOAD COO Matrix%20# =====================================%20    lw a0, 4(s0)%20    lw a0, 0(a0)%20    jal read_coo_matrix%20    mv s4, a0   # 2Bfreed; ptr to coo matrix%20    mv s5, a1   # 2Bfreed; ptr to row%20    mv s6, a2   # 2Bfreed; ptr to col%20    mv s7, a3   # 2Bfreed; ptr to nnz%20%20When I only load the first pointer, I get error 2 because the value stored in the return pointers are incorrect. When I load the second pointer, I get error 1 because the file name is incorrect. What am I doing incorrectly? | 1
2025-11-01 13:21:23.276 | Query: #    m is a sparse matrix in COO format.%20#    v is a dense vector%20# a0 is the pointer to the start of coo m%20# a1 is the # of rows (height) of coo m%20# a2 is the # of columns (width) of coo%20# a3 is the pointer to the start of v%20# a4 is the # of rows (height) of v%20# a5 is the # of columns (width) of v%20# a6 is the pointer to the the start of result%20# a7 is number of non zeros in coo m%20%20This just means that # of rows of v is the number of elements in v? And the stride of v is still 1 right? | 1
2025-11-01 18:47:36.657 | Query: How to generate the address for a nested array element array[i][j]? | 1
2025-11-01 18:48:40.009 | Query: For assignment 3, for main_spmv.s, where would be appropriate places to use malloc? | 1
2025-11-01 18:48:49.596 | Topic: For assignment 3, for main_spmv.s, where would be appropriate places to use malloc? | 1
2025-11-02 18:30:34.035 | Query: which lecture talks about converting addresses to block addresses | 1
2025-11-02 18:59:54.175 | Query: the formula for calculating the tag for a block address is `t bits = m- s- k` what does m stand for? | 1
2025-11-02 19:25:49.632 | Query: How do I convert an address to a block address? | 1
2025-11-04 15:24:47.799 | Query: Check yourself%20Do you know what a tag is?%20Do you know what is the difference between int * and int?%20Given the number of set bits and block bits, do you know how to extract tag bits?%20Tag Comparison	Selects the set	Block offset%20Tag (t)	Set index (s)	byte offset (b)%20What is the block address?%20Tag(t)	Set index (s)	0s for byte offset%20%20%20i think i know what a tag is- (the identifier used to distinguish which - out of all the possible blocks in a specific set - is stored currently in that specific way of the cach).%20The difference between the int and the int pointer would be that int is just 4 bytes, while int pointer is word bytes long, and that int pointer is storing the address of an int(or can store).%20%20what about the other two | 1
2025-11-04 15:51:43.033 | Query: %20The traces/ directory contains a collection of reference trace files that we will use as input to evaluate the correctness of your cache simulator. The trace files are generated by a Linux program called valgrind. For example, the following command runs the executable program ls -l, captures a trace of each of its memory accesses in the order they occur, and prints them to stdout.%20%20valgrind --log-fd=1 --tool=lackey -v --trace-mem=yes ls -l%20Memory traces have the following form:%20%20// Format: operation address,size%20M 0421c7f0,4%20L 04f6b868,8%20S 7ff0005c8,8%20Each line denotes one or two memory accesses. The format of each line is operation address,size:%20%20The operation field denotes the type of memory access: L a data load, S a data store, and M a data modify (i.e., a data load followed by a data store).%20The address field specifies a 64-bit hexadecimal memory address.%20The size field specifies the number of bytes accessed by the operation.%20%20This tells us about L and S and M but what is I? | 1
2025-11-05 14:53:52.690 | Query: what section of the memory address is the block%20 | 1
2025-11-05 15:13:48.600 | Query: given a memory address how do you convert it to a block address%20 | 1
2025-11-05 15:15:19.996 | Query: what is a tag in relation to caching%20%20 | 1
2025-11-05 15:19:44.043 | Query: provide an example of an address and then the corresponding block address%20%20 | 1
2025-11-05 15:32:29.781 | Query: typedef struct Cache {%20  int setBits;%20  int linesPerSet;%20  int blockBits;%20  Set *sets;%20  int eviction_count;%20  int hit_count;%20  int miss_count;%20  short displayTrace;%20  int lfu; // 0: Least Recently Used   1: Least Frequently Used.%20  char* name; %20} Cache;%20given this Cache setup and an address how do you find the block address%20 | 1
2025-11-06 12:37:37.003 | Query: %20typedef struct Cache {%20  int setBits;%20  int linesPerSet;%20  int blockBits;%20  Set *sets;%20  int eviction_count;%20  int hit_count;%20  int miss_count;%20  short displayTrace;%20  int lfu; // 0: Least Recently Used   1: Least Frequently Used.%20  char* name; %20} Cache;%20what does the block bits field specify%20 | 1
2025-11-06 12:38:48.354 | Query: %20typedef struct Cache {%20  int setBits;%20  int linesPerSet;%20  int blockBits;%20  Set *sets;%20  int eviction_count;%20  int hit_count;%20  int miss_count;%20  short displayTrace;%20  int lfu; // 0: Least Recently Used   1: Least Frequently Used.%20  char* name; %20} Cache;%20what does the block bits field specify, does this mean that 2^blockbits is the size of each block%20%20 | 1
2025-11-06 12:44:16.996 | Query: given a block size how do we calculate the size of the block offset for caching | 1
2025-11-06 12:47:45.086 | Query: typedef struct Cache {%20  int setBits;%20  int linesPerSet;%20  int blockBits;%20  Set *sets;%20  int eviction_count;%20  int hit_count;%20  int miss_count;%20  short displayTrace;%20  int lfu; // 0: Least Recently Used   1: Least Frequently Used.%20  char* name; %20} Cache; %20return address>>cache->blockBits;%20does this correctly convert a memory address to a block address %20 | 1
2025-11-06 12:49:14.188 | Query: given a memory address, what is the tag for caching%20 | 1
2025-11-06 12:59:10.210 | Query: given a memory address, what is the structure of it in terms of cachine, ie where are the blockbits, set bits, block offset%20%20 | 1
2025-11-06 13:00:15.341 | Query: given a memory address, what is the structure of it in terms of caching, where in the address are certain bits stored%20%20%20 | 1
2025-11-06 13:08:53.221 | Query: in regards to caching, is it valid to say that the tag is the same as the block address%20%20%20 | 1
2025-11-06 15:06:04.249 | Query: typedef struct Cache {%20  int setBits;%20  int linesPerSet;%20  int blockBits;%20  Set *sets;%20  int eviction_count;%20  int hit_count;%20  int miss_count;%20  short displayTrace;%20  int lfu; // 0: Least Recently Used   1: Least Frequently Used.%20  char* name; %20} Cache;%20with this cache setup, if linesPerSet=1, is the cache fully associative%20%20%20%20 | 1
2025-11-06 15:06:54.894 | Query: what is a direct-mapped cache%20 | 1
2025-11-06 16:37:38.245 | Query: in caching, what is a hit, miss, miss and evict%20%20 | 1
2025-11-07 10:23:22.226 | Query: in assignment 4, which functions should adjust the set clock and line timestamp values%20 | 1
2025-11-07 16:34:11.700 | Query: when evicting a block from a cache, does the block get removed from the cache, or is its valid bit just set to false? | 1
2025-11-07 18:08:20.637 | Query: I have a struct in a complex data structure with pointers and other structs, and I want to put that struct in a variable and have changes made to it, and then have those changes reflect in the data structure without having to reassign it. How can I do that? | 1
2025-11-07 20:54:06.924 | Query: what does a tag in a cache address represent? | 1
2025-11-07 20:55:22.792 | Query: does a tag in a cache address tell specify which position in a set (index) the block should be placed? | 1
2025-11-07 23:32:45.568 | Query: how do i mask the last 5 bits of a number to zero? | 1
2025-11-07 23:33:08.191 | Query: how do i mask the last n bits of a number to zero? | 1
2025-11-07 23:37:53.831 | Query: unsigned long long address_to_block(const unsigned long long address, const Cache *cache) {%20%20  //create a mask%20  int b = cache->blockBits;%20  int mask = ~((1 << b) - 1);%20%20  return (address & mask);%20%20}%20%20is this right | 1
2025-11-07 23:47:40.597 | Query: // Calculate the tag of the address. 0s out the bottom set bits and the bottom block bits.%20unsigned long long cache_tag(const unsigned long long address, const Cache *cache) {%20%20  unsigned long long tag;%20  // Calculate the tag of the given address for the cache.%20  // The function zeroes out the bits corresponding to the set index bits and block offset bits, %20  // leaving only the tag bits, based on the cache configuration.%20%20how would i implement this | 1
2025-11-08 00:00:18.178 | Query: if i have an address and i have the set bits and the block bits, how do i zero those out | 1
2025-11-08 00:12:47.009 | Query: // Calculate the tag of the address. 0s out the bottom set bits and the bottom block bits.%20unsigned long long cache_tag(const unsigned long long address, const Cache *cache) {%20%20  unsigned long long tag;%20  // Calculate the tag of the given address for the cache.%20  // The function zeroes out the bits corresponding to the set index bits and block offset bits, %20  // leaving only the tag bits, based on the cache configuration.%20  int n = cache->setBits + cache->blockBits;%20%20  int mask = ~((1 << b) - 1);%20%20  tag = address & mask;%20%20  return tag;%20%20}%20%20is this implemented correctly | 1
2025-11-08 00:13:27.929 | Query: // Calculate the tag of the address. 0s out the bottom set bits and the bottom block bits.%20unsigned long long cache_tag(const unsigned long long address, const Cache *cache) {%20%20  unsigned long long tag;%20  // Calculate the tag of the given address for the cache.%20  // The function zeroes out the bits corresponding to the set index bits and block offset bits, %20  // leaving only the tag bits, based on the cache configuration.%20  int n = cache->setBits + cache->blockBits;%20%20  int mask = ~((1 << n) - 1);%20%20  tag = address & mask;%20%20  return tag;%20%20}%20%20will this work? | 1
2025-11-08 00:29:16.893 | Query: // Calculate the set of the address. 0s out the bottom block bits, 0s out the tag bits, and then shift the set bits to the right.%20unsigned long long cache_set(const unsigned long long address, const Cache *cache) {%20%20  unsigned long long set;%20  return set;%20%20}%20%20how to implement this | 1
2025-11-08 00:45:04.110 | Query: how to mask the middle bits of a number | 1
2025-11-08 00:45:46.896 | Query: how to make the top n bits of a number zero, and the botton m bits of a number also zero, leaving only the middle? | 1
2025-11-08 00:49:51.913 | Query: how to only keep n number of bits the same, and make the rest all zeros | 1
2025-11-08 00:53:30.808 | Query: // Calculate the set of the address. 0s out the bottom block bits, 0s out the tag bits, and then shift the set bits to the right.%20unsigned long long cache_set(const unsigned long long address, const Cache *cache) {%20%20  unsigned long long set;%20%20  int s = cache->setBits;%20  int b = cache->blockBits;%20%20  set = address >> b;%20%20  int mask = ~((1 << s) - 1);%20%20  set = (mask & address);%20%20  return set;%20%20}%20%20will this implementation work | 1
2025-11-08 01:09:54.087 | Query: // Check if the given address is present in the cache (i.e. cache probe).%20// Returns true if the address is found in one of the cache lines (i.e., a cache hit),%20// or false if not found (cache miss).%20bool probe_cache(const unsigned long long address, const Cache *cache) {%20}%20%20%20how would i implement this | 1
2025-11-08 16:22:34.297 | Query: // Allocate an entry for the address. If the cache is full, evict an entry to create space. This method will not fail. %20void allocate_cache(const unsigned long long address, const Cache *cache) {%20  // When method runs there should have already been space created. %20}%20%20how would i implement this | 1
2025-11-08 17:08:34.680 | Query: // If the cache is full, evict an entry to create space. This method figures out which entry to evict. Depends on the policy.%20unsigned long long victim_cache(const unsigned long long address, Cache *cache) {%20  // Returns the exact way chosen for eviction based on the policy%20  //go through set s, and find the one with smallest flag%20%20  unsigned long long set = cache_set(address, cache);%20  Set *targetSet = &cache->sets[set];%20%20  Line *line;%20  Line *smallest = &targetSet->lines[0];%20%20  //iterate through lines, find the smallest one%20  for (int i = 1; i < cache->linesPerSet; i++) {%20%20    line = &targetSet->lines[i];%20%20    if (line->timestamp < smallest->timestamp) {%20%20      smallest = line;%20%20    }%20%20  }%20%20  unsigned long long victim = smallest->block_addr;%20%20  return victim;%20%20}%20%20will this work | 1
2025-11-08 17:37:05.204 | Query: // Is there space available in the set corresponding to the address?%20bool avail_cache(const unsigned long long address, const Cache *cache) {%20%20how should i implement this | 1
2025-11-09 21:55:13.328 | Query: what does this mean:%20address_to_block()%20Given an address, return the block aligned address i.e., blockbits are zero’d out | 1
2025-11-09 21:57:30.273 | Query: cache%20How to turn address to block address | 1
2025-11-09 22:02:28.707 | Query: cache%20What is a block address? Is it the tag, set, offset? | 1
2025-11-09 22:06:28.679 | Query: cache%20What is a block address compared to a regular address? How to get it from an address? | 1
2025-11-09 22:12:39.446 | Query: cache%20What is a block address compared to a regular address? How to get it from an address? | 1
2025-11-09 22:21:21.489 | Query: cache%20How to create a block address from address | 1
2025-11-09 23:14:25.013 | Query: for quiz week 7, I don't understand how to complete question 5, where it asks you to calculate the hit rate of a given program | 1
2025-11-09 23:18:43.473 | Query: for quiz week 7, I don't understand how to complete question 5, where it asks you to calculate the hit rate of a given program. %20%20I understand how to calculate a HR given a MR, but it only tells us the cache size, sets, ways. I could find the block size based on that but I don't understand how that helps. | 1
2025-11-10 11:32:07.690 | Query: hi | 1
2025-11-10 11:33:45.644 | Query: The cache size is ---- bytes Sets: 64 Ways: 2 block size: 4 bytes | 1
2025-11-10 11:40:47.144 | Query: The cache size is ---- bytes Sets: 32 Ways: 2 block size: 8 bytes | 1
2025-11-10 11:41:21.342 | Query: The bits positions in address representing the set are %20 (inclusive) to %20 (inclusive).%20%20e.g., Write as 5-0%20%20Cache size: 1024 bytes Ways: 2 block size: 2 bytes%20Assume LSB is 0 | 1
2025-11-10 11:54:21.134 | Query: The bits positions in address representing the set are %20 (inclusive) to %20 (inclusive).%20%20e.g., Write as 5-0%20%20Cache size: 512 bytes Ways: 2 block size: 8 bytes%20Assume LSB is 0%20%20(LSB IS 0) | 1
2025-11-10 12:13:23.375 | Query: The tag for address 0xa59e9 is ------- (hexadecimal). As many letters as tag width.%20%20Cache size: 128bytes Ways: 2 Sets: 32`%20Address width: 20 bits%201 kilobyte = 1024 bytes 1 megabyte = 1024 * 1024 bytes%20%20(so block size is 2 bytes, bits needed 1 bit?) | 1
2025-11-10 13:49:25.057 | Query: Cache%20How to find if address exists in cache?%20%20%20typedef struct Line {%20  unsigned long long block_addr;%20  short valid; // True: Cacheblock valid False: Cacheblock invalid%20  unsigned long long tag;%20  // holds the place in used lines%20  // the greater the rate, that much recent it is%20  int timestamp;%20} Line;%20%20typedef struct Set {%20  Line *lines; // Lines in each set (# of ways)%20  int clock;%20  int placementRate;%20} Set;%20%20typedef struct Cache {%20  // Confiuration%20  int setBits; // s%20  int linesPerSet; // E%20  int blockBits; // k%20%20  Set *sets;    // Array of sets%20%20  // Stats%20  int eviction_count;%20  int hit_count;%20  int miss_count;%20  short displayTrace;%20  int lfu; // 0: Least Recently Used   1: Least Frequently Used.%20  char* name;%20} Cache; | 1
2025-11-10 19:40:43.452 | Query: How to free lines%20%20%20typedef struct Line {%20  unsigned long long block_addr;%20  short valid;%20  unsigned long long tag;%20  // holds the place in used lines%20  // the greater the rate, that much recent it is%20  int timestamp;%20} Line;%20%20typedef struct Set {%20  Line *lines;%20  int clock;%20} Set;%20%20typedef struct Cache {%20  int setBits;%20  int linesPerSet;%20  int blockBits;%20  Set *sets;%20  int eviction_count;%20  int hit_count;%20  int miss_count;%20  short displayTrace;%20  int lfu; // 0: Least Recently Used   1: Least Frequently Used.%20  char* name; %20} Cache; | 1
2025-11-10 19:41:07.079 | Query: How to deallocate everything%20%20%20typedef struct Line {%20  unsigned long long block_addr;%20  short valid;%20  unsigned long long tag;%20  // holds the place in used lines%20  // the greater the rate, that much recent it is%20  int timestamp;%20} Line;%20%20typedef struct Set {%20  Line *lines;%20  int clock;%20} Set;%20%20typedef struct Cache {%20  int setBits;%20  int linesPerSet;%20  int blockBits;%20  Set *sets;%20  int eviction_count;%20  int hit_count;%20  int miss_count;%20  short displayTrace;%20  int lfu; // 0: Least Recently Used   1: Least Frequently Used.%20  char* name; %20} Cache; | 1
2025-11-10 19:42:00.837 | Query: How to deallocate everything. Set bits is only the num of bits that represent set%20%20%20typedef struct Line {%20  unsigned long long block_addr;%20  short valid;%20  unsigned long long tag;%20  // holds the place in used lines%20  // the greater the rate, that much recent it is%20  int timestamp;%20} Line;%20%20typedef struct Set {%20  Line *lines;%20  int clock;%20} Set;%20%20typedef struct Cache {%20  int setBits;%20  int linesPerSet;%20  int blockBits;%20  Set *sets;%20  int eviction_count;%20  int hit_count;%20  int miss_count;%20  short displayTrace;%20  int lfu; // 0: Least Recently Used   1: Least Frequently Used.%20  char* name; %20} Cache; | 1
2025-11-10 20:32:10.732 | Query: What is way in this context?%20%20// If the cache is full, evict an entry to create space. This method figures out which entry to evict. Depends on the policy.%20unsigned long long victim_cache(const unsigned long long address, Cache *cache) {%20// Returns the exact way chosen for eviction based on the policy | 1
2025-11-10 20:32:28.915 | Query: What is way in this context?%20%20// If the cache is full, evict an entry to create space. This method figures out which entry to evict. Depends on the policy.%20unsigned long long victim_cache(const unsigned long long address, Cache *cache)%20// Returns the exact way chosen for eviction based on the policy%20%20typedef struct Line {%20  unsigned long long block_addr;%20  short valid;%20  unsigned long long tag;%20  // holds the place in used lines%20  // the greater the rate, that much recent it is%20  int timestamp;%20} Line;%20%20typedef struct Set {%20  Line *lines;%20  int clock;%20} Set;%20%20typedef struct Cache {%20  int setBits;%20  int linesPerSet;%20  int blockBits;%20  Set *sets;%20  int eviction_count;%20  int hit_count;%20  int miss_count;%20  short displayTrace;%20  int lfu; // 0: Least Recently Used   1: Least Frequently Used.%20  char* name; %20} Cache; | 1
2025-11-10 20:40:19.449 | Query: What does this mean%20%20// Evict the cache entry corresponding to the given address.%20// This function wraps evict_cache() by determining the proper set and way from the address, then performing the eviction.%20void evict_address(const unsigned long long address, Cache *cache) {%20%20%20typedef struct Line {%20  unsigned long long block_addr;%20  short valid;%20  unsigned long long tag;%20  // holds the place in used lines%20  // the greater the rate, that much recent it is%20  int timestamp;%20} Line;%20%20typedef struct Set {%20  Line *lines;%20  int clock;%20} Set;%20%20typedef struct Cache {%20  int setBits;%20  int linesPerSet;%20  int blockBits;%20  Set *sets;%20  int eviction_count;%20  int hit_count;%20  int miss_count;%20  short displayTrace;%20  int lfu; // 0: Least Recently Used   1: Least Frequently Used.%20  char* name; %20} Cache; | 1
2025-11-10 20:43:48.260 | Query: What does this want to do?%20%20// Convert address to block address. 0s out the bottom block bits.%20unsigned long long address_to_block(const unsigned long long address, const Cache *cache) {%20%20typedef struct Line {%20  unsigned long long block_addr;%20  short valid;%20  unsigned long long tag;%20  // holds the place in used lines%20  // the greater the rate, that much recent it is%20  int timestamp;%20} Line;%20%20typedef struct Set {%20  Line *lines;%20  int clock;%20} Set;%20%20typedef struct Cache {%20  int setBits;%20  int linesPerSet;%20  int blockBits;%20  Set *sets;%20  int eviction_count;%20  int hit_count;%20  int miss_count;%20  short displayTrace;%20  int lfu; // 0: Least Recently Used   1: Least Frequently Used.%20  char* name; %20} Cache; | 1
2025-11-10 20:45:23.191 | Query: What does this want to do? How to calculate block address from address? Just remove the bottom bits?%20%20// Convert address to block address. 0s out the bottom block bits.%20unsigned long long address_to_block(const unsigned long long address, const Cache *cache) {%20%20typedef struct Line {%20  unsigned long long block_addr;%20  short valid;%20  unsigned long long tag;%20  // holds the place in used lines%20  // the greater the rate, that much recent it is%20  int timestamp;%20} Line;%20%20typedef struct Set {%20  Line *lines;%20  int clock;%20} Set;%20%20typedef struct Cache {%20  int setBits;%20  int linesPerSet;%20  int blockBits;%20  Set *sets;%20  int eviction_count;%20  int hit_count;%20  int miss_count;%20  short displayTrace;%20  int lfu; // 0: Least Recently Used   1: Least Frequently Used.%20  char* name; %20} Cache; | 1
2025-11-10 21:23:44.761 | Query: How to deallocate the entire cache?%20%20typedef struct Line {%20  unsigned long long block_addr;%20  short valid;%20  unsigned long long tag;%20  // holds the place in used lines%20  // the greater the rate, that much recent it is%20  int timestamp;%20} Line;%20%20typedef struct Set {%20  Line *lines;%20  int clock;%20} Set;%20%20typedef struct Cache {%20  int setBits;%20  int linesPerSet;%20  int blockBits;%20  Set *sets;%20  int eviction_count;%20  int hit_count;%20  int miss_count;%20  short displayTrace;%20  int lfu; // 0: Least Recently Used   1: Least Frequently Used.%20  char* name; %20} Cache; | 1
2025-11-10 22:18:24.660 | Query: How to deallocate the entire cache? When accessing cache->set, the program segfaults%20%20typedef struct Line {%20  unsigned long long block_addr;%20  short valid;%20  unsigned long long tag;%20  // holds the place in used lines%20  // the greater the rate, that much recent it is%20  int timestamp;%20} Line;%20%20typedef struct Set {%20  Line *lines;%20  int clock;%20} Set;%20%20typedef struct Cache {%20  int setBits;%20  int linesPerSet;%20  int blockBits;%20  Set *sets;%20  int eviction_count;%20  int hit_count;%20  int miss_count;%20  short displayTrace;%20  int lfu; // 0: Least Recently Used   1: Least Frequently Used.%20  char* name; %20} Cache; | 1
2025-11-10 22:29:31.335 | Query: How to malloc line and set%20%20typedef struct Line {%20  unsigned long long block_addr;%20  short valid;%20  unsigned long long tag;%20  // holds the place in used lines%20  // the greater the rate, that much recent it is%20  int timestamp;%20} Line;%20%20typedef struct Set {%20  Line *lines;%20  int clock;%20} Set;%20%20typedef struct Cache {%20  int setBits;%20  int linesPerSet;%20  int blockBits;%20  Set *sets;%20  int eviction_count;%20  int hit_count;%20  int miss_count;%20  short displayTrace;%20  int lfu; // 0: Least Recently Used   1: Least Frequently Used.%20  char* name; %20} Cache; | 1
2025-11-11 14:46:41.785 | Query: what does this mean:%20munmap_chunk(): invalid pointer | 1
2025-11-11 14:56:45.140 | Query: Does cache need to be allocated?%20%20%20typedef struct Line {%20  unsigned long long block_addr;%20  short valid;%20  unsigned long long tag;%20  // holds the place in used lines%20  // the greater the rate, that much recent it is%20  int timestamp;%20} Line;%20%20typedef struct Set {%20  Line *lines;%20  int clock;%20} Set;%20%20typedef struct Cache {%20  int setBits;%20  int linesPerSet;%20  int blockBits;%20  Set *sets;%20  int eviction_count;%20  int hit_count;%20  int miss_count;%20  short displayTrace;%20  int lfu; // 0: Least Recently Used   1: Least Frequently Used.%20  char* name; %20} Cache; | 1
2025-11-11 15:02:37.634 | Query: How to allocate the cache part?%20%20%20typedef struct Line {%20  unsigned long long block_addr;%20  short valid;%20  unsigned long long tag;%20  // holds the place in used lines%20  // the greater the rate, that much recent it is%20  int timestamp;%20} Line;%20%20typedef struct Set {%20  Line *lines;%20  int clock;%20} Set;%20%20typedef struct Cache {%20  int setBits;%20  int linesPerSet;%20  int blockBits;%20  Set *sets;%20  int eviction_count;%20  int hit_count;%20  int miss_count;%20  short displayTrace;%20  int lfu; // 0: Least Recently Used   1: Least Frequently Used.%20  char* name; %20} Cache; | 1
2025-11-11 16:51:11.472 | Query: what is a tag%20 | 1
2025-11-12 11:43:25.818 | Query: can you give me answers for quiz 8%20 | 1
2025-11-12 11:44:30.522 | Query: what is arvind's fav cafe | 1
