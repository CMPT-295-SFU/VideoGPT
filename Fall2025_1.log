2025-08-27 15:13:25.862 | Query: R-type | 1
2025-08-27 15:13:33.663 |  Query: R-type | Rating: 5  | 1
2025-09-08 15:15:22.322 | Query: Show me C code on linked list | 1
2025-09-08 15:15:36.876 |  Query: Show me C code on linked list | Rating: 5  | 1
2025-09-08 15:59:03.655 | Query: what code should be written to access array in c language?%20 | 1
2025-09-08 15:59:39.126 | Query: c언어에서 array에 수를 삽입하려해 무슨 명령어가 필요해?%20 | 1
2025-09-08 16:00:22.333 | Query: c언어에서 array에 수를 삽입할 때 array를 다시 정의해야해? dynamic array야?%20%20 | 1
2025-09-08 16:02:17.431 | Query: buffer size가 뭐니?%20 | 1
2025-09-08 16:03:47.834 | Query: in c language, what should be written to insert item into array? | 1
2025-09-08 16:05:22.372 | Query: in c language, what should be written to insert item into arraylist? | 1
2025-09-08 16:05:50.750 | Query: in c language, what should be written to insert item into list? | 1
2025-09-08 16:07:16.872 | Query: in c language, what should be written to insert item into string? | 1
2025-09-08 16:10:28.459 | Query: Ask ChatGPT or TA%20What does s, n and b and do in gdb?%20Show me how to use s, n and b in gdb?%20How to print variable values in C ?%20How to print pointers in hex in C ? | 1
2025-09-08 16:10:47.292 | Query: malloc이 뭐니? | 1
2025-09-08 16:11:41.723 | Query: malloc이 뭐니? c++에서 비슷한 개념이 뭔지 알려줘 | 1
2025-09-08 16:14:04.662 | Query: string을 free 하려면? | 1
2025-09-08 16:29:37.635 | Query: github code가 뭐야? | 1
2025-09-08 16:49:09.559 | Query: iterate가 뭐야? | 1
2025-09-08 16:49:58.219 | Query: tokenize가 뭐야? | 1
2025-09-08 16:51:34.173 | Query: vector char가 뭐야? | 1
2025-09-08 17:11:27.782 | Query: Given this function where 'a' is the array and 'x' is the value to be appended,%20void arraylist_add(arraylist *a, void *x) {%20%20/*%20    typedef struct arraylist%20    {%20        void **buffer;            // pointer to allocated memory%20        unsigned int buffer_size; // Maximum element capacity%20        unsigned int length;      // Current number of elements%20    } arraylist;%20    */%20%20}%20%20would 'a->buffer[a->length] = x;' be the appropriate instrunctions to append given that 'a' has already been alloced? | 1
2025-09-08 17:17:43.313 | Query: /*%20 * Store x at the specified index of the arraylist. Previously stored values%20 * should be moved back rather than overwritten. It is undefined behavior to%20 * insert an element with an index beyond the end of an arraylist.%20 */%20void arraylist_insert(arraylist *a, unsigned int index, void *x)%20{%20    // Hint: Consider how you could implement this function in terms of%20    // arraylist_add()%20%20    // Check if arraylist exists%20    if (a == NULL) {%20        return;%20    }%20%20    // Move previously stored value to the back%20    arraylist_add(a, x);%20%20    // Overwrite previously stored value after previous step%20    a->buffer[index] = x;%20%20    return;%20}%20%20is this an appropriate way to insert x? | 1
2025-09-08 18:15:13.134 | Query:   // TODO: Tokenize processing%20  // TODO:source contains the string to be processed.%20  /** Start processing file and separate into words */%20  /** Pseudocode */%20  // 1. Iterate over characters%20  // 2. if current-character starts word start accumulating into vector_char%20  // 3. if current character terminates word. print and restart word start%20  // check. Free all data.%20  // Hint: Use vector_char%20내 목표가 뭐지..?%20 | 1
2025-09-08 18:35:24.875 | Query:  how can i initialize? | 1
2025-09-08 21:16:44.249 | Query: What does s, n, and b do in gdb?%20 | 1
2025-09-08 21:17:37.544 | Query: Show me how to use s n and b in gdb%20%20 | 1
2025-09-08 21:19:00.465 | Query: how to print variable values in c?%20%20%20 | 1
2025-09-08 21:19:29.735 | Query: how to print pointers in hex in C?%20%20%20%20 | 1
2025-09-08 21:20:24.537 | Query: how to set up launch.json in vscode for debugging c programs?%20 | 1
2025-09-08 21:27:21.279 | Query: how to set up launch.json in vscode for debugging c programs?%20"C/C++: g++ build and debug active file or C/C++: gcc build and debug active file" neither option is showing up under configurations%20 | 1
2025-09-08 21:28:42.244 | Query: "C/C++: g++ build and debug active file or C/C++: gcc build and debug active file" neither option is showing up under configurations%20explain how to edit tasks.json so these options appear%20 | 1
2025-09-08 21:39:18.454 | Query: when i use the Tasks: Configure Default Build Task command, many options show up. what do these mean and which should i choose?%20 | 1
2025-09-08 21:41:16.632 | Query: How to setup launch.json in VSCODE for debugging C programs?%20%20 | 1
2025-09-08 21:42:13.652 | Query: How to setup launch.json in VSCODE for debugging C programs?%20Where should these jsons end up in my files?%20 | 1
2025-09-08 21:55:49.162 | Query: do i just have to change edit the tasks.json and launch.json everytime i need to work on a new project? | 1
2025-09-08 21:56:47.644 | Query: Regarding tasks.json and launch.json, do I need to edit these files if I want to debug a different project to the one in the files? | 1
2025-09-09 12:23:55.932 | Query: write assembly code for a simple loop | 1
2025-09-09 14:37:25.850 | Query: What does s, n and b and do in gdb?%20Show me how to use s, n and b in gdb?%20 | 1
2025-09-09 14:42:22.978 | Query: give a week 1 summary | 1
2025-09-09 14:50:33.439 | Query: how can i find a seg fault and fix it using cgdb%20 | 1
2025-09-09 18:06:12.786 | Query: What is the standard procedure for checking if a ptr is null after using realloc?%20 | 1
2025-09-09 18:08:12.913 | Query: What is the standard procedure for checking if a ptr is null after using realloc?%20What would be the best way to log the error for this class?%20 | 1
2025-09-09 18:11:32.457 | Query: What is memmove?%20 | 1
2025-09-09 18:12:09.996 | Query: What is memmove?%20Is n a required argument? | 1
2025-09-09 18:13:19.555 | Query: All pointers are 2 bytes right? | 1
2025-09-09 18:15:09.410 | Query: If I want to move sequential items from an array with memmove, and the array stores pointers, how could I calculate the number of bytes I need to copy for memmove? | 1
2025-09-09 18:17:56.627 | Query: Does memmove just copy the elements of an array into another section of memory? | 1
2025-09-09 18:19:16.964 | Query: If a pointer has not been assigned memory will memmove automatically assign the memory?%20 | 1
2025-09-09 18:25:03.668 | Query: If the header files are in a folder that is in the same folder as the C source file, how do I compile the source file?%20 | 1
2025-09-09 18:25:52.159 | Query: If the header files are in a folder that is in the same folder as the C source file, how do I compile the source file?%20The folder is in the same folder as the C source file, but the header files are not | 1
2025-09-09 18:38:22.642 | Query: What do these errors from the arraylist practice section of assignment 1 mean?%20malloc(): corrupted top size%20Test interrupted by SIGSEGV. | 1
2025-09-09 18:42:06.262 | Query: What do these errors from the arraylist practice section of assignment 1 mean?%20Test interrupted by SIGABRT | 1
2025-09-09 18:43:59.076 | Query: will fprintf to stderr show up on the terminal? | 1
2025-09-09 18:45:14.665 | Query: What does this error mean from Arraylist practice on Assignment 1?%20free(): double free detected in tcache 2 | 1
2025-09-09 18:49:06.474 | Query: How do I use cgdb on an executable generated by two c files?%20 | 1
2025-09-09 18:55:05.253 | Query: Can you help me read this?%20#5  0x00007ffff7c297b6 in __libc_message_impl (fmt=fmt@entry=0x7ffff7dce8d7 "%s\n") at ../sysdeps/posix/libc_fatal.c:134%20#6  0x00007ffff7ca8ff5 in malloc_printerr (str=str@entry=0x7ffff7dcc6f7 "malloc(): corrupted top size") at ./malloc/malloc.c:5772%20#7  0x00007ffff7cac2fc in _int_malloc (av=av@entry=0x7ffff7e03ac0 <main_arena>, bytes=16) at ./malloc/malloc.c:4447%20#8  0x00007ffff7cad7f2 in __GI___libc_malloc (bytes=<optimized out>) at ./malloc/malloc.c:3328%20#9  0x0000555555556892 in arraylist_new () at arraylist.c:78%20#10 0x000055555555a14a in test1 () at main.c:107%20#11 0x0000555555557fd9 in test_do_run__ (test=0x55555555dc50 <test_list__+16>, index=1) at include/acutest.h:944%20#12 0x00005555555583ef in test_run__ (test=0x55555555dc50 <test_list__+16>, index=1, master_index=1) at include/acutest.h:1115%20#13 0x0000555555559807 in main (argc=1, argv=0x7fffffffe2d8) at include/acutest.h:1634%20From what I'm getting it's crashing due to arraylist_new() which is provided, could I be doing something that is crashing it? This is line 107 in main.c%20  arraylist *a = arraylist_new(); | 1
2025-09-09 19:13:44.543 | Query: Are there reasons for a seg fault other than double freeing, going out of bounds, and trying to access a ptr that is NULL? | 1
2025-09-09 21:04:31.102 | Query: Can you help me debug this resizing code?%20if (a->length == a->buffer_size) {%20        a->buffer_size *= 2;%20        void** temp;%20        temp = (void**)realloc(a->buffer, a->buffer_size * sizeof(void*));%20        if (temp == NULL) {%20            arraylist_free(a);%20            a = NULL;%20            fprintf(stderr, "Memory allocation failed during realloc.\n");%20            exit(1);%20        }%20        free(a->buffer);%20        a->buffer = temp;%20    } | 1
2025-09-09 21:08:41.161 | Query: How could I get the result of putting a variable into a function in cgdb? Do I need to actually put it in the code itself or is there a cgdb command for this? | 1
2025-09-09 21:13:53.485 | Query: What reasons could there be for my buffer_size to become ridiculously large, like 3945469781? It should be coming from this code, and if not then it may be some kind of memory mismanagement%20void arraylist_add(arraylist *a, void *x)%20{%20    // TODO%20    if (a->length == a->buffer_size) {%20        a->buffer_size *= 2;%20        void** temp;%20        temp = (void**)realloc(a->buffer, a->buffer_size * sizeof(void*));%20        if (temp == NULL) {%20            arraylist_free(a);%20            fprintf(stderr, "Memory allocation failed during realloc.\n");%20            exit(1);%20        }%20        a->buffer = temp;%20    }%20    a->buffer[a->length] = x;%20    a->length++;%20} | 1
2025-09-09 21:15:47.183 | Query: How do I add logging for a variable after each modification during runtime? | 1
2025-09-09 21:19:23.705 | Query: How do I move to a specific line in a specific file in cgdb?%20 | 1
2025-09-09 21:19:31.826 |  Query: How do I move to a specific line in a specific file in cgdb?%20 | Rating: 1  | 1
2025-09-09 21:19:52.288 | Query: How do I move to a specific line in cgdb?%20 | 1
2025-09-09 21:19:56.724 |  Query: How do I move to a specific line in cgdb?%20 | Rating: 5  | 1
2025-09-09 21:20:26.203 | Query: How do I move to a specific line in cgdb?%20What if it is in a different folder than the one that cgdb is currently on? | 1
2025-09-09 21:25:54.915 | Query: void arraylist_insert(arraylist *a, unsigned int index, void *x)%20{%20    // TODO%20    // Hint: Consider how you could implement this function in terms of%20    // arraylist_add()%20    unsigned int num_bytes = index * sizeof(void*);%20    arraylist* result = arraylist_new();%20    result->length = index;%20    void** temp;%20    temp = (void**)realloc(result->buffer, a->buffer_size * sizeof(void*));%20    result->buffer_size = a->buffer_size;%20    if (temp == NULL) {%20        arraylist_free(result);%20        arraylist_free(a);%20        fprintf(stderr, "Memory allocation failed during malloc.\n");%20        exit(1);%20    }%20    result->buffer = temp;%20%20    memmove(result->buffer, a->buffer, num_bytes);%20    result->length = index;%20%20    arraylist_add(result, x);%20    for (int i = index; i < a->length+1; i++) {%20        arraylist_add(result, a->buffer[i]);%20    }%20    arraylist_free(a);%20    a = result;%20}%20%20Can you help me debug this code? As soon as it goes out of scope a's buffer size becomes extremely large | 1
2025-09-09 21:38:30.526 | Query: void arraylist_insert(arraylist *a, unsigned int index, void *x)%20{%20    // TODO%20    // Hint: Consider how you could implement this function in terms of%20    // arraylist_add()%20    unsigned int num_bytes = index * sizeof(void*);%20    arraylist* result = arraylist_new();%20    result->length = index;%20    void** temp;%20    temp = (void**)realloc(result->buffer, a->buffer_size * sizeof(void*));%20    result->buffer_size = a->buffer_size;%20    if (temp == NULL) {%20        arraylist_free(result);%20        arraylist_free(a);%20        fprintf(stderr, "Memory allocation failed during malloc.\n");%20        exit(1);%20    }%20    result->buffer = temp;%20%20    memmove(result->buffer, a->buffer, num_bytes);%20    result->length = index;%20%20    arraylist_add(result, x);%20    for (int i = index; i < a->length; i++) {%20        printf("%d\n", a->buffer[i]);%20        arraylist_add(result, a->buffer[i]);%20    }%20    free(a->buffer);%20    a->buffer = result->buffer;%20    free(result);%20}%20Can you debug my code? When printing a->buffer[i] it seems like the int at buffer[i] is underflowed | 1
2025-09-09 21:40:08.185 | Query: void arraylist_insert(arraylist *a, unsigned int index, void *x)%20{%20    // TODO%20    // Hint: Consider how you could implement this function in terms of%20    // arraylist_add()%20    unsigned int num_bytes = index * sizeof(void*);%20    arraylist* result = arraylist_new();%20    result->length = index;%20    void** temp;%20    temp = (void**)realloc(result->buffer, a->buffer_size * sizeof(void*));%20    result->buffer_size = a->buffer_size;%20    if (temp == NULL) {%20        arraylist_free(result);%20        arraylist_free(a);%20        fprintf(stderr, "Memory allocation failed during malloc.\n");%20        exit(1);%20    }%20    result->buffer = temp;%20%20    memmove(result->buffer, a->buffer, num_bytes);%20    result->length = index;%20%20    arraylist_add(result, x);%20    for (int i = index; i < a->length; i++) {%20        printf("%d\n", a->buffer[i]);%20        arraylist_add(result, a->buffer[i]);%20    }%20    free(a->buffer);%20    a->buffer = result->buffer;%20    free(result);%20}%20Can you debug my code? When printing a->buffer[i] it seems like the int at buffer[i] is underflowed%20After removing free(result) at the end it is overflowing | 1
2025-09-09 21:46:21.005 | Query: Is it possible to view the value of a void* through cgdb? | 1
2025-09-09 21:47:28.478 | Query: How do I go back one line in cgdb?%20 | 1
2025-09-09 22:07:54.898 | Query: When a character is converted into ascii in C, which column on the table is used for the conversion? | 1
2025-09-09 22:09:42.895 | Query: Could you tell me what ranges of ascii values represent 0-9, a-z, and A-Z?%20 | 1
2025-09-09 22:26:50.951 | Query: how to do gdbinit in window? | 1
2025-09-09 22:27:10.903 | Query: how to do gdbinit in window in vs code? | 1
2025-09-09 22:55:35.380 | Query: if I type p_generic_list list1, there comes undefined command%20 | 1
2025-09-09 22:55:48.249 | Query: if I type p_generic_list list1, there comes undefined command in gdb%20%20  | 1
2025-09-09 22:57:29.738 | Query: although I defined p_generic_list, if I type p_generic_list list1, there comes undefined command in gdb%20%20  | 1
2025-09-09 23:11:16.336 | Query: how to compile intellij%20%20%20  | 1
2025-09-10 10:44:46.185 | Query: What kind of unit tests should i write for str_cmp in the first assignment? Should I do tests that the provided tests don't cover?%20 | 1
2025-09-10 10:54:28.555 | Query: else printf("TEST CASE 3 PASSED\n"); passed++;%20is this allowed in C?%20 | 1
2025-09-10 10:56:20.585 | Query: else printf("TEST CASE 3 PASSED\n"); passed++;%20is this allowed in C?%20is the passed++ within the else? | 1
2025-09-10 14:29:35.863 | Query: The CPU executes instructions%20! Memory stores data%20! Binary encoding!%20" Instructions are just data%205%20Memory%20CPU%20?%20How are data%20and instructions%20represented? | 1
2025-09-10 14:30:24.229 | Topic: The CPU executes instructions! Memory stores data! Binary encoding!" Instructions are just data5MemoryCPU?How are dataand instructionsrepresented? | 1
2025-09-10 14:30:29.907 | Topic: The CPU executes instructions! Memory stores data! Binary encoding!" Instructions are just data5MemoryCPU?How are dataand instructionsrepresented? | 1
2025-09-10 14:34:06.058 | Query: How does a%20program find its%20data in memory? | 1
2025-09-10 14:38:01.729 | Query: ! If we choose to use 4-bit addresses, how big is our%20address space?%20" i.e. How much space can we “refer to” using our addresses?%20A. 16 bits%20B. 16 bytes%20C. 4 bits%20D. 4 bytes%20E. We’re lost… | 1
2025-09-10 16:44:59.698 | Query: If the word size of a machine is 64-bits, which of the%20following is usually true? (pick all that apply)%20a) 64 bits is the size of a pointer%20b) 64 bits is the size of an integer%20c) 64 bits is the width of a register | 1
2025-09-10 16:46:58.111 | Query: (True/False) By looking at the bits stored in memory,%20I can tell if a particular 4-bytes is being used to%20represent an integer, floating point number, or%20instruction. | 1
2025-09-10 16:50:44.759 | Query: int* ptr;%20int x = 5;%20int y = 2;%20ptr = &x;%20y = 1 + *ptr;%205%20Declares a variable, ptr, that is a pointer to%20(i.e. holds the address of) an int in memory%20Declares two variables, x and y, that hold ints,%20and initializes them to 5 and 2, respectively%20Sets ptr to the address of x%20(“ptr points to x”)%20Sets y to “1 plus the value stored at the%20address held by ptr. Because ptr%20points to x, this is equivalent to y=1+x;%20“Dereference ptr”%20What is *(&y) ? | 1
2025-09-10 17:39:24.134 | Query: can you explain the code line void* calloc(size_t nitems, size_t size) | 1
2025-09-10 17:42:27.899 | Query: can you explain the code line void* calloc(size_t nitems, size_t size) and how it is different from malloc(size_t size) and is there difference between variable size in both?%20 | 1
2025-09-10 21:14:26.060 | Query: hello | 1
2025-09-10 21:14:49.972 | Query: what is the marking scheme for this course%20 | 1
2025-09-10 21:15:23.198 | Query: what are the passing requirements for the exam | 1
2025-09-10 21:15:42.156 | Query: how do i use cgdb | 1
2025-09-10 21:16:16.533 | Query: write a function in C that prints a pointer value%20 | 1
2025-09-11 16:49:06.510 | Query: do I need to assert that new data is not NULL while using realloc?%20 | 1
2025-09-11 17:06:55.122 | Query: In arraylist_free, do I need to assert that *a is NULL? | 1
2025-09-11 17:07:46.773 | Query: In arraylist_free, do I need to use for loop?%20 | 1
2025-09-11 17:08:01.538 | Query: In arraylist_free, do I need to use loop?%20 | 1
2025-09-11 17:09:13.605 | Query: In arraylist_free, do I need to use loop? then how?%20 | 1
2025-09-11 20:50:11.836 | Query: vector_char_t *vector_char_allocate(void) {%20%20  vector_char_t *header = (vector_char_t *)malloc(sizeof(vector_char_t));%20  if (!header)%20    return NULL;%20%20  header->data = NULL;%20  header->len = header->max = 0;%20%20  return header;%20}%20what does this function allocate? | 1
2025-09-11 21:22:48.478 | Query: realloc이 뭐니 | 1
2025-09-11 21:23:20.518 | Query: realloc 에 대해 | 1
2025-09-11 21:24:49.354 | Query: realloc 에 대해 한글로 | 1
2025-09-11 21:25:12.391 | Query: realloc 에 대해 한글로 parameter는? | 1
2025-09-11 21:26:46.401 | Query: malloc의 파라미터 | 1
2025-09-11 21:27:42.080 | Query: arraylist *arraylist_new()%20{%20    arraylist *a = (arraylist *)malloc(sizeof(arraylist));%20    a->buffer = (void **)malloc(4 * sizeof(void *));%20    a->buffer_size = 4;%20    a->length = 0;%20%20    return a;%20}%20이거에 대해 분석 | 1
2025-09-11 21:29:43.936 | Query: malloc 파라미터 한글로 설명 | 1
2025-09-11 21:30:50.788 | Query: malloc 파라미터 한글로 설명 void일 때 | 1
2025-09-11 21:31:36.936 | Query: realloc 파라미터 한글로 설명 void일 때 | 1
2025-09-11 21:32:28.664 | Query: array_list_add 작성 팁 | 1
2025-09-11 21:33:23.631 | Query: array_list_add 작성 팁 한글로 | 1
2025-09-11 21:36:26.273 | Query: assignment1을 하면서 refer하면 좋은 슬라이드 다 보여줘 | 1
2025-09-11 21:36:45.160 | Query: assignment1에 관한 모든 슬라이드 | 1
2025-09-11 21:45:07.163 | Query: memmove에 대해 파라미터, 한글로 설명 | 1
2025-09-11 21:48:55.279 | Query: memmove에 대해 쉽게 설명 | 1
2025-09-11 22:40:41.044 | Query: arraylist free하는 법 | 1
2025-09-11 22:40:54.185 | Query: arraylist free하는 법 assignment1에서! 한글로 | 1
2025-09-11 22:41:08.895 | Query: arraylist free하는 법 ! 한글로 | 1
2025-09-11 22:42:13.636 | Query: arraylist free하는 법 한글로 | 1
2025-09-11 22:42:28.063 | Query: arraylist free하는 법 한글로 c언어 | 1
2025-09-12 10:24:36.846 | Query: assignment 1 에 관련한 슬라이드 | 1
2025-09-12 10:25:00.030 | Query: assignment 1 slide reference? | 1
2025-09-12 10:25:26.303 | Query: slide reference about free%20 | 1
2025-09-12 10:55:32.753 | Query: char* 와 char** 차이%20 | 1
2025-09-12 11:05:04.438 | Query: string comparison에 관한 슬라이드 | 1
2025-09-12 11:05:22.925 | Query: string comparison에 관한 | 1
2025-09-12 11:06:26.661 | Query: string comparison에 대해 | 1
2025-09-12 11:07:14.287 | Query: string comparison에 대해 not use library function | 1
2025-09-12 11:24:07.821 | Query: What does vector_char_allocate() allocate? space for string OR space for pointer to string?%20vector_char_t *vector_char_allocate(void) {%20%20  vector_char_t *header = (vector_char_t *)malloc(sizeof(vector_char_t));%20  if (!header)%20    return NULL;%20%20  header->data = NULL;%20  header->len = header->max = 0;%20%20  return header;%20} | 1
2025-09-12 11:25:36.847 | Query: Where does the header reside?%20vector_char_t *header = vector_char_allocate(); | 1
2025-09-12 11:25:56.069 | Query: Where does the header reside?%20vector_char_t *header = vector_char_allocate();%20stack or heap? | 1
2025-09-12 11:29:57.712 | Query: where is header->data allocated? stack or heap?%20vector_char_t *vector_char_allocate(void) {%20%20  vector_char_t *header = (vector_char_t *)malloc(sizeof(vector_char_t));%20  if (!header)%20    return NULL;%20%20  header->data = NULL;%20  header->len = header->max = 0;%20%20  return header;%20} | 1
2025-09-12 11:37:10.462 | Query: how to iterate string? | 1
2025-09-12 13:09:01.706 | Query: how do you loop over an array in C | 1
2025-09-12 14:04:42.796 | Query: vs_entry_t가 뭐야 | 1
2025-09-12 14:38:28.868 | Query: What does s, n and b and do in gdb?%20Show me how to use s, n and b in gdb?%20How to print variable values in C ?%20How to print pointers in hex in C ? | 1
2025-09-12 15:23:46.521 | Query: (buckets & (buckets - 1)이게 뭐니 | 1
2025-09-12 15:50:49.809 | Query: Could not load source './malloc/./malloc/malloc.c': 'SourceRequest' not supported..%20 | 1
2025-09-12 16:04:10.321 | Query:   if ((n = (struct node *)malloc(sizeof(struct node))) == 0) what is malloc here%20 | 1
2025-09-12 17:21:59.921 | Query: Now that we know how to tokenize, let’s build a dictionary. A dictionary is a collection of all the unify words. e.g.,%20%201. Lorem%202. i%203. dolor%204. sit%205. amet%20%20what does unify words mean? | 1
2025-09-12 18:41:56.986 | Query: should you free a char* | 1
2025-09-12 20:36:03.910 | Query: Do you have information on the assignments in this class?%20 | 1
2025-09-12 23:18:44.128 | Query: How would I modify the print_list to only print the node if the data == 5? | 1
2025-09-12 23:19:24.859 | Query: # Gdb init file for linked list debugging%20# $PWD/.gdbinit%20define p_generic_list%20  set var $n = $arg0%20  while $n%20    print *($n)%20    set var $n = $n->next%20  end%20end%20%20%20document p_generic_list%20        p_generic_list LIST_HEAD_POINTER%20        Print all the fields of the nodes in the linked list pointed to by LIST_HEAD_POINTER. Assumes there is a next field in the struct.%20end%20%20%20%20define indentby%20    printf "\n"%20    set $i_$arg0 = $arg0%20    while $i_$arg0 > 10%20        set $i_$arg0 = $i_$arg0 - 1%20        printf "%c", ' '%20    end%20end%20%20Given this .gdbinit file, how would I modify the print_list to only print the node if the data == 5? | 1
2025-09-13 15:00:52.000 | Query: How much space does a void pointer in c take? How does pointer math change with it | 1
2025-09-13 15:05:28.232 | Topic: How much space does a void pointer in c take? How does pointer math change with it | 1
2025-09-13 15:05:48.160 | Query: What does : Test interrupted by SIGSEGV. mean? | 1
2025-09-13 15:11:21.871 | Query: Debug this pointer array code: %20    arraylist_add(a, x);%20    memmove(a->buffer[index + 1], a->buffer[index], sizeof(a->buffer[index] + (a->length - index)));%20    a->buffer[index] = x; | 1
2025-09-13 15:13:01.490 |  Query: Debug this pointer array code: %20    arraylist_add(a, x);%20    memmove(a->buffer[index + 1], a->buffer[index], sizeof(a->buffer[index] + (a->length - index)));%20    a->buffer[index] = x; | Rating: 5  | 1
2025-09-13 16:08:44.052 | Query: Is there a standard method to decide how many buckets to allocate in a hash table? | 1
2025-09-13 16:27:58.959 | Query: Are there instructions for assignment 1 about how to decide how many buckets to allocate for table_string?%20 | 1
2025-09-13 19:54:07.436 | Query: Is it normal for the diff command in the terminal to print < before each line of the first file and > before each line of the second file? | 1
2025-09-14 14:54:32.305 | Query: What are s and n in gdb? | 1
2025-09-14 15:04:12.323 | Query: What is the Binary of Decimal 0d11 | 1
2025-09-14 15:04:34.996 | Query: What is the Binary of Decimal 0d36 | 1
2025-09-14 15:05:15.658 | Query: What is the Decimal of Binary 0b11011111 | 1
2025-09-14 15:05:51.987 | Query: What is the Hex of Decimal 0d111 | 1
2025-09-14 15:06:24.711 | Query: Consider a base number system 4%20%20The digits used to represent a number is | 1
2025-09-14 15:07:46.947 | Query: Consider a base number system 4%20%20The digits used to represent a number is 0, 1, 2 and 3.%20%20The maximum number i is of 2 digits is ______ (in decimal. You do not need to write 0d)%20%20Number 0d138 represented in base 4 is _______ (only write digits) | 1
2025-09-14 15:08:58.654 | Query: What is x (in hex) ?%20x = *((short*)array+29);%20%20Assume array = 0x1000%20Assume big endianess | 1
2025-09-14 15:10:38.769 | Query: If the size of the pointer is 16 bits, what is the maximum size of the memory ? | 1
2025-09-14 15:11:04.304 | Query: If the size of the memory is 4.0 megabytes what is the number of bits required ? | 1
2025-09-14 15:44:52.796 | Query: Debug why this code is not printing out:%20int i = 0;%20  vector_char_t *word = vector_char_allocate();%20  while (source[i] != '\0') {%20    if ((source[i] >= 65 && source[i] <= 90) || (source[i] >= 97 && source[i] <= 122)) {%20      vector_char_add(word, source[i]);%20%20    } else {%20      vector_char_add(word, '\0');%20%20      char* word_ptr = vector_char_get_array(word);%20      printf("%s \n", word_ptr);%20%20      vector_char_delete(word);%20%20      word = vector_char_allocate();%20%20    }%20  } | 1
2025-09-14 15:59:52.269 | Query: What reasons could there be for an extra empty line printing.%20  int i = 0;%20  vector_char_t *word = vector_char_allocate();%20  char* word_ptr;%20  while (source[i] != '\0') {%20%20    if (source[i + 1] == '\0') {%20      vector_char_add(word, '\0');%20      word_ptr = vector_char_get_array(word);%20      printf("%s", word_ptr);%20%20    }%20%20    if ((source[i] >= 65 && source[i] <= 90) || (source[i] >= 97 && source[i] <= 122)) {%20      vector_char_add(word, source[i]);%20%20    } else {%20      vector_char_add(word, '\0');%20%20      word_ptr = vector_char_get_array(word);%20      printf("%s\n", word_ptr);%20%20      vector_char_delete(word);%20%20      word = vector_char_allocate();%20%20    }%20    i++;%20  }%20%20  if (word != NULL) {%20    vector_char_delete(word);%20%20  }%20 | 1
2025-09-14 17:49:33.928 | Query: #include "table_string.h"%20#include "str_cmp.h"%20#include <stdbool.h>%20#include <stdint.h>%20#include <stdio.h>%20#include <stdlib.h>%20#include <string.h>%20%20#define BUCKETS%20// DO NOT ADD ANY NEW FUNCTIONS BEFORE djb2%20// Hash a character array to integer value between 0 and buckets-1.%20// See here for more details: https://theartincode.stanis.me/008-djb2/%20unsigned int djb2_word_to_bucket(char *word, int buckets) {%20  if (!word) {%20    printf("Invoked with null string");%20    exit(EXIT_FAILURE);%20  }%20  unsigned long hash = 5381;%20  uint32_t i;%20%20  for (i = 0; i < strlen(word); i++)%20    hash = ((hash << 5) + hash) + word[i];%20%20  return hash & (buckets - 1);%20}%20// ADD YOUR HELPER FUNCTIONS AFTER djb2%20/**%20 * @brief Instantiate a table string%20 *%20 * @param buckets%20 * @return table_string*%20 */%20table_string *table_string_allocate(unsigned int buckets) {%20  // Instantiate a bucket number of heads%20  %20  table_string *ts = malloc(sizeof(table_string));%20  if (ts == NULL) {%20    free(ts);%20    return NULL;%20  }%20%20  ts->buckets = buckets;%20  ts->heads = malloc(buckets * sizeof(vs_entry_t *));%20  if (ts->heads == NULL) {%20    free(ts->heads);%20    free(ts);%20    return NULL;%20  }%20  // Set everything to NULL%20  for (int i = 0; i < buckets; i++) {%20    ts->heads[i] = NULL;%20  }%20%20  return ts;%20}%20%20/**%20 * @brief Insert the string pointed to by word into the table string.%20 *   If word is already found increment count.%20 *   If word is not found insert at the end of the corresponding bucket%20 * @param ts - Pointer to table_string datastructure%20 * @param word - Pointer to string to search for%20 * @return * Find*%20 */%20void table_string_insert_or_add(table_string *ts, char *word, int line) {%20  // Find the bucket for word. djb2 will return a value between 0-buckets-1.%20  // Rule: buckets can only be power of 2.%20  int bucket = djb2_word_to_bucket(word, ts->buckets);%20  // TODO:%20  // Case head == NULL: bucket hasn't been initialized yet%20  // Case word already in list, add to line array.%20  // Case word not found, insert word and return.%20%20  // Validation%20  if (ts == NULL) {%20    return;%20  }%20%20  vs_entry_t *tail = NULL;%20  vs_entry_t *cursor = ts->heads[bucket];%20%20  // Searches array %20  while (cursor != NULL) {%20    // Match found%20    if (my_str_cmp(cursor->value, word) == 0) {%20%20      // Add line to pos array%20      cursor->size_of_pos++;%20      cursor->pos = (int *)realloc(cursor->pos, cursor->size_of_pos * sizeof(int));%20      cursor->pos[cursor->size_of_pos - 1] = line;%20%20      // This is  stupid%20      free(cursor->value);%20      cursor->value = word;%20%20      return;%20    }%20    // No match found, continue searching%20    tail = cursor;%20    cursor = cursor->next;%20  }%20%20  // end of array reached; create new entry%20  vs_entry_t *newNode = malloc(sizeof(vs_entry_t));%20  newNode->value = word;%20  newNode->next = NULL;%20  newNode->size_of_pos = 1;%20  newNode->pos = malloc(1 * sizeof(int));%20  newNode->pos[0] = line;%20%20  if (ts->heads[bucket] == NULL) {  // Bucket has not been initialized%20    ts->heads[bucket] = newNode;%20  } else {                          // Bucket has been initialized%20    tail->next = newNode;%20  }%20%20  return;%20%20}%20%20void table_string_deallocate(table_string *ts) {%20  // TODO:%20  // Free the linked list of each bucket%20  // Free the array of head pointers%20  // Free the structure itself%20%20  if (ts == NULL) {%20    return;%20  }%20%20  vs_entry_t *cursor = NULL;%20  vs_entry_t *temp = NULL;%20%20  for (int i = 0; i < ts->buckets; i++) {%20%20    // Anchor%20    cursor = ts->heads[i];%20%20    while (cursor != NULL) {%20      %20      temp = cursor;%20      cursor = cursor->next;%20      %20      free(temp->pos);%20      temp->pos = NULL;%20      free(temp->value);%20      temp->value = NULL;%20      free(temp);%20    }%20%20  }%20%20  free(ts->heads);%20  free(ts);%20%20  return;%20}%20%20void table_string_print(table_string *ts) {%20  /** TODO:%20   for each bucket%20    for each entry in bucket%20      print entry->word: line line line%20  */%20%20  vs_entry_t *cursor = NULL;%20  %20  // For each bucket%20  for (int i = 0; i < ts->buckets; i++) {%20%20    cursor = ts->heads[i];%20    %20    // debug stuff to show which words are in which bucket%20    printf("===[bucket %d]===\n", i);%20    // Problem: Everything else is working correctly except the for words being mapped to the incorrect bucket.%20%20    // for each entry in bucket%20    while (cursor != NULL) {%20      printf("%s: ", cursor->value);%20      %20      for (int j = 0; j < cursor->size_of_pos; j++) {%20        printf("%d ", cursor->pos[j]);%20      }%20%20      printf("\n");%20%20      cursor = cursor->next;%20    }%20  }%20}%20%20Everything else in this code works as intended, but why are my words not mapping to the correct bucket? | 1
2025-09-14 18:45:29.360 | Query: Explain what I'm supposed to do to write the code of unit_test_strcmp.c%20 | 1
2025-09-14 18:46:36.144 | Query: Debug reason causing segfault:%20void vector_string_deallocate(vector_string *vs) {%20  if (vs == NULL) {%20    return;%20  }%20  %20  vs_entry_t* p = vs->head;%20  vs_entry_t* next;%20%20  while (next != NULL) {%20    next = p->next;%20    free(p);%20    p = next;%20  }%20  p = NULL;%20%20  free(vs);%20  vs = NULL;%20} | 1
2025-09-14 18:47:05.856 |  Query: Debug reason causing segfault:%20void vector_string_deallocate(vector_string *vs) {%20  if (vs == NULL) {%20    return;%20  }%20  %20  vs_entry_t* p = vs->head;%20  vs_entry_t* next;%20%20  while (next != NULL) {%20    next = p->next;%20    free(p);%20    p = next;%20  }%20  p = NULL;%20%20  free(vs);%20  vs = NULL;%20} | Rating: 5  | 1
2025-09-14 20:19:15.577 | Query:  If the size of the pointer is 16 bits, what is the maximum size of the%20 memory ? | 1
2025-09-14 20:22:06.075 | Query: What is the Hex of Decimal 0d111  | 1
2025-09-14 20:25:13.813 | Query: What is the Decimal of Binary 0b11011111 | 1
2025-09-14 21:02:51.093 | Query: Can you explain what we are supposed to do in Assignment 1 part 4?%20 | 1
2025-09-14 21:03:34.074 | Query: Can you explain what we are supposed to do in Assignment 1 part 4?%20Here are the instructions:%20Step 4 Word Pair Search%20%20We are going to build a useful application leveraging existing data structures. Hash-based table strings enable efficient word lookup by partitioning words across buckets. We will implement a consecutive word pair detector. Given two files, find all consecutive word pairs from file 2 that also appear consecutively in file 1, then output each matching pair with its starting position from file 1. The algorithm steps are as follows:%20%20If you open txt/input.txt and txt/small.txt in a text editor and search for word pairs from small [Lorem i],... , you will find that [sit amet] at position 3, then at 32, and then again at 56 and 69. WARNING: print format has to exactly match for tests to pass. See reference%20%20We will now proceed to find the occurences of all word pairs from one file in another.%20%20# Make sure you initialize the table_strings with 8 buckets in duplicate.c%20# The reference output was generated assuming 8 buckets%20# in the table string.%20# If you do not set buckets to 8, then each word will be fine. But the order of the words could be different leading to mismatches against the reference%20%20$ cat reference/input.small.mapcount                                                        %20Lorem i 0%20i dolor 1%20dolor sit 2%20sit amet 3%20sit amet 32%20sit amet 56%20sit amet 69%20%20Example: Word Pair Extraction%20%20Input file (small.txt):%20%20Lorem Lorem i dolor sit amet,%20%20Consecutive word pairs extracted:%20%20    Lorem Lorem (positions 0,1)%20    Lorem i (positions 1,2)%20    i dolor (positions 2,3)%20    dolor sit (positions 3,4)%20    sit amet (positions 4,5)%20%20Search process: For each pair, check if both words appear consecutively in the target file (input.txt). For example, if “Lorem” appears at position 0 and “i” appears at position 1 in input.txt, then the pair “Lorem i” is found and we output: Lorem i 0%20SOURCE FILES%20%20    Create a table string to track the occurrence of words in each file. You will create one table string for file 1 (let’s call it table1).%20    Tokenize the words from file2.%20    Iterate over the words keeping track of pairs of words i.e., the cur word and next.%20    Get all positions of current word - cur_word_pos%20    Get all positons of next word - next_word_pos%20    If there exists i ∈%20%20cur_word_pos and j ∈%20%20    next_word_pos. such that j == i + 1 then we found the word pair.%20    Display it%20%20    table_file1 = table_string_create(file1) %20    words_file2 = tokenize(file2)%20    for i in range(len(words_file2) - 1):%20      cur_word = words_file2[i]%20      next_word = words_file2[i + 1]%20      cur_word_pos = table_string_get_positions(table_file1, cur_word)%20      next_word_pos = table_string_get_positions(table_file1, next_word)%20      for i in cur_word_pos:%20          for j in next_word_pos:%20              if j == i + 1:%20                  print(f"{cur_word} {next_word} {i}"%20%20Filename 	Description%20mapcount.c 	TODO: Implement the mapcount function for searching word pairs from one file in another%20%20There is only one function that you are expected to implement for common word counts:%20Test and Validation%20%20# Make sure you initialize the table_string with 8 buckets in poscount.c%20# The reference output was generated assuming 8 buckets%20# in the table string.%20cd $REPO/word-count%20# Even though binary name says mapcount. Note that you %20# are expected to implement common word count finding algorithm.%20make mapcount.bin %20# To test make sure you are in the parent folder%20cd $REPO %20./word-count/mapcount.bin  ./word-count/txt/input.txt ./word-count/txt/small.txt > ./word-count/out/input.small.ccount%20diff  ./word-count/out/input.small.ccount ./word-count/reference/input.small.ccount%20# To match reference output, you have to run from the $REPO folder.%20 | 1
2025-09-14 21:10:33.621 | Query: git revert는 어떻게 해? | 1
2025-09-14 21:10:47.465 | Query: git revert는 어떻게 해?? | 1
2025-09-14 21:53:52.463 | Query: //Functions that you need to implement:%20%20/*%20 * Append the value x to the end of the arraylist. If necessary, double the%20 * capacity of the arraylist.%20 */%20void arraylist_add(arraylist *a, void *x)%20{%20    // TODO%20} | 1
2025-09-14 22:33:00.237 | Query: while(s1[current_index] != 0 && s2[current_index] != 0)%20Suppose s1 and s2 are strings. Does this while statement sufficiently determine whether or not either string has reached its null terminator?%20 | 1
2025-09-14 22:39:28.620 | Query: int current_index = 0;%20  while(s1[current_index] != 0 && s2[current_index] != 0)%20  {%20    if (s1[current_index] == s2[current_index])%20    {%20      current_index++;%20      continue;%20    }%20    else%20    {%20      return 1;%20    }%20  }%20  if (s1[current_index] == 0 ^ s2[current_index] = 0)%20  {%20    return 1;%20  }%20%20Explain the problem with this code%20 | 1
2025-09-14 22:41:14.945 | Query: If i want to check if one string has reached its null terminator with regard to current_index but the other hasnt, how should i go about this?%20 | 1
2025-09-14 22:51:24.831 | Query: int my_str_cmp(const char *s1, const char *s2) {%20  // TODO: Compare two character arrays. return 0 if they match, 1 otherwise%20  // You can assume that s1 and s2 are null terminated strings.%20  // WARNING: strings could potentially be of different lengths%20  // e.g., "apple" does not match "apple " (which includes the extra space).%20  // Value to be returned will be 1.%20  // You cannot use any of the string helper functions including strlen and%20  // strncmp, strcmp.%20%20  int current_index = 0;%20  while(s1[current_index] != 0 && s2[current_index] != 0)%20  {%20    if (s1[current_index] == s2[current_index])%20    {%20      current_index++;%20      continue;%20    }%20      return 1;%20  }%20  if (s1[current_index] == 0 ^ s2[current_index] == 0)%20  {%20    return 1;%20  }%20  return 0;%20}%20%20With the provided description of what the code should do, explain the code below | 1
2025-09-14 22:52:03.730 | Query: int my_str_cmp(const char *s1, const char *s2) {%20  // TODO: Compare two character arrays. return 0 if they match, 1 otherwise%20  // You can assume that s1 and s2 are null terminated strings.%20  // WARNING: strings could potentially be of different lengths%20  // e.g., "apple" does not match "apple " (which includes the extra space).%20  // Value to be returned will be 1.%20  // You cannot use any of the string helper functions including strlen and%20  // strncmp, strcmp.%20%20  int current_index = 0;%20  while(s1[current_index] != 0 && s2[current_index] != 0)%20  {%20    if (s1[current_index] == s2[current_index])%20    {%20      current_index++;%20      continue;%20    }%20      return 1;%20  }%20  if (s1[current_index] == 0 ^ s2[current_index] == 0)%20  {%20    return 1;%20  }%20  return 0;%20}%20%20With the provided description of what the code should do, explain the code below%20What may be wrong with this code? | 1
2025-09-14 22:59:27.780 | Query: #include <ctype.h>%20#include <fcntl.h>%20#include <stdio.h>%20#include <stdlib.h>%20#include <string.h>%20#include <vector_char.h>%20#include <vector_string.h>%20int main(int argc, char **argv) {%20  char *source = NULL;%20%20  if (argc != 2) {%20    printf("./grade_tokenize.bin [FILE PATH]");%20    exit(1);%20  }%20  /**%20   * @brief Read file into source.%20   * source is a character array with file contents%20   * It is null terminated%20   */%20  FILE *fp = fopen(argv[1], "r");%20  if (fp == NULL) { /* Error */%20    printf("Error reading file");%20    exit(1);%20  }%20  if (fp != NULL) {%20    /* Go to the end of the file. */%20    if (fseek(fp, 0L, SEEK_END) == 0) {%20      /* Get the size of the file. */%20      long bufsize = ftell(fp);%20      if (bufsize == -1) { /* Error */%20        printf("Error reading file");%20      }%20      /* Allocate our buffer to that size. */%20      source = malloc(sizeof(char) * (bufsize + 1));%20      /* Go back to the start of the file. */%20      if (fseek(fp, 0L, SEEK_SET) != 0) { /* Error */%20      }%20      /* Read the entire file into memory. */%20      size_t newLen = fread(source, sizeof(char), bufsize, fp);%20      if (ferror(fp) != 0) {%20        printf("Error reading file");%20      } else {%20        source[newLen++] = '\0'; /* Just to be safe. */%20      }%20    }%20  }%20  fclose(fp);%20%20  vector_string *vs = vector_string_allocate();%20  vector_char_t *vc = vector_char_allocate();%20  for (size_t i =0 ; source[i] != '\0'; i++) {%20    char c = source[i];%20    if (isalpha(c)) {%20      vector_char_add(vc, c);%20    } else {%20     if (vc->len > 0) {%20        vector_char_add(vc, '\0');%20        char *word = vector_char_get_array(vc);%20        if (!vector_string_find(vs, word)) {%20          vector_string_insert(vs, word);%20        }%20        vector_char_delete(vc);%20        vc = vector_char_allocate();%20      }%20    }%20  }%20  if (vc->len > 0) {%20    vector_char_add(vc, '\0');%20    char *word = vector_char_get_array(vc);%20    if (!vector_string_find(vs, word)) {%20      vector_string_insert(vs, word);%20    }%20    free(vc);%20  }%20  vector_string_print(vs);%20  vector_string_deallocate(vs);%20  free(source);%20  return 0;%20} | 1
2025-09-14 22:59:52.055 | Query: #include <ctype.h>%20#include <fcntl.h>%20#include <stdio.h>%20#include <stdlib.h>%20#include <string.h>%20#include <vector_char.h>%20#include <vector_string.h>%20int main(int argc, char **argv) {%20  char *source = NULL;%20%20  if (argc != 2) {%20    printf("./grade_tokenize.bin [FILE PATH]");%20    exit(1);%20  }%20  /**%20   * @brief Read file into source.%20   * source is a character array with file contents%20   * It is null terminated%20   */%20  FILE *fp = fopen(argv[1], "r");%20  if (fp == NULL) { /* Error */%20    printf("Error reading file");%20    exit(1);%20  }%20  if (fp != NULL) {%20    /* Go to the end of the file. */%20    if (fseek(fp, 0L, SEEK_END) == 0) {%20      /* Get the size of the file. */%20      long bufsize = ftell(fp);%20      if (bufsize == -1) { /* Error */%20        printf("Error reading file");%20      }%20      /* Allocate our buffer to that size. */%20      source = malloc(sizeof(char) * (bufsize + 1));%20      /* Go back to the start of the file. */%20      if (fseek(fp, 0L, SEEK_SET) != 0) { /* Error */%20      }%20      /* Read the entire file into memory. */%20      size_t newLen = fread(source, sizeof(char), bufsize, fp);%20      if (ferror(fp) != 0) {%20        printf("Error reading file");%20      } else {%20        source[newLen++] = '\0'; /* Just to be safe. */%20      }%20    }%20  }%20  fclose(fp);%20%20  vector_string *vs = vector_string_allocate();%20  vector_char_t *vc = vector_char_allocate();%20  for (size_t i =0 ; source[i] != '\0'; i++) {%20    char c = source[i];%20    if (isalpha(c)) {%20      vector_char_add(vc, c);%20    } else {%20     if (vc->len > 0) {%20        vector_char_add(vc, '\0');%20        char *word = vector_char_get_array(vc);%20        if (!vector_string_find(vs, word)) {%20          vector_string_insert(vs, word);%20        }%20        vector_char_delete(vc);%20        vc = vector_char_allocate();%20      }%20    }%20  }%20  if (vc->len > 0) {%20    vector_char_add(vc, '\0');%20    char *word = vector_char_get_array(vc);%20    if (!vector_string_find(vs, word)) {%20      vector_string_insert(vs, word);%20    }%20    free(vc);%20  }%20  vector_string_print(vs);%20  vector_string_deallocate(vs);%20  free(source);%20  return 0;%20}%20is there any problem | 1
2025-09-14 23:00:48.016 | Query: #include "vector_string.h"%20#include "str_cmp.h"%20#include <stdbool.h>%20#include <stdint.h>%20#include <stdio.h>%20#include <stdlib.h>%20#include <string.h>%20/**%20/////////////////////////////////////////%20%20*/%20/**%20 * @brief Memory allocate a vector string so that we can start inserting entries%20 * into it.%20 *%20 */%20vector_string *vector_string_allocate() {%20  vector_string *vs = malloc(sizeof(vector_string));%20  if (!vs)%20    return NULL;%20%20  vs->head = NULL;%20  vs->tail = NULL;%20%20  return vs;%20}%20%20/**%20 * @brief Search the vector string pointed to by vs and return true if the%20 * vs_entry.value == key, else return false.%20 * TODO:%20 * @param vs - Pointer to vector_string datastructure%20 * @param key - Pointer to string to search for%20 * @return * Find*%20 */%20bool vector_string_find(vector_string *vs, char *key) { %20  vs_entry_t *temp = vs->head;%20  while (temp != NULL) {%20    if (my_str_cmp(temp->value, key) == 0) {%20      return true;}%20    temp = temp->next;%20  }%20  return false;%20}%20%20/**%20 * @brief TODO: Insert the string pointed to by key into the vector string.%20 *  char* is externally allocated. You do not have to allocate internally%20 *%20 * @param vs - Pointer to vector_string datastructure%20 * @param key - Pointer to string to search for%20 * @return * Find*%20 */%20void vector_string_insert(vector_string *vs, char *key) {%20  if (vs == NULL || key == NULL)%20    return;%20  vs_entry_t *new_entry = malloc(sizeof(vs_entry_t));%20  new_entry->value = key;%20  new_entry->next = NULL;%20%20  if (vs->head == NULL) {%20    vs->head = new_entry;%20    vs->tail = new_entry;%20  } else {%20    vs->tail->next = new_entry;%20    vs->tail = new_entry;%20  }%20}%20/**%20 * @brief Remove all entries and cleanup vector string%20 * TODO: Remove all entries. Remember head and tail are pointers.%20 * Remember to remove vs as well; not just entries. or you will have memory%20 * leaks.%20 * @param vs: Pointer to vector_string struct%20 */%20void vector_string_deallocate(vector_string *vs) {%20  if (vs == NULL) {%20    return;%20  }%20  if (vs->head == NULL) {%20    free(vs);%20    return;%20  }%20  vs_entry_t *temp = vs->head;%20  while (temp != NULL) {%20    vs_entry_t *next = temp->next;%20    free(temp->value);%20    free(temp);%20    temp = next;%20  }%20  free(vs);%20}%20%20/**%20 * @brief Print all value in each entry of the vector string, in the following%20 * format. In this case hello and world are the unique words in the file.%20 * 1. hello%20 * 2. world%20 * @param vs%20 */%20void vector_string_print(vector_string *vs) {%20%20  vs_entry_t *entry = vs->head;%20  int count = 1;%20%20  while (entry != NULL) {%20    printf("%d. %s\n", count, entry->value);%20    entry = entry->next;%20    count++;%20  }%20}%20what is problem | 1
2025-09-15 10:48:12.373 | Query: you know how there is step by step solutions for midterm/quiz questions? is there video walkthroughs as well | 1
2025-09-15 19:13:56.140 | Query: Explain vector_chars functions and usage | 1
2025-09-15 19:20:36.515 | Query: explain how function calls work%20 | 1
2025-09-15 19:26:05.038 | Query: %20Filename	Description%20str_cmp.c	TODO: Implement string compare%20test_str_cmp.c	YOU CANNOT MODIFY THIS FILE. Tester for str_cmp (will not work with gdb)%20unit_test_str_cmp.c	TODO: Write your own unit test case for gdbing%20%20What am I expected to put in the unit_test_str_cmp.c file? | 1
2025-09-15 19:28:23.807 | Query: Explain how to check if a char is alphanumeric or not in C | 1
2025-09-15 19:28:41.116 | Query: Explain how to check if a char is alphanumeric or not in C. Provide alternatives | 1
2025-09-15 19:32:35.176 | Query: can you explain bit level operations in c and provide examples%20%20 | 1
2025-09-15 19:49:21.283 | Query: can you explain how to do addition and subtraction with binary and hex numbers. for binary can you show both msb sign bit notation and twos complement notations as well.%20%20 | 1
2025-09-15 20:14:31.497 | Topic: can you explain how to do addition and subtraction with binary and hex numbers. for binary can you show both msb sign bit notation and twos complement notations as well. | 1
2025-09-15 20:25:11.683 | Query: for the pre integer 2 slides, slide 37, why is 0xFF0000 represent all 1's on the second byte and not the first byte%20%20%20 | 1
2025-09-15 20:26:58.158 | Query: for the pre integer 2 slides, slide 37, why is 0xFF0000 represent all 1's on the second byte and not the first byte for an int value%20%20%20 | 1
2025-09-15 21:03:41.827 | Query: // TODO: Tokenize processing%20  // TODO:source contains the string to be processed.%20  /** Start processing file and separate into words */%20  /** Pseudocode */%20  // 1. Iterate over characters%20  // 2. if current-character starts word start accumulating into vector_char%20  // 3. if current character terminates word. print and restart word start%20  // check. Free all data.%20  // Hint: Use vector_char%20%20  int current_index = 0;%20  vector_char_t *header = vector_char_allocate();%20  while(source[current_index] != 0)%20  {%20    if (isalnum(source[current_index]))%20    {%20    vector_char_add(header, source[current_index]);%20    }%20    else%20    {%20      vector_char_add(header, 0);%20      printf("%s\n", vector_char_get_array(header));%20      vector_char_delete(header);%20      vector_char_t *header = vector_char_allocate();%20    }%20  }%20  vector_char_delete(header);%20%20  return 0;%20}%20%20Explain this issue of this snippet%20 | 1
2025-09-15 21:08:47.851 | Query: // TODO: Tokenize processing%20  // TODO:source contains the string to be processed.%20  /** Start processing file and separate into words */%20  /** Pseudocode */%20  // 1. Iterate over characters%20  // 2. if current-character starts word start accumulating into vector_char%20  // 3. if current character terminates word. print and restart word start%20  // check. Free all data.%20  // Hint: Use vector_char%20%20  int current_index = 0;%20  vector_char_t *header = vector_char_allocate();%20  while(source[current_index] != 0)%20  {%20    if (isalnum(source[current_index]))%20    {%20    vector_char_add(header, source[current_index]);%20    }%20    else%20    {%20      vector_char_add(header, 0);%20      printf("%s\n", vector_char_get_array(header));%20      vector_char_delete(header);%20      vector_char_t *header = vector_char_allocate();%20    }%20  }%20  vector_char_delete(header);%20%20  return 0;%20}%20%20Explain this issue of this snippet%20Explain how I should clear if there is no clear function in the vector_char?%20 | 1
2025-09-15 21:20:00.086 | Query: what is the difference between the types of addresses (heap, stack, static, code)%20 | 1
2025-09-15 21:21:19.648 | Query: what are string literals and why are they allocated in static addresses%20%20 | 1
2025-09-15 21:37:55.686 | Query: Show me how to write a unit test | 1
2025-09-15 21:42:27.646 | Query: %20Filename	Description%20str_cmp.c	TODO: Implement string compare%20test_str_cmp.c	YOU CANNOT MODIFY THIS FILE. Tester for str_cmp (will not work with gdb)%20unit_test_str_cmp.c	TODO: Write your own unit test case for gdbing%20%20What am I expected to put in the unit_test_str_cmp.c file?%20%20this is test_str_cmp.c :%20#include <acutest.h>%20#include <stdint.h>%20#include <str_cmp.h>%20%20struct TestVector {%20  const int index;%20  const char *s1;%20  const char *s2;%20  int expected;%20};%20%20struct TestVector test_vectors[] = {%20    // Inorder,Preorder,Postorder(Expected)%20    {0, "a", "b", 1},%20    {1, "apple", "appl@ ", 1},%20    {2, "apple and oranges", "apple and oranges", 0},%20    {3, "123456", "123456", 0},%20    {4, "342342;", "afasdfsafd;", 1}};%20%20void test(void) {%20  for (int i = 0; i < 5; i++) {%20    int result = my_str_cmp(test_vectors[i].s1, test_vectors[i].s2);%20%20    TEST_CHECK(result == test_vectors[i].expected);%20    TEST_MSG("String s1: %s", test_vectors[i].s1);%20    TEST_MSG("String s2: %s", test_vectors[i].s2);%20  }%20}%20%20TEST_LIST = {{"Test", test}, {NULL, NULL}};%20 | 1
2025-09-15 22:00:27.099 | Query: Is the c "assert" method covered within the first few weeks in this course? | 1
2025-09-15 22:11:00.969 | Query: can you go over the questions in the fall 2020 midterm practice quiz%20%20 | 1
2025-09-15 22:11:26.683 | Topic: can you go over the questions in the fall 2020 midterm practice quiz | 1
2025-09-15 22:11:27.497 | Topic: can you go over the questions in the fall 2020 midterm practice quiz | 1
2025-09-15 22:11:28.141 | Topic: can you go over the questions in the fall 2020 midterm practice quiz | 1
2025-09-15 22:11:28.776 | Topic: can you go over the questions in the fall 2020 midterm practice quiz | 1
2025-09-15 22:11:29.231 | Topic: can you go over the questions in the fall 2020 midterm practice quiz | 1
2025-09-15 22:11:29.729 | Topic: can you go over the questions in the fall 2020 midterm practice quiz | 1
2025-09-15 22:11:30.341 | Topic: can you go over the questions in the fall 2020 midterm practice quiz | 1
2025-09-16 12:44:13.346 | Query: for this function, /*%20 * Return the size of an integer in bytes.%20 *%20 * ALLOWED:%20 *   Pointer operators: *, &%20 *   Binary integer operators: -, +, *%20 *   Unary integer operators: !%20 *   Shorthand operators based on the above: ex. +=, *=, ++, --, eFDIStc.%20 *%20 * DISALLOWED:%20 *   Pointer operators: [] (Array Indexing Operator)%20 *   Binary integer operators: &, &&, |, ||, <, >, <<, >>, ==, !=, ^, /, %%20 *   Unary integer operators: ~, -%20 */%20int intSize() {%20  int intArray[10];%20  int *intPtr1;%20  int *intPtr2;%20  // Write code to compute size of an integer.%20%20  *intPtr1 = 1;%20  *intPtr2 = 2;%20%20  return %20%20  return 2;%20}%20%20do i have to allocate memory with malloc or can i just start intPtr = 1 and just that.%20 | 1
2025-09-16 12:46:56.200 | Query: why does the code (char*)intPtr2 - (char*)intPtr1, compute the difference in bytes?%20 | 1
2025-09-16 13:07:10.601 | Query: how would you implement this. /*%20 * Return the size of a pointer in bytes.%20 *%20 * ALLOWED:%20 *   Pointer operators: *, &%20 *   Binary integer operators: -, +, *%20 *   Unary integer operators: !%20 *   Shorthand operators based on the above: ex. +=, *=, ++, --, etc.%20 *%20 * DISALLOWED:%20 *   Pointer operators: [] (Array Indexing Operator)%20 *   Binary integer operators: &, &&, |, ||, <, >, <<, >>, ==, !=, ^, /, %%20 *   Unary integer operators: ~, -%20 */%20int pointerSize() {%20  double *ptrArray[10];%20  double **ptrPtr1;%20  double **ptrPtr2;%20  // Write code to compute size of a pointer.%20%20  ptrPtr1 = ptrArray;%20  ptrPtr2 = ptrArray + 1;%20%20  return ptrPtr2 - ptrPtr1;%20} | 1
2025-09-16 13:10:13.896 | Query: how would you implement this. /*%20 * Return the size of a pointer in bytes.%20 *%20 * ALLOWED:%20 *   Pointer operators: *, &%20 *   Binary integer operators: -, +, *%20 *   Unary integer operators: !%20 *   Shorthand operators based on the above: ex. +=, *=, ++, --, etc.%20 *%20 * DISALLOWED:%20 *   Pointer operators: [] (Array Indexing Operator)%20 *   Binary integer operators: &, &&, |, ||, <, >, <<, >>, ==, !=, ^, /, %%20 *   Unary integer operators: ~, -%20 */%20int pointerSize() {%20  double *ptrArray[10];%20  double **ptrPtr1;%20  double **ptrPtr2;%20  // Write code to compute size of a pointer.%20%20  ptrPtr1 = ptrArray;%20  ptrPtr2 = ptrArray + 1;%20%20  return ptrPtr2 - ptrPtr1;%20}%20%20do i have to initialize the values for ptrPtr1 after giving them their adrress so i can get the size | 1
2025-09-16 18:02:11.463 | Query: Explain how to initialize and allocate memory for a linked list in C. | 1
2025-09-16 18:04:16.700 | Query: Explain how to initialize and allocate memory for a linked list in C, the header included | 1
2025-09-16 18:20:59.916 | Query: int current_index = 0;%20  vector_char_t *header = vector_char_allocate();%20  while(source[current_index] != 0)%20  {%20    if ((source[current_index] >= 65 && source[current_index] <= 90) ||%20        (source[current_index] >= 97 && source[current_index] <= 122) ||%20        (source[current_index] >= 48 && source[current_index] <= 57))%20...%20explain how i can optimize this without using alnum() | 1
2025-09-16 19:56:39.558 | Query: Debug segfault:%20vector_string *vector_string_allocate() {%20  vector_string* vs = (vector_string*) malloc(sizeof(vector_string));%20  %20  if (vs == NULL) {%20    return NULL;%20  }%20%20  vs->head = (vs_entry_t*) malloc(sizeof(vs_entry_t));%20  vs->tail = vs->head;%20  vs->head->value = NULL;%20  vs->head->next = NULL;%20%20  return vs;%20}%20void vector_string_insert(vector_string *vs, char *key) {%20  if (vector_string_find(vs, key)) {%20    return;%20  }%20  %20  vs_entry_t* add = (vs_entry_t*) malloc(sizeof(vs_entry_t));%20  add->next = NULL;%20  add->value = key;%20%20  if (vs->head == NULL && vs->tail == NULL) {%20    vs->head = add;%20    vs->tail = add;%20%20  } else {%20    vs->tail->next = add;%20    vs->tail = add;%20%20  }%20  %20} | 1
2025-09-16 20:19:17.988 | Query: Debug segfault:%20vector_string *vector_string_allocate() {%20  vector_string* vs = (vector_string*) malloc(sizeof(vector_string));%20  %20  if (vs == NULL) {%20    return NULL;%20  }%20%20  vs->head = NULL;%20  vs->head->value = NULL;%20  vs->head->next = NULL;%20  vs->tail = vs->head;%20%20  return vs;%20}%20%20void vector_string_insert(vector_string *vs, char *key) {%20  // Insert the string into the tail of the list.%20  if (vs == NULL) {%20    return;%20  }%20%20  if (vector_string_find(vs, key)) {%20    return;%20  }%20  %20  vs_entry_t* add = (vs_entry_t*) malloc(sizeof(vs_entry_t));%20  if (add == NULL) {%20    return;%20  }%20  add->next = NULL;%20  add->value = key;%20%20  if (vs->head == NULL && vs->tail == NULL) {%20    vs->head = add;%20    vs->tail = add;%20%20  } else {%20    vs->tail->next = add;%20    vs->tail = add;%20%20  }%20  %20} | 1
2025-09-16 20:20:14.915 | Query: Debug segfault:%20vector_string *vector_string_allocate() {%20  vector_string* vs = (vector_string*) malloc(sizeof(vector_string));%20  %20  if (vs == NULL) {%20    return NULL;%20  }%20%20  vs->head = NULL;%20  vs->tail = vs->head;%20%20  return vs;%20}%20%20void vector_string_insert(vector_string *vs, char *key) {%20  // Insert the string into the tail of the list.%20  if (vs == NULL) {%20    return;%20  }%20%20  if (vector_string_find(vs, key)) {%20    return;%20  }%20  %20  vs_entry_t* add = (vs_entry_t*) malloc(sizeof(vs_entry_t));%20  if (add == NULL) {%20    return;%20  }%20  add->next = NULL;%20  add->value = key;%20%20  if (vs->head == NULL && vs->tail == NULL) {%20    vs->head = add;%20    vs->tail = add;%20%20  } else {%20    vs->tail->next = add;%20    vs->tail = add;%20%20  }%20  %20} | 1
2025-09-16 20:22:37.989 | Query: how can i finish this function with what i have written in their now. /*%20 * Return 1 if the addresses stored in ptr1 and ptr2 are within the%20 * *same* 64-byte aligned  block of memory. Check the spec for examples if you%20 * are confused about what this means. Return zero otherwise. Operators / and %%20 * and loops are NOT allowed.%20 *%20 * ALLOWED:%20 *   Pointer operators: *, &%20 *   Binary integer operators: -, +, *, <<, >>, ==, ^%20 *   Unary integer operators: !, ~%20 *   Shorthand operators based on the above: ex. <<=, *=, ++, --, etc.%20 *%20 * DISALLOWED:%20 *   Pointer operators: [] (Array Indexing Operator)%20 *   Binary integer operators: &, &&, |, ||, <, >, !=, /, %%20 *   Unary integer operators: -%20 */%20int withinSameBlock(int *ptr1, int *ptr2) {%20  // Your code here%20%20%20  return ((long int)ptr2 - (long int)ptr1) ;%20}%20%20 | 1
2025-09-16 20:33:48.325 | Query: Debug segfault:%20vector_string *vector_string_allocate() {%20  vector_string* vs = (vector_string*) malloc(sizeof(vector_string));%20  %20  if (vs == NULL) {%20    return NULL;%20  }%20%20  vs->head = NULL;%20  vs->tail = vs->head;%20%20  return vs;%20}%20%20void vector_string_insert(vector_string *vs, char *key) {%20  // Insert the string into the tail of the list.%20  if (vs == NULL) {%20    return;%20  }%20%20  if (vector_string_find(vs, key)) {%20    return;%20  }%20  %20  vs_entry_t* add = (vs_entry_t*) malloc(sizeof(vs_entry_t));%20  if (add == NULL) {%20    return;%20  }%20  add->next = NULL;%20  add->value = key;%20%20  if (vs->head == NULL && vs->tail == NULL) {%20    vs->head = add;%20    vs->tail = add;%20%20  } else {%20    vs->tail->next = add;%20    vs->tail = add;%20%20  }%20  %20}%20%20void vector_string_print(vector_string *vs) {%20  int count = 1;%20%20  vs_entry_t *entry = vs->head;%20  while (entry->next != NULL) {%20    printf("%d. %s\n", count, entry->value);%20    entry = entry->next;%20    count++;%20  }%20} | 1
2025-09-16 20:34:39.368 | Query: Debug segfault:%20vector_string *vector_string_allocate() {%20  vector_string* vs = (vector_string*) malloc(sizeof(vector_string));%20  %20  if (vs == NULL) {%20    return NULL;%20  }%20%20  vs->head = NULL;%20  vs->tail = vs->head;%20%20  return vs;%20}%20%20void vector_string_print(vector_string *vs) {%20  int count = 1;%20%20  vs_entry_t *entry = vs->head;%20  while (entry->next != NULL) {%20    printf("%d. %s\n", count, entry->value);%20    entry = entry->next;%20    count++;%20  }%20} | 1
2025-09-16 20:42:34.389 | Query: Debug insert not adding:%20called by:%20      char* word_ptr = vector_char_get_array(word);%20      vector_string_insert(vs, word_ptr);%20%20vector_string *vector_string_allocate() {%20  vector_string* vs = (vector_string*) malloc(sizeof(vector_string));%20  %20  if (vs == NULL) {%20    return NULL;%20  }%20%20  vs->head = NULL;%20  vs->tail = vs->head;%20%20  return vs;%20}%20%20void vector_string_insert(vector_string *vs, char *key) {%20  // Insert the string into the tail of the list.%20  if (vs == NULL) {%20    return;%20  }%20%20  if (vs->head != NULL && vector_string_find(vs, key)) {%20    return;%20  }%20  %20  vs_entry_t* add = (vs_entry_t*) malloc(sizeof(vs_entry_t));%20  if (add == NULL) {%20    return;%20  }%20  add->next = NULL;%20  add->value = key;%20%20  if (vs->head == NULL && vs->tail == NULL) {%20    vs->head = add;%20    vs->tail = add;%20%20  } else {%20    vs->tail->next = add;%20    vs->tail = add;%20%20  } | 1
2025-09-16 20:54:24.190 | Query: Debug insert not adding:%20called by:%20      char* word_ptr = vector_char_get_array(word);%20      vector_string_insert(vs, word_ptr);%20%20void vector_string_insert(vector_string *vs, char *key) {%20  // Insert the string into the tail of the list.%20  if (vs == NULL) {%20    return;%20  }%20%20  if (vs->head != NULL && vector_string_find(vs, key)) {%20    return;%20  }%20  %20  vs_entry_t* add = (vs_entry_t*) malloc(sizeof(vs_entry_t));%20  if (add == NULL) {%20    return;%20  }%20  add->next = NULL;%20  int size = 0;%20  while (key[size] != '\0') {%20    size++;%20  }%20  add->value = (char*) malloc(sizeof(char) * size);%20  add->value = key;%20%20  if (vs->head == NULL && vs->tail == NULL) {%20    vs->head = add;%20    vs->tail = add;%20%20  } else {%20    vs->tail->next = add;%20    vs->tail = add;%20%20  }%20  %20} | 1
2025-09-16 20:54:50.211 | Query: /**%20 * @brief Remove all entries and cleanup vector string%20 * TODO: Remove all entries. Remember head and tail are pointers.%20 * Remember to remove vs as well; not just entries. or you will have memory%20 * leaks.%20 * @param vs: Pointer to vector_string struct%20 */%20void vector_string_deallocate(vector_string *vs) %20{%20  if (!vs) {return;}%20}%20%20Explain how to go about this | 1
2025-09-16 20:55:22.992 | Query: /**%20 * @brief Remove all entries and cleanup vector string%20 * TODO: Remove all entries. Remember head and tail are pointers.%20 * Remember to remove vs as well; not just entries. or you will have memory%20 * leaks.%20 * @param vs: Pointer to vector_string struct%20 */%20void vector_string_deallocate(vector_string *vs) %20{%20  if (!vs) {return;}%20}%20%20Explain how to go about this. Its a linked list | 1
2025-09-16 21:07:35.039 | Query: Debug insert not adding:%20called by:%20      vector_char_add(word, '\0');%20%20      char* word_ptr = (char*) malloc(sizeof(char) * word->len);%20      word_ptr = vector_char_get_array(word);%20      printf("%s\n", word_ptr);%20%20      vector_string_insert(vs, word_ptr);%20%20      vector_char_delete(word);%20      word = vector_char_allocate();%20%20void vector_string_insert(vector_string *vs, char *key) {%20  // Insert the string into the tail of the list.%20  if (vs == NULL) {%20    return;%20  }%20%20  if (vs->head != NULL && vector_string_find(vs, key)) {%20    return;%20  }%20  %20  vs_entry_t* add = (vs_entry_t*) malloc(sizeof(vs_entry_t));%20  if (add == NULL) {%20    return;%20  }%20  add->next = NULL;%20  int size = 0;%20  while (key[size] != '\0') {%20    size++;%20  }%20  add->value = (char*) malloc(sizeof(char) * size);%20  add->value = key;%20%20  if (vs->head == NULL && vs->tail == NULL) {%20    vs->head = add;%20    vs->tail = add;%20%20  } else {%20    vs->tail->next = add;%20    vs->tail = add;%20%20  }%20  %20} | 1
2025-09-16 21:08:06.424 | Query: Debug insert not adding:%20called by:%20      vector_char_add(word, '\0');%20%20      char* word_ptr = (char*) malloc(sizeof(char) * word->len);%20      word_ptr = vector_char_get_array(word);%20      printf("%s\n", word_ptr);%20%20      vector_string_insert(vs, word_ptr);%20%20      vector_char_delete(word);%20      word = vector_char_allocate();%20%20void vector_string_insert(vector_string *vs, char *key) {%20  // Insert the string into the tail of the list.%20  if (vs == NULL) {%20    return;%20  }%20%20  if (vs->head != NULL && vector_string_find(vs, key)) {%20    return;%20  }%20  %20  vs_entry_t* add = (vs_entry_t*) malloc(sizeof(vs_entry_t));%20  if (add == NULL) {%20    return;%20  }%20  add->next = NULL;%20  add->value = key;%20%20  if (vs->head == NULL && vs->tail == NULL) {%20    vs->head = add;%20    vs->tail = add;%20%20  } else {%20    vs->tail->next = add;%20    vs->tail = add;%20%20  }%20  %20} | 1
2025-09-16 21:27:09.661 | Query: Debug insert, not adding. Key is allocated externally:%20called by:%20      vector_char_add(word, '\0');%20%20      char* word_ptr = (char*) malloc(sizeof(char) * word->len);%20      word_ptr = vector_char_get_array(word);%20      printf("%s\n", word_ptr);%20%20      vector_string_insert(vs, word_ptr);%20%20      vector_char_delete(word);%20      word = vector_char_allocate();%20%20void vector_string_insert(vector_string *vs, char *key) {%20  // Insert the string into the tail of the list.%20  if (vs == NULL) {%20    return;%20  }%20%20  if (vs->head != NULL && vector_string_find(vs, key)) {%20    return;%20  }%20  %20  vs_entry_t* add = (vs_entry_t*) malloc(sizeof(vs_entry_t));%20  if (add == NULL) {%20    return;%20  }%20  add->next = NULL;%20  add->value = key;%20%20  if (vs->head == NULL && vs->tail == NULL) {%20    vs->head = add;%20    vs->tail = add;%20%20  } else {%20    vs->tail->next = add;%20    vs->tail = add;%20%20  }%20  %20} | 1
2025-09-16 22:11:26.043 | Query: Why does word_ptr[j] cause a segfault even though memory has been allocated?%20Debug:%20int count = 0;%20  vector_string* vs = vector_string_allocate();%20  vector_char_t* word = vector_char_allocate();%20%20%20  int i = 0;%20  while (source[i] != '\0') {%20%20    if ((source[i] >= 65 && source[i] <= 90) || (source[i] >= 97 && source[i] <= 122)) {%20      vector_char_add(word, source[i]);%20%20    } else {%20      vector_char_add(word, '\0');%20%20      char* word_ptr = (char*) malloc(sizeof(char) * word->len);%20      char* temp = vector_char_get_array(word);%20      for (int j = 0; j < word->len; j++) {%20        word_ptr[j] = temp[j];%20      }%20%20      printf("KEY: %s\n", word_ptr);%20%20      vector_string_insert(vs, word_ptr);%20%20      vector_char_delete(word);%20      word = vector_char_allocate();%20%20    }%20    i++;%20  }%20%20  vector_string_print(vs);%20%20  vector_string_deallocate(vs);%20  vector_char_delete(word);%20 | 1
2025-09-17 13:04:10.369 | Query: Check Yourself%20Have you read tutorials page and set up either VM or have CSIL Access?%20Have you read the linux section on the tutorials page?%20Have you read the C section on the tutorials page?%20Have you read the modules%20Do you know how to run cgdb on CSIL machines or VM? If not read here%20Don't proceed without knowing how to run this program in a terminal%20#include <stdio.h>%20void main() {%20  printf("Hello World");%20}%20Labs are essential to your learning and you should not skip them.%20Computer programming is inherently an applied exercise, and you will not learn much if you do not practice.%20Debugging code is an essential part of programming.%20Details%20Please use Rooms 9838 and 9700 if you want ready access to TAs. You can also use room 9804, but then TAs may not be able to provide timely advice.%20Labs are designed to take approximately 1 hour.%20Watch lab videos before the lab. TAs will dedicate the majority of the time for lab tasks only.%20TAs will not be going over the pre-req that prior courses have outlined see here%20Go over lab tasks before the lab. TAs will walk through the slides (if any) and handouts.%20TAs will only guide, they will not provide the complete solution.%20The staff recommends always asking for help on labs when you need it.%20We do recognize the value of AI bots to enhance learning in labs. You can use any AI Bot; however you see fit. May we recommend 295’s Bot ChatGPT here.%20%20%20help me follow these%20 | 1
2025-09-17 14:15:58.258 | Query: Explain how function calls work in RISC-V | 1
2025-09-17 16:21:36.142 | Query: Explain how heads would be iterated%20typedef struct table_string {%20  vs_entry_t **heads; // Array to maintain the heads of each bucket.%20  int buckets;        // Buckets can only be a power of 2.%20} table_string;%20%20%20typedef struct vs_entry {%20  char *value;%20  struct vs_entry *next;%20%20#ifdef POS_COUNT%20  int* pos; // This keeps track of each pos the word is found in%20  int  size_of_pos; // This keeps size of pos. Remember in C we track array size explicitly.%20#endif%20} vs_entry_t;%20 | 1
2025-09-17 16:34:48.572 | Query: If the size of the pointer is 24 bits, what is the maximum size of the%20memory | 1
2025-09-17 16:35:55.987 | Query: If the size of the memory is 1024.0 kilobytes what is the number of%20bits required ? | 1
2025-09-17 16:53:51.826 | Query: is x=memmove(x,...) equivalent to memmove(x, ...) is there any benefit to one%20 | 1
2025-09-17 17:15:07.723 | Query: %20debug double free:%20table_string *table_string_allocate(unsigned int buckets) {%20  // Instantiate a bucket number of heads%20  table_string* ts = (table_string*) malloc(sizeof(table_string));%20%20  for (int i = 0; i < buckets; i++) {%20    vs_entry_t *b = (vs_entry_t*) malloc(sizeof(vs_entry_t));%20    b = NULL;%20    ts->heads[i] = b;%20  }%20  ts->buckets = buckets;%20%20  return ts;%20}%20void table_string_insert_or_add(table_string *ts, char *word, int line) {%20  // Find the bucket for word. djb2 will return a value between 0-buckets-1.%20  // Rule: buckets can only be power of 2.%20  int bucket = djb2_word_to_bucket(word, ts->buckets);%20  // TODO:%20  // Case head == NULL: bucket hasn't been initialized yet%20  // Case word already in list, add to line array.%20  // Case word not found, insert word and return.%20  vs_entry_t* b = ts->heads[bucket];%20%20  if (b == NULL) {%20    b = (vs_entry_t*) malloc(sizeof(vs_entry_t));%20    b->pos = (int*) malloc(sizeof(int));%20    b->size_of_pos = 1;%20    %20    b->pos[0] = line;%20    b->value = word;%20    b->next = NULL;%20    return;%20  }%20%20  vs_entry_t* p = b;%20%20  while (p->next != NULL) {%20    if (!my_str_cmp(word, p->value)) {%20      p->pos = (int*) realloc(p->pos, sizeof(int) * p->size_of_pos + 1);%20      p->pos[p->size_of_pos] = line;%20      p->size_of_pos++;%20      return;%20%20    } else {%20      p = p->next;%20%20    }%20  }%20  %20  vs_entry_t* add = (vs_entry_t*) malloc(sizeof(vs_entry_t));%20  add->pos[0] = line;%20  add->size_of_pos = 1;%20  add->value = word;%20  add->next = NULL;%20  p->next = add;%20%20%20  return;%20}%20void table_string_deallocate(table_string *ts) {%20  // TODO:%20  // Free the linked list of each bucket%20  // Free the array of head pointers%20  // Free the structure itself%20  for (int i = 0; i < ts->buckets; i++) {%20%20    vs_entry_t* p = ts->heads[i];%20    vs_entry_t* next = p;;%20%20    while (next != NULL) {%20      next = p->next;%20      free(p);%20      p = next;%20    }%20    p = NULL;%20%20  }%20%20  // free(ts->heads);%20  free(ts);%20%20  return;%20} | 1
2025-09-17 17:35:43.356 | Query: how to properly initialize%20typedef struct table_string {%20  vs_entry_t **heads; // Array to maintain the heads of each bucket.%20  int buckets;        // Buckets can only be a power of 2.%20} table_string;%20%20typedef struct vs_entry {%20  char *value;%20  struct vs_entry *next;%20%20// Conditionally compiled in code. Not relevant for part 2. You can assume the%20// int count declaration does not exist and is irrelevant for part 2.%20#ifdef POS_COUNT%20  int* pos; // This keeps track of each pos the word is found in%20  int  size_of_pos; // This keeps size of pos. Remember in C we track array size explicitly.%20#endif%20} vs_entry_t;%20%20table_string *table_string_allocate(unsigned int buckets) {%20  // Instantiate a bucket number of heads%20  table_string* ts = (table_string*) malloc(sizeof(table_string));%20%20  for (int i = 0; i < buckets; i++) {%20%20    ts->heads[i] = NULL;%20  }%20  ts->buckets = buckets;%20%20  return ts;%20} | 1
2025-09-17 17:56:00.554 | Query: Debug memory leaks: %20void table_string_insert_or_add(table_string *ts, char *word, int line) {%20  int bucket = djb2_word_to_bucket(word, ts->buckets);%20  vs_entry_t* b = ts->heads[bucket];%20%20  if (b == NULL) {%20    b = (vs_entry_t*) malloc(sizeof(vs_entry_t));%20    b->pos = (int*) malloc(sizeof(int));%20    b->size_of_pos = 1;%20    %20    b->pos[0] = line;%20    b->value = word;%20    b->next = NULL;%20    ts->heads[bucket] = b;%20    return;%20  }%20%20  vs_entry_t* p = b;%20%20  while (p->next != NULL) {%20    if (!my_str_cmp(word, p->value)) {%20      p->pos = (int*) realloc(p->pos, sizeof(int) * p->size_of_pos + 1);%20      p->pos[p->size_of_pos] = line;%20      p->size_of_pos++;%20      return;%20%20    } else {%20      p = p->next;%20%20    }%20  }%20  %20  vs_entry_t* add = (vs_entry_t*) malloc(sizeof(vs_entry_t));%20  add->pos = (int*) malloc(sizeof(int));%20  add->pos = line;%20  add->size_of_pos = 1;%20  add->value = word;%20  add->next = NULL;%20  p->next = add;%20%20} | 1
2025-09-17 18:06:15.705 | Query: How to initalize pos correctly.%20typedef struct table_string {%20  vs_entry_t **heads; // Array to maintain the heads of each bucket.%20  int buckets;        // Buckets can only be a power of 2.%20} table_string;%20%20typedef struct vs_entry {%20  char *value;%20  struct vs_entry *next;%20%20#ifdef POS_COUNT%20  int* pos; // This keeps track of each pos the word is found in%20  int  size_of_pos; // This keeps size of pos. Remember in C we track array size explicitly.%20#endif%20} vs_entry_t; | 1
2025-09-17 18:08:04.209 | Query: How to initalize pos correctly and resize it.%20typedef struct table_string {%20  vs_entry_t **heads; // Array to maintain the heads of each bucket.%20  int buckets;        // Buckets can only be a power of 2.%20} table_string;%20%20typedef struct vs_entry {%20  char *value;%20  struct vs_entry *next;%20%20#ifdef POS_COUNT%20  int* pos; // This keeps track of each pos the word is found in%20  int  size_of_pos; // This keeps size of pos. Remember in C we track array size explicitly.%20#endif%20} vs_entry_t;%20%20void table_string_insert_or_add(table_string *ts, char *word, int line) {%20  // Find the bucket for word. djb2 will return a value between 0-buckets-1.%20  // Rule: buckets can only be power of 2.%20  int bucket = djb2_word_to_bucket(word, ts->buckets);%20  // TODO:%20  // Case head == NULL: bucket hasn't been initialized yet%20  // Case word already in list, add to line array.%20  // Case word not found, insert word and return.%20  vs_entry_t* b = ts->heads[bucket];%20%20  if (b == NULL) {%20    vs_entry_t* add = (vs_entry_t*) malloc(sizeof(vs_entry_t));%20    add->pos = (int*) malloc(1 * sizeof(int));%20    add->size_of_pos = 1;%20    %20    add->pos[0] = line;%20    add->value = word;%20    add->next = NULL;%20    ts->heads[bucket] = add;%20    return;%20  }%20%20  vs_entry_t* p = b;%20%20  while (p->next != NULL) {%20    if (!my_str_cmp(word, p->value)) {%20      int* newPos = (int*) realloc(p->pos, sizeof(int) * p->size_of_pos + 1);%20      free(p->pos);%20      p->pos = newPos;%20      p->pos[p->size_of_pos] = line;%20      p->size_of_pos++;%20      return;%20%20    } else {%20      p = p->next;%20%20    }%20  }%20  %20  vs_entry_t* add = (vs_entry_t*) malloc(sizeof(vs_entry_t));%20  add->pos = (int*) malloc(1 * sizeof(int));%20  add->pos[0] = line;%20  add->size_of_pos = 1;%20  add->value = word;%20  add->next = NULL;%20  p->next = add;%20%20} | 1
2025-09-17 18:16:48.856 | Query: Debug:       char* word_ptr = (char*) malloc(sizeof(char) * word->len - 1); leaks 5 bytes%20%20%20#include <ctype.h>%20#include <fcntl.h>%20#include <stdio.h>%20#include <stdlib.h>%20#include <string.h>%20#include <vector_char.h>%20#include <vector_string.h>%20int main(int argc, char **argv) {%20  char *source = NULL;%20%20  if (argc != 2) {%20    printf("./grade_tokenize.bin [FILE PATH]");%20    exit(1);%20  }%20  /**%20   * @brief Read file into source.%20   * source is a character array with file contents%20   * It is null terminated%20   */%20  FILE *fp = fopen(argv[1], "r");%20  if (fp == NULL) { /* Error */%20    printf("Error reading file");%20    exit(1);%20  }%20  if (fp != NULL) {%20    /* Go to the end of the file. */%20    if (fseek(fp, 0L, SEEK_END) == 0) {%20      /* Get the size of the file. */%20      long bufsize = ftell(fp);%20      if (bufsize == -1) { /* Error */%20        printf("Error reading file");%20      }%20      /* Allocate our buffer to that size. */%20      source = malloc(sizeof(char) * (bufsize + 1));%20      /* Go back to the start of the file. */%20      if (fseek(fp, 0L, SEEK_SET) != 0) { /* Error */%20      }%20      /* Read the entire file into memory. */%20      size_t newLen = fread(source, sizeof(char), bufsize, fp);%20      if (ferror(fp) != 0) {%20        printf("Error reading file");%20      } else {%20        source[newLen++] = '\0'; /* Just to be safe. */%20      }%20    }%20  }%20  fclose(fp);%20%20  // TODO: Process source[] and count the number of words%20  // Print the number of words in the end.%20  int count = 0;%20  vector_string* vs = vector_string_allocate();%20  vector_char_t* word = vector_char_allocate();%20%20%20  int i = 0;%20  while (source[i] != '\0') {%20%20    if ((source[i] >= 65 && source[i] <= 90) || (source[i] >= 97 && source[i] <= 122)) {%20      vector_char_add(word, source[i]);%20%20    } else {%20      vector_char_add(word, '\0');%20%20      char* word_ptr = (char*) malloc(sizeof(char) * word->len - 1);%20      char* temp = vector_char_get_array(word);%20      for (int j = 0; j < word->len - 1; j++) {%20        word_ptr[j] = temp[j];%20      }%20      word_ptr[word->len - 1] = '\0';%20%20      vector_string_insert(vs, word_ptr);%20%20      vector_char_delete(word);%20      word = vector_char_allocate();%20%20    }%20    i++;%20  }%20%20  vector_string_print(vs);%20%20  vector_string_deallocate(vs);%20  vector_char_delete(word);%20%20  free(source);%20%20  return 0;%20} | 1
2025-09-17 18:27:21.090 | Query: Debug infinate loop;%20void table_string_print(table_string *ts) {%20  /** TODO:%20   for each bucket%20    for each entry in bucket%20      print entry->word: line line line%20  */%20  if (ts == NULL || ts->heads == NULL) {%20    return;%20  }%20%20  for (int i = 0; i < ts->buckets; i++) {%20    vs_entry_t* p = ts->heads[i];%20%20    while (p != NULL) {%20      printf("%s: ", p->value);%20%20      for (int j = 0; j < p->size_of_pos; j++) {%20        printf("%d ", p->pos[j]);%20      }%20      printf("\n");%20    }%20%20  }%20}%20 | 1
2025-09-17 18:48:09.050 | Query: Conditional jump or move depends on uninitialised value%20 for (int j = 0; j < p->size_of_pos; j++) {%20        printf("%d ", p->pos[j]);%20      }%20%20typedef struct vs_entry {%20  char *value;%20  struct vs_entry *next;%20%20// Conditionally compiled in code. Not relevant for part 2. You can assume the%20// int count declaration does not exist and is irrelevant for part 2.%20#ifdef POS_COUNT%20  int* pos; // This keeps track of each pos the word is found in%20  int  size_of_pos; // This keeps size of pos. Remember in C we track array size explicitly.%20#endif%20} vs_entry_t;%20%20typedef struct table_string {%20  vs_entry_t **heads; // Array to maintain the heads of each bucket.%20  int buckets;        // Buckets can only be a power of 2.%20} table_string; | 1
2025-09-17 18:57:16.858 | Query: Debug:%20#include "table_string.h"%20#include "str_cmp.h"%20#include <stdbool.h>%20#include <stdint.h>%20#include <stdio.h>%20#include <stdlib.h>%20#include <string.h>%20%20#define BUCKETS%20// DO NOT ADD ANY NEW FUNCTIONS BEFORE djb2%20// Hash a character array to integer value between 0 and buckets-1.%20// See here for more details: https://theartincode.stanis.me/008-djb2/%20unsigned int djb2_word_to_bucket(char *word, int buckets) {%20  if (!word) {%20    printf("Invoked with null string");%20    exit(EXIT_FAILURE);%20  }%20  unsigned long hash = 5381;%20  uint32_t i;%20%20  for (i = 0; i < strlen(word); i++)%20    hash = ((hash << 5) + hash) + word[i];%20%20  return hash & (buckets - 1);%20}%20// ADD YOUR HELPER FUNCTIONS AFTER djb2%20/**%20 * @brief Instantiate a table string%20 *%20 * @param buckets%20 * @return table_string*%20 */%20table_string *table_string_allocate(unsigned int buckets) {%20  // Instantiate a bucket number of heads%20  table_string* ts = (table_string*) malloc(sizeof(table_string));%20%20%20  ts->heads = (vs_entry_t**) malloc(buckets * sizeof(vs_entry_t*));%20%20  for (int i = 0; i < buckets; i++) {%20    ts->heads[i] = NULL;%20  }%20  ts->buckets = buckets;%20%20  return ts;%20}%20%20/**%20 * @brief Insert the string pointed to by word into the table string.%20 *   If word is already found increment count.%20 *   If word is not found insert at the end of the corresponding bucket%20 * @param ts - Pointer to table_string datastructure%20 * @param word - Pointer to string to search for%20 * @return * Find*%20 */%20void table_string_insert_or_add(table_string *ts, char *word, int line) {%20  // Find the bucket for word. djb2 will return a value between 0-buckets-1.%20  // Rule: buckets can only be power of 2.%20  int bucket = djb2_word_to_bucket(word, ts->buckets);%20  // TODO:%20  // Case head == NULL: bucket hasn't been initialized yet%20  // Case word already in list, add to line array.%20  // Case word not found, insert word and return.%20  vs_entry_t* b = ts->heads[bucket];%20%20  if (b == NULL) {%20    vs_entry_t* add = (vs_entry_t*) malloc(sizeof(vs_entry_t));%20    add->pos = (int*) malloc(sizeof(int) * 1);%20    add->size_of_pos = 1;%20    %20    add->pos[0] = line;%20    add->value = word;%20    add->next = NULL;%20    ts->heads[bucket] = add;%20    return;%20  }%20%20  vs_entry_t* p = b;%20%20  while (p->next != NULL) {%20    if (!my_str_cmp(word, p->value)) {%20      int* newPos = (int*) realloc(p->pos, sizeof(int) * p->size_of_pos + 1);%20      p->pos = newPos;%20      p->pos[p->size_of_pos] = line;%20      p->size_of_pos++;%20      return;%20%20    } else {%20      p = p->next;%20%20    }%20  }%20  %20  vs_entry_t* add = (vs_entry_t*) malloc(sizeof(vs_entry_t));%20  add->pos = (int*) malloc(sizeof(int) * 1);%20  add->pos[0] = line;%20  add->size_of_pos = 1;%20  add->value = word;%20  add->next = NULL;%20  p->next = add;%20%20}%20%20void table_string_deallocate(table_string *ts) {%20  // TODO:%20  // Free the linked list of each bucket%20  // Free the array of head pointers%20  // Free the structure itself%20  for (int i = 0; i < ts->buckets; i++) {%20%20    vs_entry_t* p = ts->heads[i];%20    vs_entry_t* next = p;;%20%20    while (next != NULL) {%20      next = p->next;%20      free(p->pos);%20      free(p->value);%20      free(p);%20      p = next;%20    }%20    p = NULL;%20%20  }%20%20  free(ts->heads);%20  free(ts);%20%20  return;%20}%20%20void table_string_print(table_string *ts) {%20  /** TODO:%20   for each bucket%20    for each entry in bucket%20      print entry->word: line line line%20  */%20  if (ts == NULL || ts->heads == NULL) {%20    return;%20  }%20%20  for (int i = 0; i < ts->buckets; i++) {%20    vs_entry_t* p = ts->heads[i];%20%20    while (p != NULL) {%20      printf("%s: ", p->value);%20%20      for (int j = 0; j < p->size_of_pos; j++) {%20        printf("%d ", p->pos[j]);%20      }%20      printf("\n");%20%20      p = p->next;%20    }%20%20  }%20}%20%20int buckets = 4;%20  table_string *ts = table_string_allocate(buckets);%20%20  vector_char_t* word = vector_char_allocate();%20%20%20  int i = 0;%20  int line = 0;%20%20  while (source[i] != '\0') {%20    if ((source[i] >= 65 && source[i] <= 90) || (source[i] >= 97 && source[i] <= 122)) {%20      vector_char_add(word, source[i]);%20%20    } else {%20      vector_char_add(word, '\0');%20%20      char* word_ptr = (char*) malloc(sizeof(char) * word->len);%20      char* temp = vector_char_get_array(word);%20      for (int j = 0; j < word->len - 1; j++) {%20        word_ptr[j] = temp[j];%20      }%20      word_ptr[word->len - 1] = '\0';%20%20      table_string_insert_or_add(ts, word_ptr, line);%20%20      vector_char_delete(word);%20      word = vector_char_allocate();%20      line++;%20%20    }%20    i++;%20  }%20%20  table_string_print(ts);%20%20  table_string_deallocate(ts);%20  vector_char_delete(word);%20 | 1
2025-09-17 22:30:37.076 | Query: I have a vector char:%20struct vector_char {%20  uint32_t len;%20  uint32_t max;%20  char *data;%20};%20%20that I use to create and store strings. I then get the data property from the struct and add it as the value to a vs_entry:%20typedef struct vs_entry {%20  char *value;%20  struct vs_entry *next;%20}%20that is in a vector string:%20typedef struct vector_string {%20  vs_entry_t *head;%20  vs_entry_t *tail;%20} vector_string;%20%20To free the vector_char, I'm given this function:%20void vector_char_delete(vector_char_t *vector_char) {%20  if (!vector_char)%20    return;%20%20  if (vector_char->max)%20    _free(vector_char->data);%20%20  _free(vector_char);%20}%20%20However, if I run this after adding the data to a vs_entry, the value property in the vs_entry will be wiped since they both point to the same location in memory. How can I fix this? | 1
2025-09-17 22:32:33.017 | Query: I have a vector char:%20struct vector_char {%20  uint32_t len;%20  uint32_t max;%20  char *data;%20};%20%20that I use to create and store strings. I then get the data property from the struct and add it as the value to a vs_entry:%20typedef struct vs_entry {%20  char *value;%20  struct vs_entry *next;%20}%20that is in a vector string:%20typedef struct vector_string {%20  vs_entry_t *head;%20  vs_entry_t *tail;%20} vector_string;%20%20To free the vector_char, I'm given this function:%20void vector_char_delete(vector_char_t *vector_char) {%20  if (!vector_char)%20    return;%20%20  if (vector_char->max)%20    _free(vector_char->data);%20%20  _free(vector_char);%20}%20%20However, if I run this after adding the data to a vs_entry, the value property in the vs_entry will be wiped since they both point to the same location in memory. How can I fix this? I am not allowed to use strcpy or strncpy. | 1
2025-09-18 16:58:37.699 | Query: what does this mean (after running make):%20%20collect2: error: ld returned 1 exit status%20make: *** [<builtin>: poscount] Error 1 | 1
2025-09-18 18:09:49.838 | Query: debug, loop hits one extra time:%20%20int buckets = 4;%20  table_string *ts = table_string_allocate(buckets);%20%20  vector_char_t* word = vector_char_allocate();%20%20%20  int i = 0;%20  int line = 0;%20%20  while (source[i] != '\0') {%20    if ((source[i] >= 65 && source[i] <= 90) || (source[i] >= 97 && source[i] <= 122)) {%20      vector_char_add(word, source[i]);%20%20    } else {%20%20      vector_char_add(word, '\0');%20%20%20      char* word_ptr = (char*) malloc(sizeof(char) * word->len);%20      char* temp = vector_char_get_array(word);%20      for (int j = 0; j < word->len - 1; j++) {%20        word_ptr[j] = temp[j];%20      }%20      word_ptr[word->len - 1] = '\0';%20%20      printf("hit: %s\n", word_ptr);%20%20      table_string_insert_or_add(ts, word_ptr, line);%20%20      vector_char_delete(word);%20      word = vector_char_allocate();%20      line++;%20%20    }%20    i++;%20  }%20%20  table_string_print(ts);%20%20  table_string_deallocate(ts);%20  vector_char_delete(word);%20  | 1
2025-09-18 18:27:51.032 | Query: Debug:%20%20#include "table_string.h"%20#include "str_cmp.h"%20#include <stdbool.h>%20#include <stdint.h>%20#include <stdio.h>%20#include <stdlib.h>%20#include <string.h>%20%20#define BUCKETS%20// DO NOT ADD ANY NEW FUNCTIONS BEFORE djb2%20// Hash a character array to integer value between 0 and buckets-1.%20// See here for more details: https://theartincode.stanis.me/008-djb2/%20unsigned int djb2_word_to_bucket(char *word, int buckets) {%20  if (!word) {%20    printf("Invoked with null string");%20    exit(EXIT_FAILURE);%20  }%20  unsigned long hash = 5381;%20  uint32_t i;%20%20  for (i = 0; i < strlen(word); i++)%20    hash = ((hash << 5) + hash) + word[i];%20%20  return hash & (buckets - 1);%20}%20// ADD YOUR HELPER FUNCTIONS AFTER djb2%20/**%20 * @brief Instantiate a table string%20 *%20 * @param buckets%20 * @return table_string*%20 */%20table_string *table_string_allocate(unsigned int buckets) {%20  // Instantiate a bucket number of heads%20  table_string* ts = (table_string*) malloc(sizeof(table_string));%20%20%20  ts->heads = (vs_entry_t**) malloc(buckets * sizeof(vs_entry_t*));%20%20  for (int i = 0; i < buckets; i++) {%20    ts->heads[i] = NULL;%20  }%20  ts->buckets = buckets;%20%20  return ts;%20}%20%20/**%20 * @brief Insert the string pointed to by word into the table string.%20 *   If word is already found increment count.%20 *   If word is not found insert at the end of the corresponding bucket%20 * @param ts - Pointer to table_string datastructure%20 * @param word - Pointer to string to search for%20 * @return * Find*%20 */%20void table_string_insert_or_add(table_string *ts, char *word, int line) {%20  // Find the bucket for word. djb2 will return a value between 0-buckets-1.%20  // Rule: buckets can only be power of 2.%20  int bucket = djb2_word_to_bucket(word, ts->buckets);%20  // TODO:%20  // Case head == NULL: bucket hasn't been initialized yet%20  // Case word already in list, add to line array.%20  // Case word not found, insert word and return.%20  vs_entry_t* b = ts->heads[bucket];%20%20  if (b == NULL) {%20    vs_entry_t* add = (vs_entry_t*) malloc(sizeof(vs_entry_t));%20    add->pos = (int*) malloc(sizeof(int) * 1);%20    add->size_of_pos = 1;%20    %20    add->pos[0] = line;%20    add->value = word;%20    add->next = NULL;%20    ts->heads[bucket] = add;%20    return;%20  }%20%20%20  vs_entry_t* p = b;%20%20  do {%20    if (!my_str_cmp(word, p->value)) {%20      // int* newPos%20      p->pos = (int*) realloc(p->pos, sizeof(int) * (p->size_of_pos + 1));%20      // p->pos = newPos;%20      p->pos[p->size_of_pos] = line;%20      p->size_of_pos++;%20      return;%20%20    } else if (p!=NULL){%20      p = p->next;%20%20    }%20    %20  } while(p != NULL);%20  %20  vs_entry_t* add = (vs_entry_t*) malloc(sizeof(vs_entry_t));%20  add->pos = (int*) malloc(sizeof(int));%20  add->pos[0] = line;%20  add->size_of_pos = 1;%20  add->value = word;%20  add->next = NULL;%20  p->next = add;%20%20}%20%20void table_string_deallocate(table_string *ts) {%20  // TODO:%20  // Free the linked list of each bucket%20  // Free the array of head pointers%20  // Free the structure itself%20  for (int i = 0; i < ts->buckets; i++) {%20%20    vs_entry_t* p = ts->heads[i];%20    vs_entry_t* next = p;;%20%20    while (next != NULL) {%20      next = p->next;%20      free(p->pos);%20      free(p->value);%20      free(p);%20      p = next;%20    }%20    p = NULL;%20%20  }%20%20  free(ts->heads);%20  free(ts);%20%20  return;%20}%20%20void table_string_print(table_string *ts) {%20  /** TODO:%20   for each bucket%20    for each entry in bucket%20      print entry->word: line line line%20  */%20  if (ts == NULL || ts->heads == NULL) {%20    return;%20  }%20%20  for (int i = 0; i < ts->buckets; i++) {%20    vs_entry_t* p = ts->heads[i];%20%20    while (p != NULL) {%20      printf("%s: ", p->value);%20%20      for (int j = 0; j < p->size_of_pos; j++) {%20        printf("%d ", p->pos[j]);%20      }%20      printf("\n");%20%20      p = p->next;%20    }%20%20  }%20}%20 | 1
2025-09-18 18:43:44.142 | Query: if you malloc in C, will there still be garbage value in the data that you requested that you have to set to NULL? | 1
2025-09-18 18:51:36.600 | Query: Debug%20%20typedef struct vs_entry {%20  char *value;%20  struct vs_entry *next;%20%20#ifdef POS_COUNT%20  int* pos; // This keeps track of each pos the word is found in%20  int  size_of_pos; // This keeps size of pos. Remember in C we track array size explicitly.%20#endif%20} vs_entry_t;%20%20// Struct describing the data structure vector_string%20// head* points to the entry which is the start of vector string%20typedef struct vector_string {%20  vs_entry_t *head;%20  vs_entry_t *tail;%20} vector_string;%20typedef struct table_string {%20  vs_entry_t **heads; // Array to maintain the heads of each bucket.%20  int buckets;        // Buckets can only be a power of 2.%20} table_string;%20%20#include "table_string.h"%20#include "str_cmp.h"%20#include <stdbool.h>%20#include <stdint.h>%20#include <stdio.h>%20#include <stdlib.h>%20#include <string.h>%20%20#define BUCKETS%20// DO NOT ADD ANY NEW FUNCTIONS BEFORE djb2%20// Hash a character array to integer value between 0 and buckets-1.%20// See here for more details: https://theartincode.stanis.me/008-djb2/%20unsigned int djb2_word_to_bucket(char *word, int buckets) {%20  if (!word) {%20    printf("Invoked with null string");%20    exit(EXIT_FAILURE);%20  }%20  unsigned long hash = 5381;%20  uint32_t i;%20%20  for (i = 0; i < strlen(word); i++)%20    hash = ((hash << 5) + hash) + word[i];%20%20  return hash & (buckets - 1);%20}%20// ADD YOUR HELPER FUNCTIONS AFTER djb2%20/**%20 * @brief Instantiate a table string%20 *%20 * @param buckets%20 * @return table_string*%20 */%20table_string *table_string_allocate(unsigned int buckets) {%20  // Instantiate a bucket number of heads%20  table_string* ts = (table_string*) malloc(sizeof(table_string));%20%20%20  ts->heads = (vs_entry_t**) malloc(buckets * sizeof(vs_entry_t*));%20%20  for (int i = 0; i < buckets; i++) {%20    ts->heads[i] = NULL;%20  }%20  ts->buckets = buckets;%20%20  return ts;%20}%20%20/**%20 * @brief Insert the string pointed to by word into the table string.%20 *   If word is already found increment count.%20 *   If word is not found insert at the end of the corresponding bucket%20 * @param ts - Pointer to table_string datastructure%20 * @param word - Pointer to string to search for%20 * @return * Find*%20 */%20void table_string_insert_or_add(table_string *ts, char *word, int line) {%20  // Find the bucket for word. djb2 will return a value between 0-buckets-1.%20  // Rule: buckets can only be power of 2.%20  int bucket = djb2_word_to_bucket(word, ts->buckets);%20  // TODO:%20  // Case head == NULL: bucket hasn't been initialized yet%20  // Case word already in list, add to line array.%20  // Case word not found, insert word and return.%20  vs_entry_t* p = ts->heads[bucket];%20%20  while(p != NULL ) {%20    if (!my_str_cmp(word, p->value)) {%20      int* newPos = (int*) realloc(p->pos, sizeof(int) * (p->size_of_pos + 1));%20      p->pos = newPos;%20      p->pos[p->size_of_pos] = line;%20      p->size_of_pos++;%20      return;%20%20    } else if (p!=NULL) {%20      p = p->next;%20%20    }%20    %20  } %20  %20  vs_entry_t* add = (vs_entry_t*) malloc(sizeof(vs_entry_t));%20  add->pos = (int*) malloc(sizeof(int));%20  add->pos[0] = line;%20  add->size_of_pos = 1;%20  add->value = word;%20  add->next = NULL;%20%20  if (p == NULL) {%20    ts->heads[bucket] = add;%20  } else {%20    p->next = add;%20  }%20%20}%20%20void table_string_deallocate(table_string *ts) {%20  // TODO:%20  // Free the linked list of each bucket%20  // Free the array of head pointers%20  // Free the structure itself%20  for (int i = 0; i < ts->buckets; i++) {%20%20    vs_entry_t* p = ts->heads[i];%20    vs_entry_t* next = p;;%20%20    while (next != NULL) {%20      next = p->next;%20      free(p->pos);%20      free(p->value);%20      free(p);%20      p = next;%20    }%20    p = NULL;%20%20  }%20%20  free(ts->heads);%20  free(ts);%20%20  return;%20}%20%20void table_string_print(table_string *ts) {%20  /** TODO:%20   for each bucket%20    for each entry in bucket%20      print entry->word: line line line%20  */%20  if (ts == NULL || ts->heads == NULL) {%20    return;%20  }%20%20  for (int i = 0; i < ts->buckets; i++) {%20    vs_entry_t* p = ts->heads[i];%20%20    while (p != NULL) {%20      printf("%s: ", p->value);%20%20      for (int j = 0; j < p->size_of_pos; j++) {%20        printf("%d ", p->pos[j]);%20      }%20      printf("\n");%20%20      p = p->next;%20    }%20%20  }%20}%20 | 1
2025-09-18 18:54:58.346 | Query: Debug%20%20typedef struct vs_entry {%20  char *value;%20  struct vs_entry *next;%20%20#ifdef POS_COUNT%20  int* pos; // This keeps track of each pos the word is found in%20  int  size_of_pos; // This keeps size of pos. Remember in C we track array size explicitly.%20#endif%20} vs_entry_t;%20%20// Struct describing the data structure vector_string%20// head* points to the entry which is the start of vector string%20typedef struct vector_string {%20  vs_entry_t *head;%20  vs_entry_t *tail;%20} vector_string;%20typedef struct table_string {%20  vs_entry_t **heads; // Array to maintain the heads of each bucket.%20  int buckets;        // Buckets can only be a power of 2.%20} table_string;%20%20#include "table_string.h"%20#include "str_cmp.h"%20#include <stdbool.h>%20#include <stdint.h>%20#include <stdio.h>%20#include <stdlib.h>%20#include <string.h>%20%20#define BUCKETS%20// DO NOT ADD ANY NEW FUNCTIONS BEFORE djb2%20// Hash a character array to integer value between 0 and buckets-1.%20// See here for more details: https://theartincode.stanis.me/008-djb2/%20unsigned int djb2_word_to_bucket(char *word, int buckets) {%20  if (!word) {%20    printf("Invoked with null string");%20    exit(EXIT_FAILURE);%20  }%20  unsigned long hash = 5381;%20  uint32_t i;%20%20  for (i = 0; i < strlen(word); i++)%20    hash = ((hash << 5) + hash) + word[i];%20%20  return hash & (buckets - 1);%20}%20// ADD YOUR HELPER FUNCTIONS AFTER djb2%20/**%20 * @brief Instantiate a table string%20 *%20 * @param buckets%20 * @return table_string*%20 */%20table_string *table_string_allocate(unsigned int buckets) {%20  // Instantiate a bucket number of heads%20  table_string* ts = (table_string*) malloc(sizeof(table_string));%20%20%20  ts->heads = (vs_entry_t**) malloc(buckets * sizeof(vs_entry_t*));%20%20  for (int i = 0; i < buckets; i++) {%20    ts->heads[i] = NULL;%20  }%20  ts->buckets = buckets;%20%20  return ts;%20}%20%20/**%20 * @brief Insert the string pointed to by word into the table string.%20 *   If word is already found increment count.%20 *   If word is not found insert at the end of the corresponding bucket%20 * @param ts - Pointer to table_string datastructure%20 * @param word - Pointer to string to search for%20 * @return * Find*%20 */%20void table_string_insert_or_add(table_string *ts, char *word, int line) {%20  // Find the bucket for word. djb2 will return a value between 0-buckets-1.%20  // Rule: buckets can only be power of 2.%20  int bucket = djb2_word_to_bucket(word, ts->buckets);%20  // TODO:%20  // Case head == NULL: bucket hasn't been initialized yet%20  // Case word already in list, add to line array.%20  // Case word not found, insert word and return.%20  vs_entry_t* p = ts->heads[bucket];%20%20  while(p != NULL ) {%20    if (!my_str_cmp(word, p->value)) {%20      int* newPos = (int*) realloc(p->pos, sizeof(int) * (p->size_of_pos + 1));%20      p->pos = newPos;%20      p->pos[p->size_of_pos] = line;%20      p->size_of_pos++;%20      return;%20%20    } else if (p!=NULL) {%20      p = p->next;%20%20    }%20    %20  } %20  %20  vs_entry_t* add = (vs_entry_t*) malloc(sizeof(vs_entry_t));%20  add->pos = (int*) malloc(sizeof(int));%20  add->pos[0] = line;%20  add->size_of_pos = 1;%20  add->value = word;%20  add->next = NULL;%20%20  if (p == NULL) {%20    ts->heads[bucket] = add;%20  } else {%20    p->next = add;%20  }%20%20}%20%20void table_string_deallocate(table_string *ts) {%20  // TODO:%20  // Free the linked list of each bucket%20  // Free the array of head pointers%20  // Free the structure itself%20  for (int i = 0; i < ts->buckets; i++) {%20%20    vs_entry_t* p = ts->heads[i];%20    vs_entry_t* next = p;;%20%20    while (next != NULL) {%20      next = p->next;%20      free(p->pos);%20      free(p->value);%20      free(p);%20      p = next;%20    }%20    p = NULL;%20%20  }%20%20  free(ts->heads);%20  free(ts);%20%20  return;%20}%20%20void table_string_print(table_string *ts) {%20  /** TODO:%20   for each bucket%20    for each entry in bucket%20      print entry->word: line line line%20  */%20  if (ts == NULL || ts->heads == NULL) {%20    return;%20  }%20%20  for (int i = 0; i < ts->buckets; i++) {%20    vs_entry_t* p = ts->heads[i];%20%20    while (p != NULL) {%20      printf("%s: ", p->value);%20%20      for (int j = 0; j < p->size_of_pos; j++) {%20        printf("%d ", p->pos[j]);%20      }%20      printf("\n");%20%20      p = p->next;%20    }%20%20  }%20}%20%20int buckets = 4;%20  table_string *ts = table_string_allocate(buckets);%20%20  vector_char_t* word = vector_char_allocate();%20%20%20  int i = 0;%20  int line = 0;%20%20  while (source[i] != '\0') {%20    if ((source[i] >= 65 && source[i] <= 90) || (source[i] >= 97 && source[i] <= 122)) {%20      vector_char_add(word, source[i]);%20%20    } else if (word->len > 0){%20%20      vector_char_add(word, '\0');%20%20      char* word_ptr = (char*) malloc(sizeof(char) * word->len);%20      memcpy(word_ptr, vector_char_get_array(word), word->len);%20%20      table_string_insert_or_add(ts, word_ptr, line);%20%20      vector_char_delete(word);%20      word = vector_char_allocate();%20      line++;%20%20    } else {%20      vector_char_delete(word);%20%20    }%20    i++;%20  }%20%20  table_string_print(ts);%20%20  table_string_deallocate(ts);%20  vector_char_delete(word); | 1
2025-09-18 19:09:15.985 | Query: How would I deallocate everything%20%20typedef struct table_string {%20  vs_entry_t **heads; // Array to maintain the heads of each bucket.%20  int buckets;        // Buckets can only be a power of 2.%20} table_string;%20%20%20typedef struct vs_entry {%20  char *value;%20  struct vs_entry *next;%20%20#ifdef POS_COUNT%20  int* pos; // This keeps track of each pos the word is found in%20  int  size_of_pos; // This keeps size of pos. Remember in C we track array size explicitly.%20#endif%20} vs_entry_t; | 1
2025-09-18 19:12:29.409 | Query: Debug:%20void table_string_deallocate(table_string *ts) {%20  // TODO:%20  // Free the linked list of each bucket%20  // Free the array of head pointers%20  // Free the structure itself%20  if (ts == NULL) {%20    return;%20  }%20  %20  for (int i = 0; i < ts->buckets; i++) {%20%20    vs_entry_t* p = ts->heads[i];%20    vs_entry_t* next = p;%20%20    while (next != NULL) {%20      next = p->next;%20      free(p->pos);%20      free(p->value);%20      free(p);%20      p = next;%20    }%20    p = NULL;%20%20  }%20%20  free(ts->heads);%20  free(ts);%20%20  return;%20}%20%20typedef struct table_string {%20  vs_entry_t **heads; // Array to maintain the heads of each bucket.%20  int buckets;        // Buckets can only be a power of 2.%20} table_string;%20%20%20typedef struct vs_entry {%20  char *value;%20  struct vs_entry *next;%20%20#ifdef POS_COUNT%20  int* pos; // This keeps track of each pos the word is found in%20  int  size_of_pos; // This keeps size of pos. Remember in C we track array size explicitly.%20#endif%20} vs_entry_t; | 1
2025-09-18 19:36:44.066 | Query: Debug:%20void table_string_insert_or_add(table_string *ts, char *word, int line) {%20  // Find the bucket for word. djb2 will return a value between 0-buckets-1.%20  // Rule: buckets can only be power of 2.%20  int bucket = djb2_word_to_bucket(word, ts->buckets);%20  // TODO:%20  // Case head == NULL: bucket hasn't been initialized yet%20  // Case word already in list, add to line array.%20  // Case word not found, insert word and return.%20%20  if (ts == NULL) {%20    return;%20  }%20%20  vs_entry_t* p = ts->heads[bucket];%20%20  vs_entry_t* last;%20  while (p != NULL) {%20%20    if (!my_str_cmp(word, p->value)) {%20      printf("FOUND MATCH%s\n",p->value);%20      p->pos = (int*) realloc(p->pos, sizeof(int) * p->size_of_pos + 1);%20      p->pos[p->size_of_pos] = line;%20      p->size_of_pos++;%20%20      return;%20    } %20%20    last = p;%20    p = p->next;%20  }%20%20  vs_entry_t* add = (vs_entry_t*) malloc(sizeof(vs_entry_t));%20  add->next = NULL;%20  add->value = word;%20  add->size_of_pos = 1;%20  add->pos = (int*) malloc(sizeof(int));%20  add->pos[0] = line;%20%20  if (p == NULL) {%20    ts->heads[bucket] = add;%20  } else {%20    last->next = add;%20  }%20%20}%20%20typedef struct table_string {%20  vs_entry_t **heads; // Array to maintain the heads of each bucket.%20  int buckets;        // Buckets can only be a power of 2.%20} table_string;%20%20%20typedef struct vs_entry {%20  char *value;%20  struct vs_entry *next;%20%20#ifdef POS_COUNT%20  int* pos; // This keeps track of each pos the word is found in%20  int  size_of_pos; // This keeps size of pos. Remember in C we track array size explicitly.%20#endif%20} vs_entry_t; | 1
2025-09-18 21:19:49.870 | Query: Debug why there is a 6byte memory leak from word_ptr = (char*) malloc(sizeof(char) * word->len);:%20vector_string *vector_string_allocate() {%20  vector_string* vs = (vector_string*) malloc(sizeof(vector_string));%20  %20  if (vs == NULL) {%20    return NULL;%20  }%20%20  vs->head = NULL;%20  vs->tail = NULL;%20%20  return vs;%20}%20%20/**%20 * @brief Search the vector string pointed to by vs and return true if the%20 * vs_entry.value == key, else return false.%20 * TODO:%20 * @param vs - Pointer to vector_string datastructure%20 * @param key - Pointer to string to search for%20 * @return * Find*%20 */%20bool vector_string_find(vector_string *vs, char *key) { %20  if (vs == NULL || vs->head == NULL) {%20    return false;%20  }%20%20%20  vs_entry_t* p = vs->head;%20%20  if (!strcmp(p->value, key) || !strcmp(vs->tail->value, key)) {%20    return true;%20  }%20%20  if (p->next != NULL) {%20    p = p->next;%20  } else {%20    return false;%20  }%20%20  while (p != vs->tail) {%20    if (strcmp(p->value, key)) {%20      p = p->next;%20%20    } else {%20      return true;%20%20    }%20%20  }%20  %20  return false; %20}%20%20/**%20 * @brief TODO: Insert the string pointed to by key into the vector string.%20 *  char* is externally allocated. You do not have to allocate internally%20 *%20 * @param vs - Pointer to vector_string datastructure%20 * @param key - Pointer to string to search for%20 * @return * Find*%20 */%20void vector_string_insert(vector_string *vs, char *key) {%20  // Insert the string into the tail of the list.%20  if (vs == NULL) {%20    return;%20  }%20%20  if (vs->head != NULL && vector_string_find(vs, key)) {%20    return;%20  }%20  %20  vs_entry_t* add = (vs_entry_t*) malloc(sizeof(vs_entry_t));%20  if (add == NULL) {%20    return;%20  }%20%20  add->next = NULL;%20  add->value = key;%20%20%20%20  if (vs->head == NULL && vs->tail == NULL) {%20    vs->head = add;%20    vs->tail = add;%20%20%20  } else {%20    vs->tail->next = add;%20    vs->tail = add;%20%20%20%20  }%20%20  %20}%20/**%20 * @brief Remove all entries and cleanup vector string%20 * TODO: Remove all entries. Remember head and tail are pointers.%20 * Remember to remove vs as well; not just entries. or you will have memory%20 * leaks.%20 * @param vs: Pointer to vector_string struct%20 */%20void vector_string_deallocate(vector_string *vs) {%20  if (vs == NULL || vs->head == NULL) {%20    return;%20  }%20%20  vs_entry_t* p = vs->head;%20  vs_entry_t* next = p;;%20%20  while (next != NULL) {%20    next = p->next;%20    free(p->value);%20    free(p);%20    p = next;%20  }%20  p = NULL;%20%20  free(vs);%20  vs = NULL;%20}%20%20/**%20 * @brief Print all value in each entry of the vector string, in the following%20 * format. In this case hello and world are the unique words in the file.%20 * 1. hello%20 * 2. world%20 * @param vs%20 */%20void vector_string_print(vector_string *vs) {%20  if (vs == NULL || vs->head == NULL%20%20#include <ctype.h>%20#include <fcntl.h>%20#include <stdio.h>%20#include <stdlib.h>%20#include <string.h>%20#include <vector_char.h>%20#include <vector_string.h>%20int main(int argc, char **argv) {%20  char *source = NULL;%20%20  if (argc != 2) {%20    printf("./grade_tokenize.bin [FILE PATH]");%20    exit(1);%20  }%20  /**%20   * @brief Read file into source.%20   * source is a character array with file contents%20   * It is null terminated%20   */%20  FILE *fp = fopen(argv[1], "r");%20  if (fp == NULL) { /* Error */%20    printf("Error reading file");%20    exit(1);%20  }%20  if (fp != NULL) {%20    /* Go to the end of the file. */%20    if (fseek(fp, 0L, SEEK_END) == 0) {%20      /* Get the size of the file. */%20      long bufsize = ftell(fp);%20      if (bufsize == -1) { /* Error */%20        printf("Error reading file");%20      }%20      /* Allocate our buffer to that size. */%20      source = malloc(sizeof(char) * (bufsize + 1));%20      /* Go back to the start of the file. */%20      if (fseek(fp, 0L, SEEK_SET) != 0) { /* Error */%20      }%20      /* Read the entire file into memory. */%20      size_t newLen = fread(source, sizeof(char), bufsize, fp);%20      if (ferror(fp) != 0) {%20        printf("Error reading file");%20      } else {%20        source[newLen++] = '\0'; /* Just to be safe. */%20      }%20    }%20  }%20  fclose(fp);%20%20  // TODO: Process source[] and count the number of words%20  // Print the number of words in the end.%20  int count = 0;%20  vector_string* vs = vector_string_allocate();%20  vector_char_t* word = vector_char_allocate();%20  char* word_ptr;%20  int i = 0;%20  while (source[i] != '\0') {%20%20    if ((source[i] >= 65 && source[i] <= 90) || (source[i] >= 97 && source[i] <= 122)) {%20      vector_char_add(word, source[i]);%20%20    } else if (word->len > 0) {%20      vector_char_add(word, '\0');%20%20      word_ptr = (char*) malloc(sizeof(char) * word->len);%20      memcpy(word_ptr, vector_char_get_array(word), word->len);%20%20      vector_string_insert(vs, word_ptr);%20%20      vector_char_delete(word);%20      word = vector_char_allocate();%20%20    }%20    i++;%20  }%20  vector_string_print(vs);%20%20  vector_string_deallocate(vs);%20  vector_char_delete(word);%20%20  free(source);%20%20  return 0;%20} | 1
2025-09-18 21:28:33.394 | Query: debug why is the deallocator missing something:%20vector_string *vector_string_allocate() {%20  vector_string* vs = (vector_string*) malloc(sizeof(vector_string));%20  %20  if (vs == NULL) {%20    return NULL;%20  }%20%20  vs->head = NULL;%20  vs->tail = NULL;%20%20  return vs;%20}%20%20/**%20 * @brief Search the vector string pointed to by vs and return true if the%20 * vs_entry.value == key, else return false.%20 * TODO:%20 * @param vs - Pointer to vector_string datastructure%20 * @param key - Pointer to string to search for%20 * @return * Find*%20 */%20bool vector_string_find(vector_string *vs, char *key) { %20  if (vs == NULL || vs->head == NULL) {%20    return false;%20  }%20%20%20  vs_entry_t* p = vs->head;%20%20  if (!strcmp(p->value, key) || !strcmp(vs->tail->value, key)) {%20    return true;%20  }%20%20  if (p->next != NULL) {%20    p = p->next;%20  } else {%20    return false;%20  }%20%20  while (p != vs->tail) {%20    if (strcmp(p->value, key)) {%20      p = p->next;%20%20    } else {%20      return true;%20%20    }%20%20  }%20  %20  return false; %20}%20%20/**%20 * @brief TODO: Insert the string pointed to by key into the vector string.%20 *  char* is externally allocated. You do not have to allocate internally%20 *%20 * @param vs - Pointer to vector_string datastructure%20 * @param key - Pointer to string to search for%20 * @return * Find*%20 */%20void vector_string_insert(vector_string *vs, char *key) {%20  // Insert the string into the tail of the list.%20  if (vs == NULL) {%20    return;%20  }%20%20  if (vs->head != NULL && vector_string_find(vs, key)) {%20    return;%20  }%20  %20  vs_entry_t* add = (vs_entry_t*) malloc(sizeof(vs_entry_t));%20  if (add == NULL) {%20    return;%20  }%20%20  add->next = NULL;%20  add->value = key;%20%20%20%20  if (vs->head == NULL && vs->tail == NULL) {%20    vs->head = add;%20    vs->tail = add;%20%20%20  } else {%20    vs->tail->next = add;%20    vs->tail = add;%20%20%20%20  }%20%20  %20}%20/**%20 * @brief Remove all entries and cleanup vector string%20 * TODO: Remove all entries. Remember head and tail are pointers.%20 * Remember to remove vs as well; not just entries. or you will have memory%20 * leaks.%20 * @param vs: Pointer to vector_string struct%20 */%20void vector_string_deallocate(vector_string *vs) {%20  if (vs == NULL || vs->head == NULL) {%20    return;%20  }%20%20  vs_entry_t* p = vs->head;%20  vs_entry_t* next = p;;%20%20  while (next != NULL) {%20    next = p->next;%20    free(p->value);%20    free(p);%20    p = next;%20  }%20  p = NULL;%20%20  free(vs);%20  vs = NULL;%20}%20%20/**%20 * @brief Print all value in each entry of the vector string, in the following%20 * format. In this case hello and world are the unique words in the file.%20 * 1. hello%20 * 2. world%20 * @param vs%20 */%20void vector_string_print(vector_string *vs) {%20  if (vs == NULL || vs->head == NULL) {%20    return;%20  }%20%20  int count = 1;%20  vs_entry_t *entry = vs->head;%20  %20%20  while (entry->next != NULL) {%20    printf("%d. %s\n", count, entry->value);%20%20    entry = entry->next;%20    count++;%20  %20  }%20}%20%20  int count = 0;%20  vector_string* vs = vector_string_allocate();%20  vector_char_t* word = vector_char_allocate();%20  char* word_ptr;%20  int i = 0;%20  while (source[i] != '\0') {%20%20    if ((source[i] >= 65 && source[i] <= 90) || (source[i] >= 97 && source[i] <= 122)) {%20      vector_char_add(word, source[i]);%20%20    } else if (word->len > 0) {%20      vector_char_add(word, '\0');%20%20      word_ptr = (char*) malloc(sizeof(char) * word->len);%20      memcpy(word_ptr, vector_char_get_array(word), word->len);%20%20%20      vector_string_insert(vs, word_ptr);%20%20      vector_char_delete(word);%20      word = vector_char_allocate();%20%20    }%20    i++;%20  }%20%20  vector_string_print(vs);%20%20  vector_string_deallocate(vs);%20  vector_char_delete(word);%20 | 1
2025-09-18 21:33:06.520 |  Query: debug why is the deallocator missing something:%20vector_string *vector_string_allocate() {%20  vector_string* vs = (vector_string*) malloc(sizeof(vector_string));%20  %20  if (vs == NULL) {%20    return NULL;%20  }%20%20  vs->head = NULL;%20  vs->tail = NULL;%20%20  return vs;%20}%20%20/**%20 * @brief Search the vector string pointed to by vs and return true if the%20 * vs_entry.value == key, else return false.%20 * TODO:%20 * @param vs - Pointer to vector_string datastructure%20 * @param key - Pointer to string to search for%20 * @return * Find*%20 */%20bool vector_string_find(vector_string *vs, char *key) { %20  if (vs == NULL || vs->head == NULL) {%20    return false;%20  }%20%20%20  vs_entry_t* p = vs->head;%20%20  if (!strcmp(p->value, key) || !strcmp(vs->tail->value, key)) {%20    return true;%20  }%20%20  if (p->next != NULL) {%20    p = p->next;%20  } else {%20    return false;%20  }%20%20  while (p != vs->tail) {%20    if (strcmp(p->value, key)) {%20      p = p->next;%20%20    } else {%20      return true;%20%20    }%20%20  }%20  %20  return false; %20}%20%20/**%20 * @brief TODO: Insert the string pointed to by key into the vector string.%20 *  char* is externally allocated. You do not have to allocate internally%20 *%20 * @param vs - Pointer to vector_string datastructure%20 * @param key - Pointer to string to search for%20 * @return * Find*%20 */%20void vector_string_insert(vector_string *vs, char *key) {%20  // Insert the string into the tail of the list.%20  if (vs == NULL) {%20    return;%20  }%20%20  if (vs->head != NULL && vector_string_find(vs, key)) {%20    return;%20  }%20  %20  vs_entry_t* add = (vs_entry_t*) malloc(sizeof(vs_entry_t));%20  if (add == NULL) {%20    return;%20  }%20%20  add->next = NULL;%20  add->value = key;%20%20%20%20  if (vs->head == NULL && vs->tail == NULL) {%20    vs->head = add;%20    vs->tail = add;%20%20%20  } else {%20    vs->tail->next = add;%20    vs->tail = add;%20%20%20%20  }%20%20  %20}%20/**%20 * @brief Remove all entries and cleanup vector string%20 * TODO: Remove all entries. Remember head and tail are pointers.%20 * Remember to remove vs as well; not just entries. or you will have memory%20 * leaks.%20 * @param vs: Pointer to vector_string struct%20 */%20void vector_string_deallocate(vector_string *vs) {%20  if (vs == NULL || vs->head == NULL) {%20    return;%20  }%20%20  vs_entry_t* p = vs->head;%20  vs_entry_t* next = p;;%20%20  while (next != NULL) {%20    next = p->next;%20    free(p->value);%20    free(p);%20    p = next;%20  }%20  p = NULL;%20%20  free(vs);%20  vs = NULL;%20}%20%20/**%20 * @brief Print all value in each entry of the vector string, in the following%20 * format. In this case hello and world are the unique words in the file.%20 * 1. hello%20 * 2. world%20 * @param vs%20 */%20void vector_string_print(vector_string *vs) {%20  if (vs == NULL || vs->head == NULL) {%20    return;%20  }%20%20  int count = 1;%20  vs_entry_t *entry = vs->head;%20  %20%20  while (entry->next != NULL) {%20    printf("%d. %s\n", count, entry->value);%20%20    entry = entry->next;%20    count++;%20  %20  }%20}%20%20  int count = 0;%20  vector_string* vs = vector_string_allocate();%20  vector_char_t* word = vector_char_allocate();%20  char* word_ptr;%20  int i = 0;%20  while (source[i] != '\0') {%20%20    if ((source[i] >= 65 && source[i] <= 90) || (source[i] >= 97 && source[i] <= 122)) {%20      vector_char_add(word, source[i]);%20%20    } else if (word->len > 0) {%20      vector_char_add(word, '\0');%20%20      word_ptr = (char*) malloc(sizeof(char) * word->len);%20      memcpy(word_ptr, vector_char_get_array(word), word->len);%20%20%20      vector_string_insert(vs, word_ptr);%20%20      vector_char_delete(word);%20      word = vector_char_allocate();%20%20    }%20    i++;%20  }%20%20  vector_string_print(vs);%20%20  vector_string_deallocate(vs);%20  vector_char_delete(word);%20 | Rating: 5  | 1
2025-09-18 21:52:01.373 | Query: Explain how I can track down a segfault | 1
2025-09-19 10:01:38.648 | Query: Consider the 6-bit number 0b110000. What number is it sign-extended 11 bits. ? | 1
2025-09-19 10:02:56.541 | Query: what is 0b1111100000 in decimal | 1
2025-09-19 10:04:02.654 | Query: what number is 0b1111100000 sign extended 11 bits%20%20-16%20%2017%20%20-2029%20%202036 | 1
2025-09-19 10:05:29.366 | Query: Consider the 4-bit number 0b1011. What number is it sign-extended 9 bits. ?%20Group of answer choices%20%20-5%20%206%20%20-504%20%20511 | 1
2025-09-19 10:08:18.118 | Query: Which of the following 12 bit numbers has the same value as the 7 bit number 0b1000111. ?%20Group of answer choices%20%200b100001000111%20%200b100011101001%20%200b000001000110%20%200b111111000111 | 1
2025-09-19 10:11:29.490 | Query: How many bits are required to represent the number -3740? in 2’s complement and sign-magnitude? ?%20Group of answer choices%20%2014 (2’s complement), 12 (Sign-mag)%20%2012 (2’s complement), 14 (Sign-mag)%20%2015 (2’s complement), 13 (Sign-mag)%20%2013 (2’s complement), 13 (Sign-mag) | 1
2025-09-19 10:15:15.401 | Query: If x is the following number 0x98,%20y = x<<(3)>>(4). Assume logical shift. Write all 8 bits%20What is y in binary ? | 1
2025-09-19 10:24:52.171 | Query: If x = 0x1 and y = 0xd What is the value of%20z = (A & ~A) after this statement (where x is A and y is B)?%20Write in binary 4 bits | 1
2025-09-19 10:29:31.773 | Query: If x = 0x7 and y = 0xb What is the value of%20z = (B & ~B) after this statement (where x is A and y is B)?%20Write in binary 4 bits | 1
2025-09-19 10:32:16.368 | Query: How many bits are required to represent the number 871? in unsigned, 2s complement, and sign-magnitude? ?%20Group of answer choices%20%2010 (Unsigned), 12 (2’s complement), 10 (Sign-mag)%20%2010 (Unsigned), 11 (2’s complement), 11 (Sign-mag)%20%2011 (Unsigned), 10 (2’s complement), 12 (Sign-mag)%20%2012 (Unsigned), 10 (2’s complement), 13 (Sign-mag) | 1
2025-09-19 10:33:52.762 | Query: Which of the following 9 bit numbers has the same value as the 4 bit number 0b1011. ?%20Group of answer choices%20%200b100001011%20%200b000001010%20%200b111111011%20%200b101101101 | 1
2025-09-19 11:37:47.425 | Query: Invalid read of size 1%20==66377==    at 0x4852EE0: memmove (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)%20==66377==    by 0x109814: main (mapcount.c:109)%20%20main 109: memcpy(newWord, wordPointer, word->len + 1); | 1
2025-09-19 14:16:00.698 | Query: Walk me through assignment 2%20 | 1
2025-09-19 15:23:35.099 | Query: How does a "hash-based" table type data-structure work? | 1
2025-09-19 15:26:59.943 | Query: How should i allocate a table-based data structure on the heap | 1
2025-09-19 15:29:38.613 | Query: Why should we cast malloc to the type we are allocating for in C | 1
2025-09-19 15:30:48.806 | Query: Would this be a good way of allocating a table data structure:%20table_string *ts = (table_string*)malloc(buckets * sizeof(tab | 1
2025-09-19 16:54:14.199 | Query: Address 0x4a90410 is 16 bytes inside a block of size 32 free'd%20==5805==    at 0x488C868: realloc%20What causes this error%20 | 1
2025-09-19 16:55:49.433 | Query: Address 0x4a90410 is 16 bytes inside a block of size 32 free'd%20==5805==    at 0x488C868: realloc%20What causes this error%20Does realloc free any memory?%20 | 1
2025-09-19 20:47:52.180 | Query: Give me practice questions from week 1 and 2 | 1
2025-09-20 11:29:56.170 | Query: if you make an arraylist struct, why would you make a pointer to a pointer to allocated memory like void **buffer?%20 | 1
2025-09-20 11:36:28.684 | Query: what do you mean by "you can allocate more memory to buffer without needing to copy the existing elements to a different memory location"? don't I always need to copy all the existing things to a different place with more memory?%20 | 1
2025-09-20 11:43:39.914 | Query: Would this reallocate the array of pointers to a bigger memory location?%20a->buffer = (void**) realloc(a->buffer, a->buffer_size*2);%20(I'm unsure if the * are in the right places)%20 | 1
2025-09-20 11:45:28.734 | Query: If it turns out there's an adjacent memory block to which we can expand, do I understand correctly that realloc will return null and therefore it will make a->buffer also a null? that will be an error...%20a->buffer = (void**) realloc(a->buffer, a->buffer_size*2);%20%20 | 1
2025-09-20 11:53:31.227 | Query: How exactly does the free() function work? If I have a pointer array, would I need to call free() once to the pointer to the whole array or would I need to free() each pointer in the array and then the pointer to the whole array? | 1
2025-09-20 14:01:56.266 | Query: Debug:%20%20typedef struct table_string {%20  vs_entry_t **heads; // Array to maintain the heads of each bucket.%20  int buckets;        // Buckets can only be a power of 2.%20} table_string;%20%20typedef struct vs_entry {%20  char *value;%20  struct vs_entry *next;%20%20  int* pos; // This keeps track of each pos the word is found in%20  int  size_of_pos; // This keeps size of pos. Remember in C we track array size explicitly.%20%20} vs_entry_t;%20%20vs_entry_t* table_string_find(table_string* ts, unsigned int buckets, char* word) {%20  if (ts == NULL) {%20    return NULL;%20  }%20  vs_entry_t* p = ts->heads[buckets];%20%20  while (p != NULL) {%20    if (!my_str_cmp(word, p->value)) {%20      return p;%20    }%20    p = p->next;%20  }%20%20  return NULL;%20} | 1
2025-09-20 14:14:49.332 | Query: Debug why tablestring find:%20%20typedef struct table_string {%20  vs_entry_t **heads; // Array to maintain the heads of each bucket.%20  int buckets;        // Buckets can only be a power of 2.%20} table_string;%20%20typedef struct vs_entry {%20  char *value;%20  struct vs_entry *next;%20%20  int* pos; // This keeps track of each pos the word is found in%20  int  size_of_pos; // This keeps size of pos. Remember in C we track array size explicitly.%20%20} vs_entry_t;%20%20#include <ctype.h>%20#include <fcntl.h>%20#include <stdio.h>%20#include <stdlib.h>%20#include <string.h>%20#include <table_string.h>%20#include <vector_char.h>%20#include "str_cmp.h"%20%20// Function to read file content into a string%20char* read_file_content(char* filename) {%20  char *source = NULL;%20  FILE *fp = fopen(filename, "r");%20  if (fp == NULL) {%20    printf("Error reading file: %s\n", filename);%20    exit(1);%20  }%20  %20  if (fseek(fp, 0L, SEEK_END) == 0) {%20    long bufsize = ftell(fp);%20    if (bufsize == -1) {%20      printf("Error reading file: %s\n", filename);%20      exit(1);%20    }%20    source = malloc(sizeof(char) * (bufsize + 1));%20    if (fseek(fp, 0L, SEEK_SET) != 0) {%20      printf("Error reading file: %s\n", filename);%20      exit(1);%20    }%20    size_t newLen = fread(source, sizeof(char), bufsize, fp);%20    if (ferror(fp) != 0) {%20      printf("Error reading file: %s\n", filename);%20      exit(1);%20    } else {%20      source[newLen++] = '\0';%20    }%20  }%20  fclose(fp);%20  return source;%20}%20%20// Helper function%20vs_entry_t* table_string_find(table_string* ts, unsigned int buckets, char* word) {%20  if (ts == NULL || ts->buckets != buckets) {%20    return NULL;%20  }%20  vs_entry_t* p = ts->heads[buckets];%20%20  while (p != NULL) {%20    if (!my_str_cmp(word, p->value)) {%20      return p;%20    }%20    p = p->next;%20  }%20%20  return NULL;%20}%20%20int main(int argc, char **argv) {%20  if (argc != 3) {%20    printf("Usage: ./mapcount.bin [FIRST_FILE] [SECOND_FILE]\n");%20    exit(1);%20  }%20  %20  // Read both files%20  char *first_file_content = read_file_content(argv[1]);%20  char *second_file_content = read_file_content(argv[2]);%20%20%20  int buckets = 8;%20  /** Process first file and build table_string with word positions */%20  table_string* table1 = table_string_allocate(buckets);%20  vector_char_t* word = vector_char_allocate();%20%20%20  int w = 0;%20  int line = 0;%20%20  while (first_file_content[w] != '\0') {%20    if ((first_file_content[w] >= 65 && first_file_content[w] <= 90) || (first_file_content[w] >= 97 && first_file_content[w] <= 122)) {%20      vector_char_add(word, first_file_content[w]);%20%20    } else if (word->len > 0){%20%20      vector_char_add(word, '\0');%20%20      char* word_ptr = (char*) malloc(sizeof(char) * word->len);%20      memcpy(word_ptr, vector_char_get_array(word), word->len);%20%20      table_string_insert_or_add(table1, word_ptr, line);%20%20      vector_char_delete(word);%20      word = vector_char_allocate();%20      line++;%20%20%20    }%20    w++;%20  }%20%20%20  /** Process second file and search for consecutive word pairs */%20  int i = 0;%20%20  char* cur = NULL;%20  char* next = NULL;%20%20  vector_char_t *word2 = vector_char_allocate();%20%20  while (second_file_content[i + 1] != '\0') {%20%20    if ((second_file_content[i] >= 65 && second_file_content[i] <= 90) || (second_file_content[i] >= 97 && second_file_content[i] <= 122)) {%20      vector_char_add(word2, second_file_content[i]);%20    %20    } else if (word2->len > 0){%20      vector_char_add(word2, '\0');%20%20      char* word_ptr = vector_char_get_array(word2);%20  %20      printf("%s\n", word_ptr);%20%20      cur = next;%20      next = word_ptr;%20%20      if (cur != NULL) {%20        int bucket1 = djb2_word_to_bucket(cur,buckets);      %20      }%20      int bucket2 = djb2_word_to_bucket(next,buckets);%20%20%20%20      if (cur != NULL) {%20        vs_entry_t* q = table_string_find(table1, buckets, cur);%20        int* cur_pos = q->pos;%20        int cur_pos_size = q->size_of_pos;%20      %20%20%20        vs_entry_t* l = table_string_find(table1, buckets, next);%20        int* next_pos = l->pos;%20        int next_pos_size = l->size_of_pos;%20%20        if (q != NULL && l != NULL) {%20          for (int k = 0; k < line; k++) {%20            for (int a = 0; a < cur_pos_size; a++) {%20              for (int b = 0; b < next_pos_size; b++) {%20                if (b == a + 1) {%20                  printf("%s %s %d", cur, next, cur_pos[a]);%20                }%20              }%20            }%20          }%20        }%20      }%20%20      vector_char_delete(word2);%20      word2 = vector_char_allocate();%20    } %20    i++;%20  }%20  %20  vector_char_delete(word2);%20  vector_char_delete(word);%20  table_string_deallocate(table1);%20  free(first_file_content);%20  free(second_file_content);%20  return 0;%20} | 1
2025-09-20 14:27:19.954 | Query: Debug why cur and next are always the same:%20%20typedef struct table_string {%20  vs_entry_t **heads; // Array to maintain the heads of each bucket.%20  int buckets;        // Buckets can only be a power of 2.%20} table_string;%20%20typedef struct vs_entry {%20  char *value;%20  struct vs_entry *next;%20%20  int* pos; // This keeps track of each pos the word is found in%20  int  size_of_pos; // This keeps size of pos. Remember in C we track array size explicitly.%20%20} vs_entry_t;%20#include <ctype.h>%20#include <fcntl.h>%20#include <stdio.h>%20#include <stdlib.h>%20#include <string.h>%20#include <table_string.h>%20#include <vector_char.h>%20#include "str_cmp.h"%20%20// Function to read file content into a string%20char* read_file_content(char* filename) {%20  char *source = NULL;%20  FILE *fp = fopen(filename, "r");%20  if (fp == NULL) {%20    printf("Error reading file: %s\n", filename);%20    exit(1);%20  }%20  %20  if (fseek(fp, 0L, SEEK_END) == 0) {%20    long bufsize = ftell(fp);%20    if (bufsize == -1) {%20      printf("Error reading file: %s\n", filename);%20      exit(1);%20    }%20    source = malloc(sizeof(char) * (bufsize + 1));%20    if (fseek(fp, 0L, SEEK_SET) != 0) {%20      printf("Error reading file: %s\n", filename);%20      exit(1);%20    }%20    size_t newLen = fread(source, sizeof(char), bufsize, fp);%20    if (ferror(fp) != 0) {%20      printf("Error reading file: %s\n", filename);%20      exit(1);%20    } else {%20      source[newLen++] = '\0';%20    }%20  }%20  fclose(fp);%20  return source;%20}%20%20// Helper function%20vs_entry_t* table_string_find(table_string* ts, unsigned int maxBucket, char* word) {%20  if (ts == NULL || ts->buckets != maxBucket) {%20    return NULL;%20  }%20%20  int bucket = djb2_word_to_bucket(word, maxBucket);      %20%20  vs_entry_t* p = ts->heads[bucket];%20%20  while (p != NULL) {%20    if (!my_str_cmp(word, p->value)) {%20      return p;%20    }%20    p = p->next;%20  }%20%20  return NULL;%20}%20%20int main(int argc, char **argv) {%20  if (argc != 3) {%20    printf("Usage: ./mapcount.bin [FIRST_FILE] [SECOND_FILE]\n");%20    exit(1);%20  }%20  %20  // Read both files%20  char *first_file_content = read_file_content(argv[1]);%20  char *second_file_content = read_file_content(argv[2]);%20%20%20  int buckets = 8;%20  /** Process first file and build table_string with word positions */%20  table_string* table1 = table_string_allocate(buckets);%20  vector_char_t* word = vector_char_allocate();%20%20%20  int w = 0;%20  int line = 0;%20%20  while (first_file_content[w] != '\0') {%20    if ((first_file_content[w] >= 65 && first_file_content[w] <= 90) || (first_file_content[w] >= 97 && first_file_content[w] <= 122)) {%20      vector_char_add(word, first_file_content[w]);%20%20    } else if (word->len > 0){%20%20      vector_char_add(word, '\0');%20%20      char* word_ptr = (char*) malloc(sizeof(char) * word->len);%20      memcpy(word_ptr, vector_char_get_array(word), word->len);%20%20      table_string_insert_or_add(table1, word_ptr, line);%20%20      vector_char_delete(word);%20      word = vector_char_allocate();%20      line++;%20%20%20    }%20    w++;%20  }%20%20%20  /** Process second file and search for consecutive word pairs */%20  int i = 0;%20%20  char* cur = NULL;%20  char* next = NULL;%20%20  vector_char_t *word2 = vector_char_allocate();%20%20  while (second_file_content[i + 1] != '\0') {%20%20    if ((second_file_content[i] >= 65 && second_file_content[i] <= 90) || (second_file_content[i] >= 97 && second_file_content[i] <= 122)) {%20      vector_char_add(word2, second_file_content[i]);%20    %20    } else if (word2->len > 0){%20      vector_char_add(word2, '\0');%20%20      char* word_ptr = (char*) malloc(sizeof(char) * word2->len);%20      memcpy(word_ptr, vector_char_get_array(word2), word2->len);%20  %20      // printf("%s\n", word_ptr);%20%20      next = word_ptr;%20%20%20      if (cur != NULL) {%20%20      printf("Cur:%s \t Next:%s\n", cur,next);%20%20        vs_entry_t* q = table_string_find(table1, buckets, cur);%20        int* cur_pos = q->pos;%20        int cur_pos_size = q->size_of_pos;%20      %20%20%20        vs_entry_t* l = table_string_find(table1, buckets, next);%20        int* next_pos = l->pos;%20        int next_pos_size = l->size_of_pos;%20%20        if (q != NULL && l != NULL) {%20          for (int k = 0; k < line; k++) {%20            for (int a = 0; a < cur_pos_size; a++) {%20              for (int b = 0; b < next_pos_size; b++) {%20                if (b == a + 1) {%20                  // printf("%s %s %d\n", cur, next, cur_pos[a]);%20                }%20              }%20            }%20          }%20        }%20      }%20%20      vector_char_delete(word2);%20      word2 = vector_char_allocate();%20%20%20      cur = next;%20      free(word_ptr);%20    } %20    i++;%20  }%20  %20  vector_char_delete(word2);%20  vector_char_delete(word);%20  table_string_deallocate(table1);%20  free(first_file_content);%20  free(second_file_content);%20  return 0;%20} | 1
2025-09-20 14:37:45.485 | Query: Debug the first and last read pair does not print:%20%20typedef struct table_string {%20  vs_entry_t **heads; // Array to maintain the heads of each bucket.%20  int buckets;        // Buckets can only be a power of 2.%20} table_string;%20%20typedef struct vs_entry {%20  char *value;%20  struct vs_entry *next;%20%20  int* pos; // This keeps track of each pos the word is found in%20  int  size_of_pos; // This keeps size of pos. Remember in C we track array size explicitly.%20%20} vs_entry_t;%20#include <ctype.h>%20#include <fcntl.h>%20#include <stdio.h>%20#include <stdlib.h>%20#include <string.h>%20#include <table_string.h>%20#include <vector_char.h>%20#include "str_cmp.h"%20%20// Function to read file content into a string%20char* read_file_content(char* filename) {%20  char *source = NULL;%20  FILE *fp = fopen(filename, "r");%20  if (fp == NULL) {%20    printf("Error reading file: %s\n", filename);%20    exit(1);%20  }%20  %20  if (fseek(fp, 0L, SEEK_END) == 0) {%20    long bufsize = ftell(fp);%20    if (bufsize == -1) {%20      printf("Error reading file: %s\n", filename);%20      exit(1);%20    }%20    source = malloc(sizeof(char) * (bufsize + 1));%20    if (fseek(fp, 0L, SEEK_SET) != 0) {%20      printf("Error reading file: %s\n", filename);%20      exit(1);%20    }%20    size_t newLen = fread(source, sizeof(char), bufsize, fp);%20    if (ferror(fp) != 0) {%20      printf("Error reading file: %s\n", filename);%20      exit(1);%20    } else {%20      source[newLen++] = '\0';%20    }%20  }%20  fclose(fp);%20  return source;%20}%20%20// Helper function%20vs_entry_t* table_string_find(table_string* ts, unsigned int maxBucket, char* word) {%20  if (ts == NULL || ts->buckets != maxBucket) {%20    return NULL;%20  }%20%20  int bucket = djb2_word_to_bucket(word, maxBucket);      %20%20  vs_entry_t* p = ts->heads[bucket];%20%20  while (p != NULL) {%20    if (!my_str_cmp(word, p->value)) {%20      return p;%20    }%20    p = p->next;%20  }%20%20  return NULL;%20}%20%20int main(int argc, char **argv) {%20  if (argc != 3) {%20    printf("Usage: ./mapcount.bin [FIRST_FILE] [SECOND_FILE]\n");%20    exit(1);%20  }%20  %20  // Read both files%20  char *first_file_content = read_file_content(argv[1]);%20  char *second_file_content = read_file_content(argv[2]);%20%20%20  int buckets = 8;%20  /** Process first file and build table_string with word positions */%20  table_string* table1 = table_string_allocate(buckets);%20  vector_char_t* word = vector_char_allocate();%20%20%20  int w = 0;%20  int line = 0;%20%20  while (first_file_content[w] != '\0') {%20    if ((first_file_content[w] >= 65 && first_file_content[w] <= 90) || (first_file_content[w] >= 97 && first_file_content[w] <= 122)) {%20      vector_char_add(word, first_file_content[w]);%20%20    } else if (word->len > 0){%20%20      vector_char_add(word, '\0');%20%20      char* word_ptr = (char*) malloc(sizeof(char) * word->len);%20      memcpy(word_ptr, vector_char_get_array(word), word->len);%20%20      table_string_insert_or_add(table1, word_ptr, line);%20%20      vector_char_delete(word);%20      word = vector_char_allocate();%20      line++;%20%20%20    }%20    w++;%20  }%20%20%20  /** Process second file and search for consecutive word pairs */%20  int i = 0;%20%20  char* cur = NULL;%20  char* next = NULL;%20%20  vector_char_t *word2 = vector_char_allocate();%20%20  while (second_file_content[i] != '\0') {%20%20    if ((second_file_content[i] >= 65 && second_file_content[i] <= 90) || (second_file_content[i] >= 97 && second_file_content[i] <= 122)) {%20      vector_char_add(word2, second_file_content[i]);%20%20    } else if (word2->len > 0){%20      vector_char_add(word2, '\0');%20%20      char* word_ptr = (char*) malloc(sizeof(char) * word2->len);%20      memcpy(word_ptr, vector_char_get_array(word2), word2->len);%20%20      if (cur != NULL) {%20        free(cur);%20      }%20      cur = next;%20      next = word_ptr;%20%20%20      if (cur != NULL) {%20%20      // printf("Cur:%s \t Next:%s\n", cur,next);%20        vs_entry_t* q = table_string_find(table1, buckets, cur);%20        int* cur_pos = q->pos;%20        int cur_pos_size = q->size_of_pos;%20      %20%20%20        vs_entry_t* l = table_string_find(table1, buckets, next);%20        int* next_pos = l->pos;%20        int next_pos_size = l->size_of_pos;%20%20        if (q != NULL && l != NULL) {%20            for (int a = 0; a < cur_pos_size; a++) {%20              for (int b = 0; b < next_pos_size; b++) {%20                if (b == a + 1) {%20                  printf("%s %s %d\n", cur, next, cur_pos[a]);%20                }%20              }%20            }%20        }%20      }%20%20      vector_char_delete(word2);%20      word2 = vector_char_allocate();%20%20%20%20    } %20    i++;%20  }%20%20  free(cur);%20  free(next);%20  %20  vector_char_delete(word2);%20  vector_char_delete(word);%20  table_string_deallocate(table1);%20  free(first_file_content);%20  free(second_file_content);%20  return 0;%20} | 1
2025-09-20 21:43:07.021 | Query: Lets start off by talking about assignment 1 | 1
2025-09-21 00:48:58.112 | Query: Assignment 1 unit_test_str_cmp.c I'm confused on the task at hand | 1
2025-09-21 12:37:19.732 | Query: what do i need to know for first midterm pls help me i will die | 1
2025-09-21 12:37:47.886 | Query: no like what r the questions that will be asked on the first midterm | 1
2025-09-21 12:38:11.840 | Query: tytpe of questions on first midterm | 1
2025-09-21 12:38:50.409 | Query: Explain pointer arithmetic in C with examples | 1
2025-09-21 14:26:54.440 | Query: What does vector_char_allocate() allocate? space for string OR space for pointer to string? | 1
2025-09-21 15:43:17.748 | Query: try to think like the professor, make me a study guide of the most likely questions on the midterm 1 which is just week 1 and week 2. give me the most important definitions, step by step general ways to solve all the possible questions, a way to deduce all the types of questions and what they expect of us and how to solve or think of them when at exam, and anything else to ensure ill smash the exam. | 1
2025-09-22 00:09:28.963 | Query: try to think like the professor, make me a study guide of the most likely questions on the midterm 1 which is just week 1 and week 2. give me the most important definitions, step by step general ways to solve all the possible questions, a way to deduce all the types of questions and what they expect of us and how to solve or think of them when at exam, and anything else to ensure ill smash the exam. based on the fact that midterms are usually pretty much the same just diff numbrs give me a kind of go to way of thinking lke if i see this do this or think this yk break down the main types of problems or questions i can get%20 | 1
2025-09-22 10:59:31.526 | Query: In simple terms, please help me understand and summarize the tasks I need to complete:%20%20#include "table_string.h"%20#include "str_cmp.h"%20#include <stdbool.h>%20#include <stdint.h>%20#include <stdio.h>%20#include <stdlib.h>%20#include <string.h>%20%20#define BUCKETS%20// DO NOT ADD ANY NEW FUNCTIONS BEFORE djb2%20// Hash a character array to integer value between 0 and buckets-1.%20// See here for more details: https://theartincode.stanis.me/008-djb2/%20unsigned int djb2_word_to_bucket(char *word, int buckets) {%20  if (!word) {%20    printf("Invoked with null string");%20    exit(EXIT_FAILURE);%20  }%20  unsigned long hash = 5381;%20  uint32_t i;%20%20  for (i = 0; i < strlen(word); i++)%20    hash = ((hash << 5) + hash) + word[i];%20%20  return hash & (buckets - 1);%20}%20// ADD YOUR HELPER FUNCTIONS AFTER djb2%20/**%20 * @brief Instantiate a table string%20 *%20 * @param buckets%20 * @return table_string*%20 */%20table_string *table_string_allocate(unsigned int buckets) {%20  // Instantiate a bucket number of heads%20}%20%20/**%20 * @brief Insert the string pointed to by word into the table string.%20 *   If word is already found increment count.%20 *   If word is not found insert at the end of the corresponding bucket%20 * @param ts - Pointer to table_string datastructure%20 * @param word - Pointer to string to search for%20 * @return * Find*%20 */%20void table_string_insert_or_add(table_string *ts, char *word, int line) {%20  // Find the bucket for word. djb2 will return a value between 0-buckets-1.%20  // Rule: buckets can only be power of 2.%20  int bucket = djb2_word_to_bucket(word, ts->buckets);%20  // TODO:%20  // Case head == NULL: bucket hasn't been initialized yet%20  // Case word already in list, add to line array.%20  // Case word not found, insert word and return.%20}%20%20void table_string_deallocate(table_string *ts) {%20  // TODO:%20  // Free the linked list of each bucket%20  // Free the array of head pointers%20  // Free the structure itself%20  return;%20}%20%20void table_string_print(table_string *ts) {%20  /** TODO:%20   for each bucket%20    for each entry in bucket%20      print entry->word: line line line%20  */%20}%20 | 1
2025-09-22 11:10:44.169 | Query: How does my allocate function look?%20#include "table_string.h"%20#include "str_cmp.h"%20#include <stdbool.h>%20#include <stdint.h>%20#include <stdio.h>%20#include <stdlib.h>%20#include <string.h>%20%20#define BUCKETS%20// DO NOT ADD ANY NEW FUNCTIONS BEFORE djb2%20// Hash a character array to integer value between 0 and buckets-1.%20// See here for more details: https://theartincode.stanis.me/008-djb2/%20unsigned int djb2_word_to_bucket(char *word, int buckets) {%20  if (!word) {%20    printf("Invoked with null string");%20    exit(EXIT_FAILURE);%20  }%20  unsigned long hash = 5381;%20  uint32_t i;%20%20  for (i = 0; i < strlen(word); i++)%20    hash = ((hash << 5) + hash) + word[i];%20%20  return hash & (buckets - 1);%20}%20// ADD YOUR HELPER FUNCTIONS AFTER djb2%20/**%20 * @brief Instantiate a table string%20 *%20 * @param buckets%20 * @return table_string*%20 */%20table_string *table_string_allocate(unsigned int buckets) {%20  // Instantiate a bucket number of heads%20  table_string = new table_string();%20  table_string -> buckets = buckets;%20}%20%20/**%20 * @brief Insert the string pointed to by word into the table string.%20 *   If word is already found increment count.%20 *   If word is not found insert at the end of the corresponding bucket%20 * @param ts - Pointer to table_string datastructure%20 * @param word - Pointer to string to search for%20 * @return * Find*%20 */%20void table_string_insert_or_add(table_string *ts, char *word, int line) {%20  // Find the bucket for word. djb2 will return a value between 0-buckets-1.%20  // Rule: buckets can only be power of 2.%20  int bucket = djb2_word_to_bucket(word, ts->buckets);%20  // TODO:%20  // Case head == NULL: bucket hasn't been initialized yet%20  // Case word already in list, add to line array.%20  // Case word not found, insert word and return.%20}%20%20void table_string_deallocate(table_string *ts) {%20  // TODO:%20  // Free the linked list of each bucket%20  // Free the array of head pointers%20  // Free the structure itself%20  return;%20}%20%20void table_string_print(table_string *ts) {%20  /** TODO:%20   for each bucket%20    for each entry in bucket%20      print entry->word: line line line%20  */%20}%20%20%20#ifndef table_string_H%20#define table_string_H%20#define POS_COUNT%20%20#include "vector_string.h"%20#include <stdbool.h>%20%20// Struct describing the data structure table_string%20// head* points to the entry which is the start of vector string%20typedef struct table_string {%20  vs_entry_t **heads; // Array to maintain the heads of each bucket.%20  int buckets;        // Buckets can only be a power of 2.%20} table_string;%20%20/**%20 * @brief Memory allocate a vector string so that we can start inserting entries%20 * into it.%20 *%20 */%20table_string *table_string_allocate(unsigned int buckets);%20%20/**%20 * @brief function that returns a value between 1%20 */%20unsigned int djb2_word_to_bucket(char *key, int buckets);%20%20/**%20 * @brief If word does not exist, Insert the string pointed to by key into the%20 * table string If word exists, then simply increment the count in vs_entry_t%20 *%20 * @param vs - Pointer to table_string datastructure%20 * @param key - Pointer to string to search for%20 * @return * .%20 */%20void table_string_insert_or_add(table_string *vs, char *word, int line);%20/**%20 * @brief Remove all entries and cleanup vector string%20 * TODO: Remove all entries. Remember head and tail are pointers.%20 * Remember to remove vs as well; not just entries. or you will have memory%20 * leaks.%20 * @param vs: Pointer to table_string struct%20 */%20void table_string_deallocate(table_string *vs);%20%20/**%20 * @brief Print all value in each entry of the vector string, one line at a time%20 * [hello]%20 * [world]%20 * @param vs%20 */%20void table_string_print(table_string *vs);%20#endif%20 | 1
2025-09-22 11:59:18.608 | Query: How do I add a line to a bucket?%20#include "table_string.h"%20#include "str_cmp.h"%20#include <stdbool.h>%20#include <stdint.h>%20#include <stdio.h>%20#include <stdlib.h>%20#include <string.h>%20%20#define BUCKETS%20// DO NOT ADD ANY NEW FUNCTIONS BEFORE djb2%20// Hash a character array to integer value between 0 and buckets-1.%20// See here for more details: https://theartincode.stanis.me/008-djb2/%20unsigned int djb2_word_to_bucket(char *word, int buckets) {%20  if (!word) {%20    printf("Invoked with null string");%20    exit(EXIT_FAILURE);%20  }%20  unsigned long hash = 5381;%20  uint32_t i;%20%20  for (i = 0; i < strlen(word); i++)%20    hash = ((hash << 5) + hash) + word[i];%20%20  return hash & (buckets - 1);%20}%20// ADD YOUR HELPER FUNCTIONS AFTER djb2%20/**%20 * @brief Instantiate a table string%20 *%20 * @param buckets%20 * @return table_string*%20 */%20table_string *table_string_allocate(unsigned int buckets) {%20  // Instantiate a bucket number of heads%20  table_string = new table_string();%20  table_string -> buckets = buckets;%20}%20%20/**%20 * @brief Insert the string pointed to by word into the table string.%20 *   If word is already found increment count.%20 *   If word is not found insert at the end of the corresponding bucket%20 * @param ts - Pointer to table_string datastructure%20 * @param word - Pointer to string to search for%20 * @return * Find*%20 */%20void table_string_insert_or_add(table_string *ts, char *word, int line) {%20  // Find the bucket for word. djb2 will return a value between 0-buckets-1.%20  // Rule: buckets can only be power of 2.%20  int bucket = djb2_word_to_bucket(word, ts->buckets);%20  // TODO:%20  // Case head == NULL: bucket hasn't been initialized yet%20  // Case word already in list, add to line array.%20  // Case word not found, insert word and return.%20}%20%20void table_string_deallocate(table_string *ts) {%20  // TODO:%20  // Free the linked list of each bucket%20  // Free the array of head pointers%20  // Free the structure itself%20  return;%20}%20%20void table_string_print(table_string *ts) {%20  /** TODO:%20   for each bucket%20    for each entry in bucket%20      print entry->word: line line line%20  */%20}%20%20%20#ifndef table_string_H%20#define table_string_H%20#define POS_COUNT%20%20#include "vector_string.h"%20#include <stdbool.h>%20%20// Struct describing the data structure table_string%20// head* points to the entry which is the start of vector string%20typedef struct table_string {%20  vs_entry_t **heads; // Array to maintain the heads of each bucket.%20  int buckets;        // Buckets can only be a power of 2.%20} table_string;%20%20/**%20 * @brief Memory allocate a vector string so that we can start inserting entries%20 * into it.%20 *%20 */%20table_string *table_string_allocate(unsigned int buckets);%20%20/**%20 * @brief function that returns a value between 1%20 */%20unsigned int djb2_word_to_bucket(char *key, int buckets);%20%20/**%20 * @brief If word does not exist, Insert the string pointed to by key into the%20 * table string If word exists, then simply increment the count in vs_entry_t%20 *%20 * @param vs - Pointer to table_string datastructure%20 * @param key - Pointer to string to search for%20 * @return * .%20 */%20void table_string_insert_or_add(table_string *vs, char *word, int line);%20/**%20 * @brief Remove all entries and cleanup vector string%20 * TODO: Remove all entries. Remember head and tail are pointers.%20 * Remember to remove vs as well; not just entries. or you will have memory%20 * leaks.%20 * @param vs: Pointer to table_string struct%20 */%20void table_string_deallocate(table_string *vs);%20%20/**%20 * @brief Print all value in each entry of the vector string, one line at a time%20 * [hello]%20 * [world]%20 * @param vs%20 */%20void table_string_print(table_string *vs);%20#endif%20 | 1
2025-09-22 12:10:33.902 | Query: How do I add a line to a bucket?%20#include "table_string.h"%20#include "str_cmp.h"%20#include <stdbool.h>%20#include <stdint.h>%20#include <stdio.h>%20#include <stdlib.h>%20#include <string.h>%20%20#define BUCKETS%20// DO NOT ADD ANY NEW FUNCTIONS BEFORE djb2%20// Hash a character array to integer value between 0 and buckets-1.%20// See here for more details: https://theartincode.stanis.me/008-djb2/%20unsigned int djb2_word_to_bucket(char *word, int buckets) {%20  if (!word) {%20    printf("Invoked with null string");%20    exit(EXIT_FAILURE);%20  }%20  unsigned long hash = 5381;%20  uint32_t i;%20%20  for (i = 0; i < strlen(word); i++)%20    hash = ((hash << 5) + hash) + word[i];%20%20  return hash & (buckets - 1);%20}%20// ADD YOUR HELPER FUNCTIONS AFTER djb2%20/**%20 * @brief Instantiate a table string%20 *%20 * @param buckets%20 * @return table_string*%20 */%20table_string *table_string_allocate(unsigned int buckets) {%20  // Instantiate a bucket number of heads%20  table_string = new table_string();%20  table_string -> buckets = buckets;%20}%20%20/**%20 * @brief Insert the string pointed to by word into the table string.%20 *   If word is already found increment count.%20 *   If word is not found insert at the end of the corresponding bucket%20 * @param ts - Pointer to table_string datastructure%20 * @param word - Pointer to string to search for%20 * @return * Find*%20 */%20void table_string_insert_or_add(table_string *ts, char *word, int line) {%20  // Find the bucket for word. djb2 will return a value between 0-buckets-1.%20  // Rule: buckets can only be power of 2.%20  int bucket = djb2_word_to_bucket(word, ts->buckets);%20  // TODO:%20  // Case head == NULL: bucket hasn't been initialized yet%20  // Case word already in list, add to line array.%20  // Case word not found, insert word and return.%20}%20%20void table_string_deallocate(table_string *ts) {%20  // TODO:%20  // Free the linked list of each bucket%20  // Free the array of head pointers%20  // Free the structure itself%20  return;%20}%20%20void table_string_print(table_string *ts) {%20  /** TODO:%20   for each bucket%20    for each entry in bucket%20      print entry->word: line line line%20  */%20}%20%20%20#ifndef table_string_H%20#define table_string_H%20#define POS_COUNT%20%20#include "vector_string.h"%20#include <stdbool.h>%20%20// Struct describing the data structure table_string%20// head* points to the entry which is the start of vector string%20typedef struct table_string {%20  vs_entry_t **heads; // Array to maintain the heads of each bucket.%20  int buckets;        // Buckets can only be a power of 2.%20} table_string;%20%20/**%20 * @brief Memory allocate a vector string so that we can start inserting entries%20 * into it.%20 *%20 */%20table_string *table_string_allocate(unsigned int buckets);%20%20/**%20 * @brief function that returns a value between 1%20 */%20unsigned int djb2_word_to_bucket(char *key, int buckets);%20%20/**%20 * @brief If word does not exist, Insert the string pointed to by key into the%20 * table string If word exists, then simply increment the count in vs_entry_t%20 *%20 * @param vs - Pointer to table_string datastructure%20 * @param key - Pointer to string to search for%20 * @return * .%20 */%20void table_string_insert_or_add(table_string *vs, char *word, int line);%20/**%20 * @brief Remove all entries and cleanup vector string%20 * TODO: Remove all entries. Remember head and tail are pointers.%20 * Remember to remove vs as well; not just entries. or you will have memory%20 * leaks.%20 * @param vs: Pointer to table_string struct%20 */%20void table_string_deallocate(table_string *vs);%20%20/**%20 * @brief Print all value in each entry of the vector string, one line at a time%20 * [hello]%20 * [world]%20 * @param vs%20 */%20void table_string_print(table_string *vs);%20#endif%20%20typedef struct vs_entry {%20  char *value;%20  struct vs_entry *next;%20%20// Conditionally compiled in code. Not relevant for part 2. You can assume the%20// int count declaration does not exist and is irrelevant for part 2.%20#ifdef POS_COUNT%20  int* pos; // This keeps track of each pos the word is found in%20  int  size_of_pos; // This keeps size of pos. Remember in C we track array size explicitly.%20#endif%20} vs_entry_t;%20%20// Struct describing the data structure vector_string%20// head* points to the entry which is the start of vector string%20typedef struct vector_string {%20  vs_entry_t *head;%20  vs_entry_t *tail;%20} vector_string;%20%20/**%20 * @brief Memory allocate a vector string so that we can start inserting entries%20 * into it.%20 *%20 */%20vector_string *vector_string_allocate();%20%20/**%20 * @brief Search the vector string pointed to by vs and return the entry if the%20 * vs_entry.value == key.%20 * TODO:%20 * @param vs - Pointer to vector_string datastructure%20 * @param key - Pointer to string to search for%20 * @return * Find*%20 */%20bool vector_string_find(vector_string *vs, char *key);%20%20/**%20 * @brief Insert the string pointed to by key into the vector string.%20 *  TODO: char* is externally allocated. You do not have to allocate internally%20 * @param vs - Pointer to vector_string datastructure%20 * @param key - Pointer to string to search for%20 * @return * Find*%20 */%20void vector_string_insert(vector_string *vs, char *key);%20/ | 1
2025-09-22 12:28:29.418 | Topic: How do pointers work | 1
2025-09-22 12:28:30.663 | Topic: How do pointers work | 1
2025-09-22 12:28:32.008 | Topic: How do pointers work | 1
2025-09-22 12:28:49.394 | Query: What is assignment 1? | 1
2025-09-22 12:29:55.435 | Query: How would I write a C function that bit shifts arg x by 6 bits | 1
2025-09-22 13:25:47.540 | Query: where in the course dud we cver how to know what is the umer f nits needed to reepresemt a 3 digit nase 6 number | 1
2025-09-22 13:26:13.574 | Query: where in the course did we cover how to know what is the numebr of bits needed to represent a 3 digit base 6 number | 1
2025-09-22 13:26:16.591 | Topic: where in the course did we cover how to know what is the numebr of bits needed to represent a 3 digit base 6 number | 1
2025-09-22 13:26:17.732 | Topic: where in the course did we cover how to know what is the numebr of bits needed to represent a 3 digit base 6 number | 1
2025-09-22 13:26:18.312 | Topic: where in the course did we cover how to know what is the numebr of bits needed to represent a 3 digit base 6 number | 1
2025-09-22 13:26:29.702 | Topic: where in the course did we cover how to know what is the numebr of bits needed to represent a 3 digit base 6 number | 1
2025-09-22 13:26:35.348 | Query: where in the course did we cover how to know what is the numebr of bits needed to represent a 3 digit base 6 number | 1
2025-09-22 14:15:30.158 | Query: remind me again we got nested arrays and then the array of pointers right %20the nested arrays basically are a contiguous block of memory, thus any nested array can be represented as one big array but what about an array of pointers, not the same at all we store memory address of sub arrays%20not at all need to be contugous right %20am i getting it? what else should i know to be able to answer any a+ level question on this topic and the surroudning topics%20 | 1
2025-09-22 16:49:37.590 | Query: 28. What base 6 number XXX represents 0? (That is, your answer needs to have 3%20base-6 characters.)? [1]%20Hint%202556%20A 8-bit bias-encoded number presented in class has a bias of -127 so that roughly half the numbers are%20negative. but there’s one more positive than negative number i.e., [-127 to +128]. Using an equivalent%20scheme for choosing the bias,%20There is one more positive number%20Hence answer is 2556%20%20which set of lecture slides cover this%20 | 1
2025-09-22 16:50:37.355 | Query: what lectures cover bias encoding%20%20 | 1
2025-09-22 20:01:49.291 | Query: hi what is the layout of stack heap and static%20 | 1
2025-09-22 20:03:31.495 |  Query: can you give an example for stack heap static and code | Rating: 4  | 1
2025-09-22 20:03:39.850 | Query: can you give an example for stack heap static and code | 1
2025-09-22 20:05:18.144 | Query: how does shifting work | 1
2025-09-22 20:08:36.283 | Query: how does offsets in arrays work | 1
2025-09-22 20:32:17.820 | Query: how many bytes does each type need in a 32 and 64 bit system | 1
2025-09-22 20:33:01.736 | Query: how many bits does each type need in a 32 and 64 bit system | 1
2025-09-22 20:37:55.213 | Query: what is word size | 1
2025-09-22 20:45:02.194 | Query: what is the difference between multi level and nested arrays%20 | 1
2025-09-22 20:46:01.100 | Query: how does padding work | 1
2025-09-22 20:46:40.887 | Query: is there padding after? | 1
2025-09-22 20:47:18.224 | Query: how does padding after a struct work | 1
2025-09-22 20:47:55.849 | Query: who picks kmax | 1
2025-09-22 20:48:08.024 | Query: what is kmax | 1
2025-09-22 20:49:25.395 | Query: how do bit masks work%20 | 1
2025-09-22 20:56:27.883 | Query: what is the formula for accessing nested arrays%20 | 1
2025-09-22 20:57:33.988 | Query: what is the formula for accessing 3d nested arrays%20 | 1
2025-09-22 21:01:18.275 | Topic: what is the formula for accessing 3d nested arrays | 1
2025-09-22 21:01:18.893 | Topic: what is the formula for accessing 3d nested arrays | 1
2025-09-22 21:05:55.627 | Query: what are all the casting surprises%20 | 1
2025-09-22 23:38:40.221 | Query: If x = 0xb and y = 0x5 What is the value of%20z = (A | A) after this statement?%20Write in binary 4 bits | 1
2025-09-23 00:46:25.062 | Query: teach me this asap in bullet points simply%20Revising bitwise operators (!, ~, &, ^, |, <<, >>).%20 | 1
2025-09-23 15:13:57.926 | Topic: What is the number of bits needed to represent a 3 digit base-6 number ? Lets use MSB (most-significant digit) for sign (1- postiive 0-ve) How many numbers can be represented ? | 1
2025-09-23 15:14:14.316 | Query: What is the number of bits needed to represent a 3 digit base-6 number ? Lets use MSB (most-significant digit) for sign (1- postiive 0-ve) How many numbers can be represented ?   | 1
2025-09-23 15:14:50.755 | Topic: What is the number of bits needed to represent a 3 digit base-6 number ? Lets use MSB (most-significant digit) for sign (1- postiive 0-ve) How many numbers can be represented ? | 1
